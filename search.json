[{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"constraint-functions","dir":"Articles","previous_headings":"","what":"Constraint Functions","title":"Constraints, Partitions, and Compositions","text":"5 compiled constraint functions can utilized efficiently test given result. sum prod mean max min passed strings constraintFun parameter. employed without parameters set, additional column added represents result applying given function combination/permutation. can also set keepResults = TRUE (later).","code":"library(RcppAlgos) options(width = 90)  packageVersion(\"RcppAlgos\") #> [1] '2.9.2'  cat(paste(capture.output(sessionInfo())[1:3], collapse = \"\\n\")) #> R version 4.4.2 (2024-10-31) #> Platform: aarch64-apple-darwin20 #> Running under: macOS Sonoma 14.5  ## base R using combn and FUN combnSum = combn(20, 10, sum) algosSum = comboGeneral(20, 10, constraintFun = \"sum\")  ## Notice the additional column (i.e. the 11th column) head(algosSum) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #> [1,]    1    2    3    4    5    6    7    8    9    10    55 #> [2,]    1    2    3    4    5    6    7    8    9    11    56 #> [3,]    1    2    3    4    5    6    7    8    9    12    57 #> [4,]    1    2    3    4    5    6    7    8    9    13    58 #> [5,]    1    2    3    4    5    6    7    8    9    14    59 #> [6,]    1    2    3    4    5    6    7    8    9    15    60  identical(as.integer(combnSum), algosSum[,11]) #> [1] TRUE  ## Using parallel paralSum = comboGeneral(20, 10, constraintFun = \"sum\", Parallel = TRUE) identical(paralSum, algosSum) #> [1] TRUE  library(microbenchmark) microbenchmark(serial = comboGeneral(20, 10, constraintFun = \"sum\"),              parallel = comboGeneral(20, 10, constraintFun = \"sum\", Parallel = TRUE),              combnSum = combn(20, 10, sum), unit = \"relative\") #> Warning in microbenchmark(serial = comboGeneral(20, 10, constraintFun = \"sum\"), : less #> accurate nanosecond times to avoid potential integer overflows #> Unit: relative #>      expr        min         lq       mean     median         uq       max neval #>    serial   3.485355   3.291729   2.914214   3.197378   3.010128  1.716721   100 #>  parallel   1.000000   1.000000   1.000000   1.000000   1.000000  1.000000   100 #>  combnSum 171.180306 157.361966 133.895925 151.336700 139.596890 64.992480   100"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"faster-than-rowsums-and-rowmeans","dir":"Articles","previous_headings":"Constraint Functions","what":"Faster than rowSums and rowMeans","title":"Constraints, Partitions, and Compositions","text":"Finding row sums row means even faster simply applying highly efficient rowSums/rowMeans combinations already generated: cases , RcppAlgos double work nearly twice fast!!!","code":"## Pre-generate combinations combs = comboGeneral(25, 10)  ## Testing rowSums alone against generating combinations as well as summing microbenchmark(serial = comboGeneral(25, 10, constraintFun = \"sum\"),              parallel = comboGeneral(25, 10, constraintFun = \"sum\", Parallel = TRUE),               rowsums = rowSums(combs), unit = \"relative\") #> Unit: relative #>      expr      min       lq     mean   median       uq      max neval #>    serial 3.282834 3.118272 2.961110 2.873113 2.805536 3.622693   100 #>  parallel 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000   100 #>   rowsums 1.882470 1.857191 1.762444 1.684538 1.678611 1.722250   100  all.equal(rowSums(combs),           comboGeneral(25, 10,                        constraintFun = \"sum\",                        Parallel = TRUE)[,11]) #> [1] TRUE  ## Testing rowMeans alone against generating combinations as well as obtain row means microbenchmark(serial = comboGeneral(25, 10, constraintFun = \"mean\"),              parallel = comboGeneral(25, 10, constraintFun = \"mean\", Parallel = TRUE),              rowmeans = rowMeans(combs), unit = \"relative\") #> Unit: relative #>      expr      min       lq     mean   median       uq      max neval #>    serial 2.540918 2.273344 2.198220 2.233083 2.172085 1.593756   100 #>  parallel 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000   100 #>  rowmeans 1.520303 1.303887 1.271082 1.282142 1.248715 1.201293   100  all.equal(rowMeans(combs),           comboGeneral(25, 10,                        constraintFun = \"mean\",                        Parallel = TRUE)[,11]) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"comparison-operators-and-limitconstraints","dir":"Articles","previous_headings":"","what":"Comparison Operators and limitConstraints","title":"Constraints, Partitions, and Compositions","text":"standard 5 comparison operators (.e. \"<\", \">\", \"<=\", \">=\", & \"==\") can used variety ways. order effect, must used conjunction constraintFun well limitConstraints. latter value(s) used comparison. can passed single value vector two numerical values. useful one wants find results (outside) given range.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"one-comparison-operator","dir":"Articles","previous_headings":"Comparison Operators and limitConstraints","what":"One Comparison Operator","title":"Constraints, Partitions, and Compositions","text":"First look cases one comparison one value limitConstraint.","code":"## Generate some random data. N.B. Using R >= 4.0.0 set.seed(101) myNums = sample(500, 20)  myNums #>  [1] 329 313 430  95 209 442 351 317 444 315 246 355 128 131 288   9 352 489 354 244  ## Find all 5-tuples combinations without repetition of myNums ## (defined above) such that the sum is equal to 1176. p1 = comboGeneral(v = myNums, m = 5,                   constraintFun = \"sum\",                   comparisonFun = \"==\",                   limitConstraints = 1176)  tail(p1) #>       [,1] [,2] [,3] [,4] [,5] #> [10,]   95  128  246  352  355 #> [11,]   95  128  288  313  352 #> [12,]   95  131  244  351  355 #> [13,]   95  131  244  352  354 #> [14,]   95  209  244  313  315 #> [15,]  128  131  246  317  354   ## Authenticate with brute force allCombs = comboGeneral(sort(myNums), 5) identical(p1, allCombs[which(rowSums(allCombs) == 1176), ]) #> [1] TRUE   ## How about finding combinations with repetition ## whose mean is less than or equal to 150. p2 = comboGeneral(v = myNums, m = 5, TRUE,                   constraintFun = \"mean\",                   comparisonFun = \"<=\",                   limitConstraints = 150)  ## Again, we authenticate with brute force allCombs = comboGeneral(sort(myNums), 5, TRUE) identical(p2, allCombs[which(rowMeans(allCombs) <= 150), ]) #> [1] FALSE  ### <-- What? They should be the same  ## N.B. class(p2[1, ]) #> [1] \"numeric\"  class(allCombs[1, ]) #> [1] \"integer\"  ## When mean is employed or it can be determined that integral ## values will not suffice for the comparison, we fall back to ## numeric types, thus all.equal should return TRUE all.equal(p2, allCombs[which(rowMeans(allCombs) <= 150), ]) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"two-comparison-operators","dir":"Articles","previous_headings":"Comparison Operators and limitConstraints","what":"Two Comparison Operators","title":"Constraints, Partitions, and Compositions","text":"Sometimes, need generate combinations/permutations apply constraint function, results (outside) given range. natural two step process finding results outside range, however finding results range, two step approach become computationally demanding. underlying algorithms RcppAlgos optimized cases avoids adding results eventually removed. Using two comparisons easy. first comparison operator applied first limit second operator applied second limit. Note examples , keepResults = TRUE. means additional column added output result applying constraintFun particular combination.","code":"## Get combinations such that the product is ## strictly between 3600 and 4000 comboGeneral(5, 7, TRUE, constraintFun = \"prod\",              comparisonFun = c(\">\",\"<\"),          ## Find results > 3600 and < 4000              limitConstraints = c(3600, 4000),              keepResults = TRUE) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    2    3    5    5    5    5 3750 #> [2,]    1    3    4    4    4    4    5 3840 #> [3,]    2    2    3    4    4    4    5 3840 #> [4,]    3    3    3    3    3    3    5 3645 #> [5,]    3    3    3    3    3    4    4 3888  # ## The above is the same as doing the following: # comboGeneral(5, 7, TRUE, constraintFun = \"prod\", #              comparisonFun = c(\"<\",\">\"),          ## Note that the comparison vector #              limitConstraints = c(4000, 3600),    ## and the limits have flipped #              keepResults = TRUE)   ## What about finding combinations outside a range outside = comboGeneral(5, 7, TRUE, constraintFun = \"prod\",                        comparisonFun = c(\"<=\",\">=\"),                        limitConstraints = c(3600, 4000),                        keepResults = TRUE)  all(apply(outside[, -8], 1, prod) <= 3600      | apply(outside[, -8], 1, prod) >= 4000) #> [1] TRUE  dim(outside) #> [1] 325   8  ## Note that we obtained 5 results when searching \"between\" ## 3600 and 4000. Thus we have: 325 + 5 = 330 comboCount(5, 7, T) #> [1] 330"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"using-tolerance","dir":"Articles","previous_headings":"Comparison Operators and limitConstraints","what":"Using tolerance","title":"Constraints, Partitions, and Compositions","text":"underlying type numeric, round-errors can occur. stated floating-point error mitigation: “definition, floating-point error eliminated, , best, can managed.” great stackoverflow post illuminates tricky topic: correct/standard way check difference smaller machine precision? reasons, argument tolerance can utilized refine given constraint. added upper limit subtracted lower limit. default value sqrt(.Machine$double.eps) ~= 0.00000001490116. default value good bad. good side: tolerance zero, obtained incorrect result: now less desirable result. example appears give incorrect results. , shouldn’t return combination mean 4.1 5.1. example, range actually tested c(4.0999999950329462, 5.1000000049670531). want absolutely sure getting correct results, one must rely integers simple changes arithmetic can throw precision floating point operations.","code":"dim(comboGeneral(seq(0, 0.5, 0.05), 6, TRUE,                  constraintFun = \"sum\",                  comparisonFun = \"==\",                  limitConstraints = 1)) #> [1] 199   6  ## Confirm with integers and brute force allCbs = comboGeneral(seq(0L, 50L, 5L), 6, TRUE, constraintFun = \"sum\")  sum(allCbs[, 7] == 100L) #> [1] 199 ## We miss 31 combinations that add up to 1 dim(comboGeneral(seq(0, 0.5, 0.05), 6, TRUE,                  constraintFun = \"sum\",                  comparisonFun = \"==\",                  limitConstraints = 1, tolerance = 0)) #> [1] 168   6 comboGeneral(c(2.1, 3.1, 5.1, 7.1), 3, T,              constraintFun = \"mean\", comparisonFun = c(\"<\", \">\"),              limitConstraints = c(5.1, 4.1), keepResults = TRUE) #>      [,1] [,2] [,3]     [,4] #> [1,]  2.1  3.1  7.1 4.100000 #> [2,]  2.1  5.1  5.1 4.100000 #> [3,]  2.1  5.1  7.1 4.766667 #> [4,]  3.1  3.1  7.1 4.433333 #> [5,]  3.1  5.1  5.1 4.433333 #> [6,]  3.1  5.1  7.1 5.100000 #> [7,]  5.1  5.1  5.1 5.100000 comboGeneral(c(21, 31, 51, 71), 3, T,              constraintFun = \"mean\", comparisonFun = c(\"<\", \">\"),              limitConstraints = c(51, 41), keepResults = TRUE) / 10 #>      [,1] [,2] [,3]     [,4] #> [1,]  2.1  5.1  7.1 4.766667 #> [2,]  3.1  3.1  7.1 4.433333 #> [3,]  3.1  5.1  5.1 4.433333"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"output-order-with-permutegeneral","dir":"Articles","previous_headings":"Comparison Operators and limitConstraints","what":"Output Order with permuteGeneral","title":"Constraints, Partitions, and Compositions","text":"Typically, call permuteGeneral, output lexicographical order, however apply constraint, underlying algorithm checks combinations , efficient. particular combination meets constraint, permutations vector also meet constraint, need check . reason, output isn’t order. Observe: can see, 2nd 6th entries simply permutations 1st entry. Similarly, entries 8 9 permutations 7th entries 11 12 permutations 10th.","code":"permuteGeneral(c(2, 3, 5, 7), 3, freqs = rep(2, 4),                constraintFun = \"mean\", comparisonFun = c(\">\", \"<\"),                limitConstraints = c(4, 5), keepResults = TRUE, tolerance = 0) #>       [,1] [,2] [,3]     [,4] #>  [1,]    2    5    7 4.666667   ### <-- First combination that meets the criteria #>  [2,]    2    7    5 4.666667 #>  [3,]    5    2    7 4.666667 #>  [4,]    5    7    2 4.666667 #>  [5,]    7    2    5 4.666667 #>  [6,]    7    5    2 4.666667 #>  [7,]    3    3    7 4.333333   ### <-- Second combination that meets the criteria #>  [8,]    3    7    3 4.333333 #>  [9,]    7    3    3 4.333333 #> [10,]    3    5    5 4.333333   ### <-- Third combination that meets the criteria #> [11,]    5    3    5 4.333333 #> [12,]    5    5    3 4.333333"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"integer-partitions","dir":"Articles","previous_headings":"","what":"Integer Partitions","title":"Constraints, Partitions, and Compositions","text":"Specialized algorithms employed can determined looking integer partitions. version 2.5.0, now added partitionsGeneral similar comboGeneral constraintFun = \"sum\" comparisonFun = \"==\". Instead using general limitConstraints parameter, use target default max(v) seems fitting partitions.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-1-all-integer-partitions-of-n","dir":"Articles","previous_headings":"Integer Partitions","what":"Case 1: All Integer Partitions of N","title":"Constraints, Partitions, and Compositions","text":"need v = 0:N, repetition = TRUE. leave m = NULL, m internally set length longest non-zero combination (true cases ).","code":"partitionsGeneral(0:5, repetition = TRUE) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    0    5 #> [2,]    0    0    0    1    4 #> [3,]    0    0    0    2    3 #> [4,]    0    0    1    1    3 #> [5,]    0    0    1    2    2 #> [6,]    0    1    1    1    2 #> [7,]    1    1    1    1    1  ## Note that we could also use comboGeneral: ## comboGeneral(0:5, repetition = TRUE, ##              constraintFun = \"sum\", ##              comparisonFun = \"==\", limitConstraints = 5) ## ## The same goes for any of the examples below"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-2-integer-partitions-of-n-of-length-m","dir":"Articles","previous_headings":"Integer Partitions","what":"Case 2: Integer Partitions of N of Length m","title":"Constraints, Partitions, and Compositions","text":"Everything except explicitly setting desired length deciding whether include zero .","code":"## Including zero partitionsGeneral(0:5, 3, repetition = TRUE) #>      [,1] [,2] [,3] #> [1,]    0    0    5 #> [2,]    0    1    4 #> [3,]    0    2    3 #> [4,]    1    1    3 #> [5,]    1    2    2  ## Zero not included partitionsGeneral(5, 3, repetition = TRUE) #>      [,1] [,2] [,3] #> [1,]    1    1    3 #> [2,]    1    2    2"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-3-integer-partitions-of-n-into-distinct-parts","dir":"Articles","previous_headings":"Integer Partitions","what":"Case 3: Integer Partitions of N into Distinct Parts","title":"Constraints, Partitions, and Compositions","text":"Case 1 & 2 except now repetition = FALSE.","code":"partitionsGeneral(0:10) #>      [,1] [,2] [,3] [,4] #> [1,]    0    1    2    7 #> [2,]    0    1    3    6 #> [3,]    0    1    4    5 #> [4,]    0    2    3    5 #> [5,]    1    2    3    4  ## Zero not included and restrict the length partitionsGeneral(10, 3) #>      [,1] [,2] [,3] #> [1,]    1    2    7 #> [2,]    1    3    6 #> [3,]    1    4    5 #> [4,]    2    3    5  ## Include zero and restrict the length partitionsGeneral(0:10, 3) #>      [,1] [,2] [,3] #> [1,]    0    1    9 #> [2,]    0    2    8 #> [3,]    0    3    7 #> [4,]    0    4    6 #> [5,]    1    2    7 #> [6,]    1    3    6 #> [7,]    1    4    5 #> [8,]    2    3    5  ## partitions of 10 into distinct parts of every length lapply(1:4, function(x) {     partitionsGeneral(10, x) }) #> [[1]] #>      [,1] #> [1,]   10 #>  #> [[2]] #>      [,1] [,2] #> [1,]    1    9 #> [2,]    2    8 #> [3,]    3    7 #> [4,]    4    6 #>  #> [[3]] #>      [,1] [,2] [,3] #> [1,]    1    2    7 #> [2,]    1    3    6 #> [3,]    1    4    5 #> [4,]    2    3    5 #>  #> [[4]] #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    3    4"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"using-freqs-to-refine-length","dir":"Articles","previous_headings":"Integer Partitions > Case 3: Integer Partitions of N into Distinct Parts","what":"Using freqs to Refine Length","title":"Constraints, Partitions, and Compositions","text":"can utilize freqs argument obtain distinct partitions allowing repeated zeros. super optimized algorithm carried zero included number repetitions every number except zero one. example, given v = 0:N J >= 1, freqs = c(J, rep(1, N)), super optimized algorithm used, however freqs = c(J, 2, rep(1, N - 1)), general algorithm used. noted general algorithms still highly optimized one fear using . pattern guaranteed retrieve distinct partitions N set v = 0:N freqs = c(N, rep(1, N)) (extra zeros left ).","code":"## Obtain all distinct partitions of 10 partitionsGeneral(0:10, freqs = c(10, rep(1, 10)))    ## Same as c(3, rep(1, 10)) #>       [,1] [,2] [,3] [,4] #>  [1,]    0    0    0   10 #>  [2,]    0    0    1    9 #>  [3,]    0    0    2    8 #>  [4,]    0    0    3    7 #>  [5,]    0    0    4    6 #>  [6,]    0    1    2    7 #>  [7,]    0    1    3    6 #>  [8,]    0    1    4    5 #>  [9,]    0    2    3    5 #> [10,]    1    2    3    4"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"caveats-using-freqs","dir":"Articles","previous_headings":"Integer Partitions > Case 3: Integer Partitions of N into Distinct Parts","what":"Caveats Using freqs","title":"Constraints, Partitions, and Compositions","text":"noted Case 1, m = NULL, length output determined longest non-zero combination sums N.","code":"## m is NOT NULL and output has at most 2 zeros partitionsGeneral(0:10, 3, freqs = c(2, rep(1, 10))) #>       [,1] [,2] [,3] #>  [1,]    0    0   10 #>  [2,]    0    1    9 #>  [3,]    0    2    8 #>  [4,]    0    3    7 #>  [5,]    0    4    6 #>  [6,]    1    2    7 #>  [7,]    1    3    6 #>  [8,]    1    4    5 #>  [9,]    2    3    5  ## m is NULL and output has at most 2 zeros partitionsGeneral(0:10, freqs = c(2, rep(1, 10))) #>       [,1] [,2] [,3] [,4] #>  [1,]    0    0    1    9 #>  [2,]    0    0    2    8 #>  [3,]    0    0    3    7 #>  [4,]    0    0    4    6 #>  [5,]    0    1    2    7 #>  [6,]    0    1    3    6 #>  [7,]    0    1    4    5 #>  [8,]    0    2    3    5 #>  [9,]    1    2    3    4"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-4-integer-partitions-of-n-into-parts-of-varying-multiplicity","dir":"Articles","previous_headings":"Integer Partitions","what":"Case 4: Integer Partitions of N into Parts of Varying Multiplicity","title":"Constraints, Partitions, and Compositions","text":"","code":"## partitions of 12 into 4 parts where each part can ## be used a specific number of times (e.g. 2 or 3) partitionsGeneral(12, 4, freqs = rep(2:3, 6)) #>       [,1] [,2] [,3] [,4] #>  [1,]    1    1    2    8 #>  [2,]    1    1    3    7 #>  [3,]    1    1    4    6 #>  [4,]    1    1    5    5 #>  [5,]    1    2    2    7 #>  [6,]    1    2    3    6 #>  [7,]    1    2    4    5 #>  [8,]    1    3    3    5 #>  [9,]    1    3    4    4 #> [10,]    2    2    2    6 #> [11,]    2    2    3    5 #> [12,]    2    2    4    4 #> [13,]    2    3    3    4"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"efficiency-generating-partitions","dir":"Articles","previous_headings":"","what":"Efficiency Generating Partitions","title":"Constraints, Partitions, and Compositions","text":"Note, version 2.5.0, one can generate partitions parallel using nThreads argument.","code":"## partitions of 60 partitionsCount(0:60, repetition = TRUE) #> [1] 966467  ## Single threaded system.time(partitionsGeneral(0:60, repetition = TRUE)) #>    user  system elapsed  #>   0.030   0.013   0.056  ## Using nThreads system.time(partitionsGeneral(0:60, repetition = TRUE, nThreads=4)) #>    user  system elapsed  #>   0.032   0.021   0.014   ## partitions of 120 into distinct parts partitionsCount(0:120, freqs = c(120, rep(1, 120))) #> [1] 2194432  system.time(partitionsGeneral(0:120, freqs = c(120, rep(1, 120)))) #>    user  system elapsed  #>   0.020   0.006   0.026  system.time(partitionsGeneral(0:120, freqs = c(120, rep(1, 120)), nThreads=4)) #>    user  system elapsed  #>   0.022   0.005   0.008   ## partitions of 100 into parts of 15 with specific multiplicity partitionsCount(100, 15, freqs = rep(4:8, 20)) #> [1] 6704215  ## Over 6 million in just over a second! system.time(partitionsGeneral(100, 15, freqs = rep(4:8, 20))) #>    user  system elapsed  #>   0.246   0.082   0.329"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"integer-compositions","dir":"Articles","previous_headings":"","what":"Integer Compositions","title":"Constraints, Partitions, and Compositions","text":"Compositions related integer partitions, however order matters. RcppAlgos, generate standard compositions compositionsGeneral. Currently, composition algorithms limited subset cases compositions repetiion. output compositionGeneral lexicographical order. set weak = TRUE, obtain weak compositions, allow zeros part sequence (E.g. c(0, 0, 5), c(0, 5, 0), c(5, 0, 0) weak compositions 5). Wikipedia article points , can increase number zeros indefinitely weak = TRUE. general cases, can make use permuteGeneral, keeping mind output lexicographical order. Another consideration permuteGeneral include zero, always obtain weak compositions. mind, generating compositions RcppAlgos easy, flexible, quite efficient.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-5-all-compositions-of-n","dir":"Articles","previous_headings":"Integer Compositions","what":"Case 5: All Compositions of N","title":"Constraints, Partitions, and Compositions","text":"","code":"## See Case 1 compositionsGeneral(0:3, repetition = TRUE) #>      [,1] [,2] [,3] #> [1,]    0    0    3 #> [2,]    0    1    2 #> [3,]    0    2    1 #> [4,]    1    1    1  ## Get weak compositions compositionsGeneral(0:3, repetition = TRUE, weak = TRUE) #>       [,1] [,2] [,3] #>  [1,]    0    0    3 #>  [2,]    0    1    2 #>  [3,]    0    2    1 #>  [4,]    0    3    0 #>  [5,]    1    0    2 #>  [6,]    1    1    1 #>  [7,]    1    2    0 #>  [8,]    2    0    1 #>  [9,]    2    1    0 #> [10,]    3    0    0  ## Get weak compositions with width > than target tail(compositionsGeneral(0:3, 10, repetition = TRUE, weak = TRUE)) #>        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [215,]    2    0    0    0    0    1    0    0    0     0 #> [216,]    2    0    0    0    1    0    0    0    0     0 #> [217,]    2    0    0    1    0    0    0    0    0     0 #> [218,]    2    0    1    0    0    0    0    0    0     0 #> [219,]    2    1    0    0    0    0    0    0    0     0 #> [220,]    3    0    0    0    0    0    0    0    0     0  ## With permuteGeneral, we always get weak compositions, just ## not in lexicographical order permuteGeneral(0:3, repetition = TRUE,                constraintFun = \"sum\",                comparisonFun = \"==\", limitConstraints = 3) #>       [,1] [,2] [,3] #>  [1,]    0    0    3 #>  [2,]    0    3    0 #>  [3,]    3    0    0 #>  [4,]    0    1    2 #>  [5,]    0    2    1 #>  [6,]    1    0    2 #>  [7,]    1    2    0 #>  [8,]    2    0    1 #>  [9,]    2    1    0 #> [10,]    1    1    1  tail(permuteGeneral(0:3, 10, repetition = TRUE,                     constraintFun = \"sum\",                     comparisonFun = \"==\", limitConstraints = 3)) #>        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [215,]    1    1    0    0    0    0    0    1    0     0 #> [216,]    1    1    0    0    0    0    1    0    0     0 #> [217,]    1    1    0    0    0    1    0    0    0     0 #> [218,]    1    1    0    0    1    0    0    0    0     0 #> [219,]    1    1    0    1    0    0    0    0    0     0 #> [220,]    1    1    1    0    0    0    0    0    0     0"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-6-compositions-of-n-of-length-m","dir":"Articles","previous_headings":"Integer Compositions","what":"Case 6: Compositions of N of Length m","title":"Constraints, Partitions, and Compositions","text":"","code":"## See Case 2. N.B. weak = TRUE has no effect compositionsGeneral(6, 3, repetition = TRUE) #>       [,1] [,2] [,3] #>  [1,]    1    1    4 #>  [2,]    1    2    3 #>  [3,]    1    3    2 #>  [4,]    1    4    1 #>  [5,]    2    1    3 #>  [6,]    2    2    2 #>  [7,]    2    3    1 #>  [8,]    3    1    2 #>  [9,]    3    2    1 #> [10,]    4    1    1"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-7-compositions-of-n-into-distinct-parts","dir":"Articles","previous_headings":"Integer Compositions","what":"Case 7: Compositions of N into Distinct Parts","title":"Constraints, Partitions, and Compositions","text":"must use permuteGeneral .","code":"compositionsGeneral(6, 3) #> Error: Currently, there is no composition algorithm for this case. #>  Use permuteCount, permuteIter, permuteGeneral, permuteSample, or #>  permuteRank instead.  ## See Case 3 permuteGeneral(6, 3,                constraintFun = \"sum\",                comparisonFun = \"==\", limitConstraints = 6) #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    1    3    2 #> [3,]    2    1    3 #> [4,]    2    3    1 #> [5,]    3    1    2 #> [6,]    3    2    1"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"case-8-integer-compositions-of-n-into-parts-of-varying-multiplicity","dir":"Articles","previous_headings":"Integer Compositions","what":"Case 8: Integer Compositions of N into Parts of Varying Multiplicity","title":"Constraints, Partitions, and Compositions","text":"","code":"## compositions of 5 into 3 parts where each part can ## be used a maximum of 2 times. permuteGeneral(5, 3, freqs = rep(2, 5),                constraintFun = \"sum\",                comparisonFun = \"==\",                limitConstraints = 5) #>      [,1] [,2] [,3] #> [1,]    1    1    3 #> [2,]    1    3    1 #> [3,]    3    1    1 #> [4,]    1    2    2 #> [5,]    2    1    2 #> [6,]    2    2    1"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"efficiency-generating-partitions-and-compositions","dir":"Articles","previous_headings":"","what":"Efficiency Generating Partitions and Compositions","title":"Constraints, Partitions, and Compositions","text":"compositionGeneral able take advantage parallel computation. permuteGeneral, parallel options effect generating compositions.","code":"## compositions of 25 system.time(compositionsGeneral(0:25, repetition = TRUE)) #>    user  system elapsed  #>   1.649   0.085   1.738  compositionsCount(0:25, repetition=TRUE) #> [1] 16777216  ## Use multiple threads for greater efficiency. Generate ## over 16 million compositions in under a second! system.time(compositionsGeneral(0:25, repetition = TRUE, nThreads = 4)) #>    user  system elapsed  #>   1.819   0.099   0.514   ## weak compositions of 12 usnig nThreads = 4 system.time(weakComp12 <- compositionsGeneral(0:12, repetition = TRUE,                                               weak = TRUE, nThreads = 4)) #>    user  system elapsed  #>   0.011   0.006   0.005  ## And using permuteGeneral system.time(weakPerm12 <- permuteGeneral(0:12, 12, repetition = TRUE,                                          constraintFun = \"sum\",                                          comparisonFun = \"==\",                                          limitConstraints = 12)) #>    user  system elapsed  #>   0.010   0.003   0.014  dim(weakPerm12) #> [1] 1352078      12  identical(weakPerm12[do.call(order, as.data.frame(weakPerm12)), ],           weakComp12) #> [1] TRUE   ## General compositions with varying multiplicities system.time(comp25_gen <- permuteGeneral(25, 10, freqs = rep(4:8, 5),                                          constraintFun = \"sum\",                                          comparisonFun = \"==\",                                          limitConstraints = 25)) #>    user  system elapsed  #>   0.016   0.006   0.022  dim(comp25_gen) #> [1] 946092     10"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"safely-interrupt-execution-with-cpp11check_user_interrupt","dir":"Articles","previous_headings":"","what":"Safely Interrupt Execution with cpp11::check_user_interrupt","title":"Constraints, Partitions, and Compositions","text":"operations can take time, especially exploratory phase don’t much information type solution obtain. reason, added ability interrupt execution. hood, call cpp11::check_user_interrupt() every second check user requested process interrupted. Note check user interruptions determine number results front. means initiate process take long time exhaust available memory (e.g. forget put upper limit number results, relax tolerance, etc.), can simply hit Ctrl + c, esc using RStudio, stop execution.","code":"set.seed(123) s = rnorm(1000)  ## Oops!! We forgot to limit the output/put a loose tolerance ## There are as.numeric(comboCount(s, 20, T)) ~= 4.964324e+41 ## This will either take a long long time, or all of your ## memory will be consumed!!! ## ## No problem... simply hit Ctrl + c or if in RStudio, hit esc ## or hit the \"Stop\" button  ## ## system.time(testInterrupt <- partitionsGeneral(s, 20, TRUE, target = 0)) ## Timing stopped at: 1.029 0.011 1.04 ##"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombPermConstraints.html","id":"note-about-interrupting-execution","dir":"Articles","previous_headings":"Safely Interrupt Execution with cpp11::check_user_interrupt","what":"Note about Interrupting Execution","title":"Constraints, Partitions, and Compositions","text":"Generally, encourage user use iterators (See Combinatorial Iterators RcppAlgos) offer greater flexibility. example, iterators easy avoid resource consuming calls fetching results time. example investigate difficult problems due combinatorial explosion without fear restart R.","code":"## We use \"s\" defined above iter = partitionsIter(s, 20, TRUE, target = 0)  ## Test one iteration to see if we need to relax the tolerance system.time(iter@nextIter()) #>    user  system elapsed  #>   5.166   0.001   5.182  ## 8 seconds per iteration is a bit much... Let's loosen things ## a little by increasing the tolerance from sqrt(.Machine$double.eps) ## ~= 1.49e-8 to 1e-5. relaxedIter = partitionsIter(s, 20, TRUE, target = 0, tolerance = 1e-5)  system.time(relaxedIter@nextIter()) #>    user  system elapsed  #>       0       0       0"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"sampling","dir":"Articles","previous_headings":"","what":"Sampling","title":"Combinatorial Sampling and Ranking","text":"heart sampling ability efficiently generate nth lexicographical result. algorithms RcppAlgos flexible optimized, allowing tackling task ease.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"base-r","dir":"Articles","previous_headings":"Sampling","what":"Base R","title":"Combinatorial Sampling and Ranking","text":"illustrate base R, let us consider getting 5 random combinations vector 1:20 length 10. proceed? naive approach generate combinations using combn call sample: okay small example (choose(20, 10) = 184756 results), however wanted find one hundred thousand random combinations vector 1:100 length 20? Clearly, approach feasible far many results generate (choose(100, 20) = 5.359834e+20). Furthermore, internal limitations sample. try pass choose(100, 20), get error: also try calling sample(100, 20) bunch times hope don’t get duplicate combinations. neither promising elegant.","code":"options(width = 90) naive <- function(v, m, n, s) {     allCombs <- combn(v, m)     set.seed(s)     allCombs[, sample(ncol(allCombs), n)] }  fiveRndCombs <- naive(20, 10, 5, 42) t(fiveRndCombs) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    3    5   10   11   14   15   16   18    20 #> [2,]    1    3    4    9   10   11   12   13   18    19 #> [3,]    2    3    4    6    9   10   12   13   15    19 #> [4,]    1    4    5   10   13   14   15   17   18    19 #> [5,]    1    3    4    5    7    8   13   15   18    19 sample(choose(100, 20), 5) #> Error in sample.int(x, size, replace, prob): invalid first argument"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"rcppalgos-solutions","dir":"Articles","previous_headings":"Sampling","what":"RcppAlgos Solutions","title":"Combinatorial Sampling and Ranking","text":"RcppAlgos provides five functions: comboSample, permuteSample, partitionsSample, compositionsSample, comboGroupsSample seamlessly attacking types problems. functions provide following: Easily generate random samples parallel using nThreads Parallel parameters. can pass vector specific indices via sampleVec rely internal sampling functions. call sample total number results small larger cases, sampling done similar fashion urand.bigz gmp package. Consistent interface respective general functions (e.g. partitionsGeneral) seed parameter allows generating reproducible samples. gmp library needed, seed parameter must set order reproducible results (E.g. set.seed()) effect cases).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"combosample-and-permutesample","dir":"Articles","previous_headings":"Sampling","what":"comboSample and permuteSample","title":"Combinatorial Sampling and Ranking","text":"Let’s first look first problem (.e. getting 5 random combinations vector 1:20 length 10):","code":"library(RcppAlgos) set.seed(42) comboSample(20, 10, n = 5) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    3    5   10   11   14   15   16   18    20 #> [2,]    1    3    4    9   10   11   12   13   18    19 #> [3,]    2    3    4    6    9   10   12   13   15    19 #> [4,]    1    4    5   10   13   14   15   17   18    19 #> [5,]    1    3    4    5    7    8   13   15   18    19  ## Use the seed argument directly to produce the same output comboSample(20, 10, n = 5, seed = 42) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    3    5   10   11   14   15   16   18    20 #> [2,]    1    3    4    9   10   11   12   13   18    19 #> [3,]    2    3    4    6    9   10   12   13   15    19 #> [4,]    1    4    5   10   13   14   15   17   18    19 #> [5,]    1    3    4    5    7    8   13   15   18    19  ## fiveRndCombs produced above identical(t(fiveRndCombs),           comboSample(20, 10, n = 5, seed = 42)) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"samples-of-results-with-repetition","dir":"Articles","previous_headings":"Sampling > comboSample and permuteSample","what":"Samples of Results with Repetition","title":"Combinatorial Sampling and Ranking","text":"Just like comboGeneral permuteGeneral, can explore results repetition.","code":"comboSample(10, 8, TRUE, n = 3, seed = 84) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    2    5    5    7    9    9    9    9 #> [2,]    4    5    8    8    8   10   10   10 #> [3,]    2    6    6    6    6    6    9    9  permuteSample(10, 8, TRUE, n = 3) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    4   10    4    4   10    2    2   10 #> [2,]    1    4    5   10    5    5    2    2 #> [3,]    4    1    7    9    1    5    6    5  comboSample(10, 12, freqs = 1:10, n = 3) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,]    2    2    3    5    5    6    6    6    7     8     9    10 #> [2,]    1    2    3    3    5    5    6    7    9     9     9     9 #> [3,]    1    2    5    5    5    6    6    9   10    10    10    10  permuteSample(10, 12, freqs = 1:10, n = 3, seed = 123) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,]    2    8    7    4    8    9   10   10    7     1     8     2 #> [2,]    5    5    9    8    1    8    3    2    6     4     3    10 #> [3,]   10    3    8    8    4    8    8    6   10     6     3     8"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"specific-results-with-samplevec","dir":"Articles","previous_headings":"Sampling > comboSample and permuteSample","what":"Specific Results with sampleVec","title":"Combinatorial Sampling and Ranking","text":"can also utilize sampleVec generate specific results.","code":"## E.g. the below generates the 1st, 5th, 25th, 125th, and ## 625th lexicographical combinations comboSample(10, 8, TRUE, sampleVec = c(1, 5, 25, 125, 625)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    1    1    1    1    1    1    1 #> [2,]    1    1    1    1    1    1    1    5 #> [3,]    1    1    1    1    1    1    3    8 #> [4,]    1    1    1    1    1    3    6    9 #> [5,]    1    1    1    1    5    6   10   10  ## Is the same as: comboGeneral(10, 8, TRUE)[5^(0:4), ] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    1    1    1    1    1    1    1 #> [2,]    1    1    1    1    1    1    1    5 #> [3,]    1    1    1    1    1    1    3    8 #> [4,]    1    1    1    1    1    3    6    9 #> [5,]    1    1    1    1    5    6   10   10"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"using-namedsample","dir":"Articles","previous_headings":"Sampling > comboSample and permuteSample","what":"Using namedSample","title":"Combinatorial Sampling and Ranking","text":"ever wondered lexicographical combinations/permutations returned sampling? worries, simply set namedSample = TRUE:","code":"testInd <- permuteSample(30, 10, n = 3, seed = 100, namedSample = TRUE) testInd #>                [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> 86626302070118   24   26    7   29    3   21   20    9   16    28 #> 15871916538841    5   12   21    9    6    3   14   23    4    20 #> 87932455980012   25    6   20   23   18   10   27   30   19    29  ## Same output as above permuteSample(30, 10, sampleVec = row.names(testInd)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]   24   26    7   29    3   21   20    9   16    28 #> [2,]    5   12   21    9    6    3   14   23    4    20 #> [3,]   25    6   20   23   18   10   27   30   19    29"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"parallel-computing-and-gmp-support","dir":"Articles","previous_headings":"Sampling > comboSample and permuteSample","what":"Parallel Computing and GMP Support","title":"Combinatorial Sampling and Ranking","text":"Just like General counterparts, sampling functions utilize GMP allow exploration combinations/permutations large vectors total number results enormous. also offer parallel options using Parallel nThreads.","code":"## Uses min(stdThreadMax() - 1, 5) threads (in this case) permuteSample(500, 10, TRUE, n = 5, seed = 123, Parallel = TRUE) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]   55  435  274  324  200  152    6  313  121   377 #> [2,]  196  166  331  154  443  329  155  233  354   442 #> [3,]  235  325   94   27  370  117  302   86  229   126 #> [4,]  284  104  464  104  207  127  117    9  390   414 #> [5,]  456   76  381  456  219   23  376  187   11   123  permuteSample(factor(state.abb), 15, n = 3, seed = 50, nThreads = 3) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] #> [1,] ME   FL   DE   OK   ND   CA   PA   AL   ID   MO    NM    HI    KY    MT    NJ    #> [2,] AZ   CA   AL   CT   ME   SD   ID   SC   OK   NH    HI    TN    ND    IA    MT    #> [3,] MD   MO   NC   MT   NH   AL   VA   MA   VT   WV    NJ    NE    MN    MS    MI    #> 50 Levels: AK AL AR AZ CA CO CT DE FL GA HI IA ID IL IN KS KY LA MA MD ME MI MN MO ... WY  permuteCount(factor(state.abb), 15) #> Big Integer ('bigz') : #> [1] 2943352142120754524160000"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"efficiency","dir":"Articles","previous_headings":"Sampling > comboSample and permuteSample","what":"Efficiency","title":"Combinatorial Sampling and Ranking","text":"algorithms incredibly efficient offer tremendous gains naive approach : Even dealing extremely large numbers, algorithms fast. using parallel options even greater effects saw general counterparts (typically around ~2-3 times faster general functions, whereas last example sampling see nearly 5x improvement).","code":"## the function \"naive\" is defined above system.time(naive(25, 10, 5, 15)) #>    user  system elapsed  #>   1.523   0.019   1.547  system.time(comboSample(25, 10, n = 5, seed = 15)) #>    user  system elapsed  #>       0       0       0 ## Lightning fast even with examples involving many results system.time(comboSample(2500, 100, n = 5, seed = 15)) #>    user  system elapsed  #>   0.001   0.000   0.000  ## The total number of combinations has ~180 digits gmp::log10.bigz(comboCount(2500, 100)) #> [1] 180.9525  ## Still fast with larger samples system.time(comboSample(2500, 100, n = 1e4, seed = 157)) #>    user  system elapsed  #>   0.647   0.001   0.648  ## Using Parallel/nThreads in these cases has an even greater effect system.time(comboSample(2500, 100, n = 1e4, seed = 157, nThreads = 8)) #>    user  system elapsed  #>   0.915   0.001   0.124"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"user-defined-functions","dir":"Articles","previous_headings":"Sampling > comboSample and permuteSample","what":"User Defined Functions","title":"Combinatorial Sampling and Ranking","text":", just general functions, can pass custom function {combo|permute}Sample using FUN argument.","code":"permuteSample(5000, 1000, n = 3, seed = 101, FUN = sd) #> [[1]] #> [1] 1431.949 #>  #> [[2]] #> [1] 1446.859 #>  #> [[3]] #> [1] 1449.272  ## Example using complex numbers myCplx <- as.complex(1:100 + rep(c(-1, 1), 50) * 1i)  permuteSample(myCplx, 10, freqs = rep(1:5, 20),               n = 3, seed = 101, FUN = function(x) {                   sqrt(sum(x))               }) #> [[1]] #> [1] 24.83948+0i #>  #> [[2]] #> [1] 20.9285+0.04778172i #>  #> [[3]] #> [1] 22.20379+0.09007473i"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"partitionssample","dir":"Articles","previous_headings":"Sampling","what":"partitionsSample","title":"Combinatorial Sampling and Ranking","text":"partitionsSample function allows one draw random sample partitions number. Many features present comboSample permuteSample available partitionsSample. sampling algorithms available partition cases, cases covered. example, standard multisets, currently unable efficiently generate nth lexicographical result. Another example source vector uniform (e.g. distance element irregular). Observe following: ongoing research area goal eventually able cover standard multiset case.","code":"## Use the seed parameter to obtain reproducible results partitionsSample(100, 8, TRUE, n = 3, seed = 42) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    1    3    3    4   20   23   45 #> [2,]    1    1    2    7   14   14   29   32 #> [3,]    2   10   11   11   16   16   16   18  ## Used namedSample to obtain the lexicographical indices partitionsSample(100, 8, TRUE, n = 3, seed = 42, namedSample = TRUE) #>        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> 61413     1    1    3    3    4   20   23   45 #> 54425     1    1    2    7   14   14   29   32 #> 623844    2   10   11   11   16   16   16   18  ## Use sampleVec to obtain specific results partitionsSample(100, 8, TRUE, sampleVec = c(61413, 54425, 623844)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    1    3    3    4   20   23   45 #> [2,]    1    1    2    7   14   14   29   32 #> [3,]    2   10   11   11   16   16   16   18  partitionsCount(2500, 10) #> Big Integer ('bigz') : #> [1] 2621914835336941325  ## Algorithms are very efficient system.time(serial <- partitionsSample(2500, 10, n = 1e3,                                        seed = 8128)) #>    user  system elapsed  #>   2.997   0.002   3.007  ## Use nThreads for greater efficiency system.time(multi <- partitionsSample(2500, 10, n = 1e3,                                       seed = 8128, nThreads = 8)) #>    user  system elapsed  #>   4.374   0.020   0.576  identical(multi, serial) #> [1] TRUE  ## Even works with non-standard setup partitionsSample(17 + (1:10) * 3, 10, TRUE,                  target = 320, n = 3, seed = 111) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]   23   23   26   26   29   29   38   38   41    47 #> [2,]   26   26   26   29   29   29   32   41   41    41 #> [3,]   20   23   23   26   26   35   38   41   44    44 ## No sampling algorithm available when the source vector is not uniform partitionsSample(c(1, 4, 6, 7, 10, seq(11, 100, 7)), 10, n = 1, target = 340) #> Error: Partition sampling not available for this case.  ## As stated above, the standard multiset case doesn't work either partitionsSample(0:50, 6, freqs = rep(1:3, 17), n = 2) #> Error: Partition sampling not available for this case.  ## If we use freqs to indicate that zeros can repeat, ## then we can obtain random samples partitionsSample(0:50, 6, freqs = c(50, rep(1, 50)), n = 3, seed = 222) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    0    0    1    4    9   36 #> [2,]    0    0    0    0   17   33 #> [3,]    2    4    5    6    8   25  ## Even works when the vector is restricted in regards to the target partitionsSample(0:50, 6, freqs = c(50, rep(1, 50)),                  n = 3, seed = 222, target = 100) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    0    1    6   15   29   49 #> [2,]    0    0    0    8   43   49 #> [3,]    4    7   17   19   22   31"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"compositionssample","dir":"Articles","previous_headings":"Sampling","what":"compositionsSample","title":"Combinatorial Sampling and Ranking","text":"compositionsSample function allows one draw random sample compositions number. Many features present comboSample permuteSample available compositionsSample. Currently, sampling algorithms cases compositions repetition. ongoing work expand algorithms future.","code":"## Use the seed parameter to obtain reproducible results compositionsSample(100, 8, TRUE, n = 3, seed = 42) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    5    4   34   31    7    3    1   15 #> [2,]    3   21    8    6   12   43    6    1 #> [3,]    6    6    1   36   17   18   10    6  ## Used namedSample to obtain the lexicographical indices compositionsSample(100, 8, TRUE, n = 3, seed = 42, namedSample = TRUE) #>            [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> 4024715585    5    4   34   31    7    3    1   15 #> 2756281572    3   21    8    6   12   43    6    1 #> 4873365553    6    6    1   36   17   18   10    6  ## Use sampleVec to obtain specific results compositionsSample(100, 8, TRUE,                    sampleVec = c(4024715585, 2756281572, 4873365553)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    5    4   34   31    7    3    1   15 #> [2,]    3   21    8    6   12   43    6    1 #> [3,]    6    6    1   36   17   18   10    6  compositionsCount(2500, 10, TRUE) #> Big Integer ('bigz') : #> [1] 10324518903611974891453624  ## Algorithms are very efficient... ## The below retrieves 10,000 compositions in under a second system.time(serial <- compositionsSample(2500, 10, TRUE,                                          n = 1e4, seed = 8128)) #>    user  system elapsed  #>   0.262   0.000   0.263  ## Use nThreads for greater efficiency system.time(multi <- compositionsSample(2500, 10, TRUE, n = 1e4,                                         seed = 8128, nThreads = 8)) #>    user  system elapsed  #>   0.364   0.001   0.053  identical(multi, serial) #> [1] TRUE  ## Sample weak compositions compositionsSample(0:100, 8, repetition = TRUE, weak = TRUE,                    seed = 245659, n = 3, namedSample = TRUE) #>             [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> 21547195040   23    0    0    8    5   22   25   17 #> 7649268748     5    0   13   36   42    4    0    0 #> 7598223523     4   54   21    4    6    0    8    3"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"sampling-partitions-of-groups-with-combogroupssample","dir":"Articles","previous_headings":"Sampling","what":"Sampling Partitions of Groups with comboGroupsSample","title":"Combinatorial Sampling and Ranking","text":"Just can generate random samples combinations permutations, also able generate random samples partitions groups well. many problems present manner. , examine one involving playing cards. Let’s say 4 players player 3 cards piece. Given deck shuffled, dealer distributes 12 cards. possible hands can player ? See Creating Deck Cards R Without Using Double Loop (Credit @MichaelChirico) add twist problem . instead want deal players 1 & 2 two cards, player 3 three cards, player 4 five cards. might ? , make use grpSizes parameter:","code":"cards <- c(2:10, \"J\", \"Q\", \"K\", \"A\") suits <- c(\"♠\", \"♥\", \"♦\", \"♣\") deck <- paste0(rep(cards, length(suits)),  # card values                rep(suits, each = length(cards))) # suits  set.seed(1738) shuffled <- factor(deck[sample(52)], levels = deck)  ## Here are 2 possibilities comboGroupsSample(shuffled[1:12], numGroups = 4, n = 2, seed = 13) #>      Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp4 Grp4 Grp4 #> [1,] 8♦   3♥   5♦   9♦   J♠   7♥   8♠   K♦   10♦  A♦   J♥   3♦   #> [2,] 8♦   K♦   10♦  9♦   J♥   3♥   J♠   8♠   3♦   A♦   5♦   7♥   #> 52 Levels: 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠ A♠ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ ... A♣   comboGroupsSample(shuffled[1:12], numGroups = 4, retType = \"3Darray\",                   n = 2, seed = 13, namedSample = TRUE) #> , , Grp1 #>  #>       [,1] [,2] [,3] #> 13784 8♦   3♥   5♦   #> 9152  8♦   K♦   10♦  #>  #> , , Grp2 #>  #>       [,1] [,2] [,3] #> 13784 9♦   J♠   7♥   #> 9152  9♦   J♥   3♥   #>  #> , , Grp3 #>  #>       [,1] [,2] [,3] #> 13784 8♠   K♦   10♦  #> 9152  J♠   8♠   3♦   #>  #> , , Grp4 #>  #>       [,1] [,2] [,3] #> 13784 A♦   J♥   3♦   #> 9152  A♦   5♦   7♥   #>  #> 52 Levels: 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠ A♠ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ ... A♣ ## Again, here are 2 possibilities comboGroupsSample(shuffled[1:12], grpSizes = c(2, 2, 3, 5),                   n = 2, seed = 13, namedSample = TRUE) #>       Grp1 Grp1 Grp2 Grp2 Grp3 Grp3 Grp3 Grp4 Grp4 Grp4 Grp4 Grp4 #> 81667 J♥   10♦  3♦   3♥   8♦   A♦   5♦   9♦   J♠   8♠   K♦   7♥   #> 71525 K♦   A♦   J♥   5♦   8♦   8♠   3♥   9♦   J♠   3♦   10♦  7♥   #> 52 Levels: 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠ A♠ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ ... A♣"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"ranking","dir":"Articles","previous_headings":"","what":"Ranking","title":"Combinatorial Sampling and Ranking","text":"Ranking complement sampling. , given combination (permutation/partition), determine lexicographical result . example, consider combinations 5 choose 3: can see rank combination: c(2, 3, 4) 7. , c(2, 3, 4) 7th combination 5 choose 3.","code":"comboGeneral(5, 3) #>       [,1] [,2] [,3] #>  [1,]    1    2    3 #>  [2,]    1    2    4 #>  [3,]    1    2    5 #>  [4,]    1    3    4 #>  [5,]    1    3    5 #>  [6,]    1    4    5 #>  [7,]    2    3    4 #>  [8,]    2    3    5 #>  [9,]    2    4    5 #> [10,]    3    4    5"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"base-r-1","dir":"Articles","previous_headings":"Ranking","what":"Base R","title":"Combinatorial Sampling and Ranking","text":"Just saw , easily produce brute force approach work well small cases, become unmanageable quickly. example:","code":"naive_rank <- function(v, m, comb) {     comb <- as.integer(comb)     which(apply(combn(v, m), 2, function(x) identical(x, comb))) }  naive_rank(5, 3, 2:4) #> [1] 7  ## Larger example comb = comboSample(25, 12, sampleVec = 2e6)[1, ]  system.time(print(naive_rank(25, 12, comb))) #> [1] 2000000 #>    user  system elapsed  #>   6.194   0.083   6.290"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"rcppalgos-solutions-1","dir":"Articles","previous_headings":"Ranking","what":"RcppAlgos Solutions","title":"Combinatorial Sampling and Ranking","text":"Similar sampling problem, RcppAlgos provides four functions: comboRank, permuteRank, partitionsRank, compositionsRank (currently ranking function comboGroups). functions similar sampling counterparts. problems presented , attack comboRank: needed original vector used produce results whether repetition used via repetition freqs arguments. width determined automatically input.","code":"comboRank(2:4, v = 5) #> [1] 7  ## Since order doesn't matter with combinations, 4:2 should return 7 as well comboRank(4:2, v = 5) #> [1] 7  ## comb was provided above system.time(print(comboRank(comb, v = 25))) #> [1] 2000000 #>    user  system elapsed  #>       0       0       0"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"rank-multiple-inputs","dir":"Articles","previous_headings":"Ranking","what":"Rank Multiple Inputs","title":"Combinatorial Sampling and Ranking","text":"neat feature ranking functions ability rank multiple inputs . can either pass single vector, multiple vectors, can even pass matrices.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"comborank","dir":"Articles","previous_headings":"Ranking","what":"comboRank","title":"Combinatorial Sampling and Ranking","text":"","code":"combs = comboSample(50, 8, n = 10, seed = 123, namedSample = TRUE) combs #>           [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> 161401295    3    4    6   13   40   44   48   50 #> 120710262    2    6   21   29   32   36   42   45 #> 220886245    3   22   23   25   35   36   48   50 #> 442099291   10   11   13   20   21   24   36   45 #> 334689371    6    9   13   20   28   41   43   48 #> 189241370    3    7   18   26   29   31   43   50 #> 168175018    3    4   20   21   27   42   44   49 #> 105740881    2    4   24   27   40   46   48   49 #> 36321127     1    5   10   15   18   32   40   46 #> 292830028    5    8   16   19   34   35   46   47  comboRank(combs, v = 50) #>  [1] 161401295 120710262 220886245 442099291 334689371 189241370 168175018 105740881 #>  [9]  36321127 292830028"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"permuterank","dir":"Articles","previous_headings":"Ranking","what":"permuteRank","title":"Combinatorial Sampling and Ranking","text":"","code":"perms_len_5 = permuteSample(100, 5, freqs = rep(1:5, 20),                             n = 3, seed = 987, namedSample = TRUE) perms_len_5 #>            [,1] [,2] [,3] [,4] [,5] #> 3474930553   36   47   93    7   32 #> 5793832271   60   12   27   39   99 #> 797663634     9   16   23    3   35  perms_len_8 = permuteSample(100, 8, freqs = rep(1:5, 20),                             n = 3, seed = 123, namedSample = TRUE) perms_len_8 #>                  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> 6897937625624040   73   96   48   62   19   39   60   31 #> 6937176899580966   74   37   42   44   34   80   18   94 #> 5771073522599470   62    7   60   69   14   60    7   30  ## Note you can name the inputs permuteRank(p5 = perms_len_5, p8 = perms_len_8,             v = 100, freqs = rep(1:5, 20)) #> $p5 #> [1] 3474930553 5793832271  797663634 #>  #> $p8 #> Big Integer ('bigz') object of length 3: #> [1] 6897937625624040 6937176899580966 5771073522599470"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"partitionsrank","dir":"Articles","previous_headings":"Ranking","what":"partitionsRank","title":"Combinatorial Sampling and Ranking","text":"","code":"parts = partitionsSample(50, 8, target = 100, repetition = TRUE,                          n = 3, seed = 42, namedSample = TRUE) parts #>        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> 61413     1    1    3   11   12   21   23   28 #> 54425     1    1    3    6    7   13   29   40 #> 623844    3    4    4    7    7   15   28   32  partitionsRank(parts, v = 50, target = 100, repetition = TRUE) #> [1]  61413  54425 623844"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatorialSampling.html","id":"compositionsrank","dir":"Articles","previous_headings":"Ranking","what":"compositionsRank","title":"Combinatorial Sampling and Ranking","text":"","code":"comps = compositionsSample(50, 8, repetition = TRUE,                            n = 3, seed = 42, namedSample = TRUE) comps #>          [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> 36761573    4    6    2    1   13    3   15    6 #> 21025945    2   11   13    8    2    3    7    4 #> 71927012   11    4   17    1    2    5    5    5  compositionsRank(comps, v = 50, repetition = TRUE) #> [1] 36761573 21025945 71927012"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"iterating-over-combinations-and-permutations","dir":"Articles","previous_headings":"","what":"Iterating over Combinations and Permutations","title":"Combinatorial Iterators in RcppAlgos","text":"order iterate, must initialize iterator via comboIter permuteIter. interface similar comboGeneral permuteGeneral.","code":"library(RcppAlgos) options(width = 90)  ## Initialize the iterator a = comboIter(5, 3)  ## Get the first combination a$nextIter() #> [1] 1 2 3  ## And the next a$nextIter() #> [1] 1 2 4  ## Set the current iterator to a variable iter = a$currIter() i = 1  ## Iterate until there are no more while (!is.null(iter)) {     cat(i, \" \", iter, \"\\n\")     iter = a$nextIter()     i = i + 1 } #> 1   1 2 4  #> 2   1 2 5  #> 3   1 3 4  #> 4   1 3 5  #> 5   1 4 5  #> 6   2 3 4  #> 7   2 3 5  #> 8   2 4 5  #> 9   3 4 5  #> No more results. To see the last result, use the prevIter method(s)  ## See the output of comboGeneral for comparison comboGeneral(5, 3, lower = 2) #>       [,1] [,2] [,3] #>  [1,]    1    2    4 #>  [2,]    1    2    5 #>  [3,]    1    3    4 #>  [4,]    1    3    5 #>  [5,]    1    4    5 #>  [6,]    2    3    4 #>  [7,]    2    3    5 #>  [8,]    2    4    5 #>  [9,]    3    4    5  ## Call the summary method to see information about our iterator a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 11 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] -1"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"bidirectional-iterators","dir":"Articles","previous_headings":"Iterating over Combinations and Permutations","what":"Bidirectional Iterators","title":"Combinatorial Iterators in RcppAlgos","text":"combinatorial iterators RcppAlgos bidirectional iterators. means can iterate forward manner (.e. lexicographically), can also iterate backwards (.e. Reverse Lexicographical Order) via prevIter method(s).","code":"## Using the same iterable from the previous section a$currIter() #> No more results. To see the last result, use the prevIter method(s) #> NULL  ## As the comment says, we call the prevIter method to see the last result a$prevIter() #> [1] 3 4 5  ## Get the previous result a$prevIter() #> [1] 2 4 5  ## As in the previous example, we set the current iterator to a variable iter = a$currIter()  ## Defined above print(i) #> [1] 10  ## Iterate until we are at the very beginning. Note that the ## output is exactly the same as above, but in reverse order while (!is.null(iter)) {     i = i - 1     cat(i, \" \", iter, \"\\n\")     iter = a$prevIter() } #> 9   2 4 5  #> 8   2 3 5  #> 7   2 3 4  #> 6   1 4 5  #> 5   1 3 5  #> 4   1 3 4  #> 3   1 2 5  #> 2   1 2 4  #> 1   1 2 3  #> Iterator Initialized. To see the first result, use the nextIter method(s)  ## Call the summary method to see information about our iterator a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 0 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] 10"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"retrieving-more-than-one-result-at-a-time","dir":"Articles","previous_headings":"Iterating over Combinations and Permutations","what":"Retrieving More than One Result at a Time","title":"Combinatorial Iterators in RcppAlgos","text":"four methods allow obtaining one result time: nextNIter, prevNIter, nextRemaining, prevRemaining. Now, look opposite direction.","code":"## Reset the iterator a$startOver()  ## Get the next 4 combinations a$nextNIter(4) #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    1    2    4 #> [3,]    1    2    5 #> [4,]    1    3    4  ## Get the summary. Note that the index has been updated a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 4 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] 6  ## View the current combination a$currIter() #> [1] 1 3 4  ## Get the remaining combinations with nextRemaining a$nextRemaining() #>      [,1] [,2] [,3] #> [1,]    1    3    5 #> [2,]    1    4    5 #> [3,]    2    3    4 #> [4,]    2    3    5 #> [5,]    2    4    5 #> [6,]    3    4    5  a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 11 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] -1 ## Get the previous 4 combinations a$prevNIter(4) #>      [,1] [,2] [,3] #> [1,]    3    4    5 #> [2,]    2    4    5 #> [3,]    2    3    5 #> [4,]    2    3    4  ## Get the summary. Note that the index has been updated a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 7 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] 3  ## View the current combination a$currIter() #> [1] 2 3 4  ## Get the remaining previous combinations with prevRemaining a$prevRemaining() #>      [,1] [,2] [,3] #> [1,]    1    4    5 #> [2,]    1    3    5 #> [3,]    1    3    4 #> [4,]    1    2    5 #> [5,]    1    2    4 #> [6,]    1    2    3  a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 0 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] 10"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"random-access-iterator","dir":"Articles","previous_headings":"Iterating over Combinations and Permutations","what":"Random Access Iterator","title":"Combinatorial Iterators in RcppAlgos","text":"bidirectional iterators, combinatorial iterators RcppAlgos, can jump nth result without need iterating first n - 1 results. can also easily return random sample combinations [[ operator passing vector indices. cases, noted current index updated.","code":"## Reset the iterator a$startOver()  ## How many total combinations do we have? a$summary()$totalResults #> [1] 10  ## Let's get the 3rd combination a[[3]] #> [1] 1 2 5  ## See the summary. Note that the index has been updated a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 3 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] 7  ## Let's see the 9th combination a[[9]] #> [1] 2 4 5  ## What about the first and last combination? a$front() #> [1] 1 2 3  a$back() #> [1] 3 4 5  ## Again the index has been updated a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 10 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] 0  a$currIter() #> [1] 3 4 5 ## Set the current index to the second combination a[[2]] #> [1] 1 2 4  set.seed(121) samp = sample(a$summary()$totalResults, 4)  samp #> [1]  4  7 10  1  a[[samp]] #>      [,1] [,2] [,3] #> [1,]    1    3    4 #> [2,]    2    3    4 #> [3,]    3    4    5 #> [4,]    1    2    3  ## Note that the current index remains unchanged a$summary() #> $description #> [1] \"Combinations of 5 choose 3\" #>  #> $currentIndex #> [1] 2 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] 8"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"user-defined-functions","dir":"Articles","previous_headings":"Iterating over Combinations and Permutations","what":"User Defined Functions","title":"Combinatorial Iterators in RcppAlgos","text":"Just comboGeneral permuteGeneral, can pass user defined function comboIter permuteIter.","code":"## Initialize the iterator b = permuteIter(LETTERS[1:4], 3, FUN = function(p) paste(p, collapse = \"\"),                 FUN.VALUE = \"a\") b$nextIter() #> [1] \"ABC\"  b$nextNIter(5) #> [1] \"ABD\" \"ACB\" \"ACD\" \"ADB\" \"ADC\"  b$back() #> [1] \"DCB\"  b$prevIter() #> [1] \"DCA\"  b$prevNIter(5) #> [1] \"DBC\" \"DBA\" \"DAC\" \"DAB\" \"CDB\"  b$nextRemaining() #> [1] \"DAB\" \"DAC\" \"DBA\" \"DBC\" \"DCA\" \"DCB\"  ## Random access b[[5]] #> [1] \"ADB\"  b$prevRemaining() #> [1] \"ACD\" \"ACB\" \"ABD\" \"ABC\"  ## View the source vector b$sourceVector() #> [1] \"A\" \"B\" \"C\" \"D\""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"new-in-verison-2-5-0","dir":"Articles","previous_headings":"","what":"New in Verison 2.5.0","title":"Combinatorial Iterators in RcppAlgos","text":"version 2.5.0, longer rely Rcpp dependency, means utilize Rcpp modules exposing C++ classes. now carried using external pointers (See External pointers weak references) along S4 Classes. use slots S4 classes exposing method access carried “sign”, @. also added ability access method “dollar sign”, $, backwards compatibility.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"access-efficiency-in-2-5-0","dir":"Articles","previous_headings":"New in Verison 2.5.0","what":"Access Efficiency in 2.5.0+","title":"Combinatorial Iterators in RcppAlgos","text":"tests show accessing methods much efficient 2.5.0+ compared prior versions. tests, measure execution time calling nextIter multiple times different versions. use function test_nextIter testing. one needs reproduce, simply download 2.4.3 tar : https://cran.r-project.org/src/contrib/Archive/RcppAlgos/, change RcppAlgos RcppAlgos243 place (e.g. DESCRIPTION, NAMESPACE, etc.), rebuild.","code":"test_nextIter <- function(n, m, get_val = FALSE, v = 243) {     a <- if (v == 243) {         RcppAlgos243::comboIter(n, m)     } else {         comboIter(n, m)     }      total <- comboCount(n, m)      if (get_val) {         mat <- matrix(0L, nrow = total, ncol = m)         for (i in 1:total) mat[i, ] <- a$nextIter()         return(mat)     } else {         if (v == 243) {             for (i in 1:total) a$nextIter()         } else {             for (i in 1:total) a@nextIter()         }          invisible(NULL)     } }"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"version-2-4-3-using-rcpp","dir":"Articles","previous_headings":"New in Verison 2.5.0 > Access Efficiency in 2.5.0+","what":"Version 2.4.3 Using Rcpp","title":"Combinatorial Iterators in RcppAlgos","text":"","code":"library(microbenchmark) ## Using R version 4.1.3 comboCount(15, 8) #> [1] 6435  microbenchmark(v243 = test_nextIter(15, 8)) #> Warning in microbenchmark(v243 = test_nextIter(15, 8)): less accurate nanosecond times to #> avoid potential integer overflows #> Unit: milliseconds #>  expr      min      lq     mean   median       uq      max neval #>  v243 21.34612 21.8676 23.53489 22.32694 22.74385 128.8881   100  identical(test_nextIter(15, 8, get_val = TRUE),           comboGeneral(15, 8)) #> [1] TRUE  comboCount(25, 10) #> [1] 3268760  system.time(test_nextIter(25, 10)) #>    user  system elapsed  #>  11.316   0.011  11.359  Rprof(\"Version243.out\", memory.profiling = TRUE) test_nextIter(25, 10) Rprof(NULL) lapply(summaryRprof(\"Version243.out\", memory = \"both\"), head) #> $by.self #>                  self.time self.pct total.time total.pct mem.total #> \"as.environment\"      3.18    34.57       3.18     34.57    1067.6 #> \"$\"                   2.44    26.52       7.16     77.83    2546.9 #> \"test_nextIter\"       1.04    11.30       9.20    100.00    3452.9 #> \".External\"           0.80     8.70       0.80      8.70     346.2 #> \"get\"                 0.78     8.48       0.78      8.48     279.4 #> \"exists\"              0.76     8.26       0.76      8.26     268.5 #>  #> $by.total #>                             total.time total.pct mem.total self.time self.pct #> \"test_nextIter\"                    9.2       100    3452.9      1.04     11.3 #> \"<Anonymous>\"                      9.2       100    3452.9      0.00      0.0 #> \"base::do.call\"                    9.2       100    3452.9      0.00      0.0 #> \"base::saveRDS\"                    9.2       100    3452.9      0.00      0.0 #> \"base::tryCatch\"                   9.2       100    3452.9      0.00      0.0 #> \"base::withCallingHandlers\"        9.2       100    3452.9      0.00      0.0 #>  #> $sample.interval #> [1] 0.02 #>  #> $sampling.time #> [1] 9.2"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"version-2-9-2-no-rcpp","dir":"Articles","previous_headings":"New in Verison 2.5.0 > Access Efficiency in 2.5.0+","what":"Version 2.9.2 (No Rcpp)","title":"Combinatorial Iterators in RcppAlgos","text":"","code":"curr_version <- as.integer(gsub(\"\\\\.\", \"\", packageVersion(\"RcppAlgos\"))) curr_version #> [1] 292 microbenchmark(curr_v = test_nextIter(15, 8, v = curr_version)) #> Unit: milliseconds #>    expr      min       lq     mean   median       uq      max neval #>  curr_v 2.540483 2.617563 2.716912 2.664324 2.757885 3.711566   100  system.time(test_nextIter(25, 10, v = curr_version)) #>    user  system elapsed  #>   1.330   0.001   1.334  identical(test_nextIter(15, 8, get_val = TRUE, v = curr_version),           comboGeneral(15, 8)) #> [1] TRUE  Rprof(\"Version250.out\", memory.profiling = TRUE) test_nextIter(25, 10, v = curr_version) Rprof(NULL) lapply(summaryRprof(\"Version250.out\", memory = \"both\"), head) #> $by.self #>                 self.time self.pct total.time total.pct mem.total #> \"<Anonymous>\"        0.48    44.44       1.08    100.00     632.4 #> \".Call\"              0.38    35.19       0.38     35.19     245.5 #> \"test_nextIter\"      0.22    20.37       1.08    100.00     632.4 #>  #> $by.total #>                             total.time total.pct mem.total self.time self.pct #> \"<Anonymous>\"                     1.08       100     632.4      0.48    44.44 #> \"test_nextIter\"                   1.08       100     632.4      0.22    20.37 #> \"base::do.call\"                   1.08       100     632.4      0.00     0.00 #> \"base::saveRDS\"                   1.08       100     632.4      0.00     0.00 #> \"base::tryCatch\"                  1.08       100     632.4      0.00     0.00 #> \"base::withCallingHandlers\"       1.08       100     632.4      0.00     0.00 #>  #> $sample.interval #> [1] 0.02 #>  #> $sampling.time #> [1] 1.08"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"conclusions","dir":"Articles","previous_headings":"New in Verison 2.5.0 > Access Efficiency in 2.5.0+","what":"Conclusions","title":"Combinatorial Iterators in RcppAlgos","text":"appears memory issue previous versions. Indeed, look Memory statistics Rprof, view files memory = \"stats\" see C funciton, duplicate, appears main culprit. verison 2.5.0+ 126 tot.duplications whereas version 2.4.3 millions tot.duplications. fact, total 9798529 duplications version 2.4.3. together comboCount(25, 10) = 3,268,760 implies C funciton, duplicate, called 3 times per iteration older versions (.e. 9798529 / 3268760 ~= 2.9976).","code":"## We set index = 1 to ensure we get the very bottom of the stack  ### Verison 2.4.3 v243 <- summaryRprof(\"Version243.out\", memory = \"stats\", index = 1) v243 #> index: \"base::tryCatch\" #>      vsize.small  max.vsize.small      vsize.large  max.vsize.large            nodes  #>           393626          6192400            15554          7154768          7648340  #>        max.nodes     duplications tot.duplications          samples  #>         72527392            21301          9798529              460  ## Version 2.5.0 v250 <- summaryRprof(\"Version250.out\", memory = \"stats\", index = 1) v250 #> index: \"base::tryCatch\" #>      vsize.small  max.vsize.small      vsize.large  max.vsize.large            nodes  #>          2393803          5896032           133897          7230416         10930771  #>        max.nodes     duplications tot.duplications          samples  #>         50521240                2              126               54"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"iterating-over-partitions-and-compositions-of-a-number","dir":"Articles","previous_headings":"New in Verison 2.5.0","what":"Iterating over Partitions and Compositions of a Number","title":"Combinatorial Iterators in RcppAlgos","text":"partition cases, capabilities standard comboIter permuteIter except bidirectionality (.e. prevIter methods). cases involving standard multisets also don’t random access methods. compositions, options limited subset compositions repetition.","code":"## Similar illustration of comboIter(5, 3) at the top p = partitionsIter(16, 4) p@nextIter() #> [1]  1  2  3 10  p@nextIter() #> [1] 1 2 4 9  iter = p@currIter() i = 1  while (!is.null(iter)) {     cat(i, \" \", iter, \"\\n\")     iter = p@nextIter()     i = i + 1 } #> 1   1 2 4 9  #> 2   1 2 5 8  #> 3   1 2 6 7  #> 4   1 3 4 8  #> 5   1 3 5 7  #> 6   1 4 5 6  #> 7   2 3 4 7  #> 8   2 3 5 6  #> No more results.  partitionsGeneral(16, 4, lower = 2) #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    4    9 #> [2,]    1    2    5    8 #> [3,]    1    2    6    7 #> [4,]    1    3    4    8 #> [5,]    1    3    5    7 #> [6,]    1    4    5    6 #> [7,]    2    3    4    7 #> [8,]    2    3    5    6  p@summary() #> $description #> [1] \"Partitions of 16 into 4 parts\" #>  #> $currentIndex #> [1] 10 #>  #> $totalResults #> [1] 9 #>  #> $totalRemaining #> [1] -1  ## Using random access p[[7]] #> [1] 1 4 5 6  ## No previous iterators p@prevIter() #> Error in eval(expr, envir, enclos): no slot of name \"prevIter\" for this object of class \"Partitions\" ## Similar illustration of comboIter(5, 3) at the top p = compositionsIter(6, 3, TRUE) p@nextIter() #> [1] 1 1 4  p@nextIter() #> [1] 1 2 3  iter = p@currIter() i = 1  while (!is.null(iter)) {     cat(i, \" \", iter, \"\\n\")     iter = p@nextIter()     i = i + 1 } #> 1   1 2 3  #> 2   1 3 2  #> 3   1 4 1  #> 4   2 1 3  #> 5   2 2 2  #> 6   2 3 1  #> 7   3 1 2  #> 8   3 2 1  #> 9   4 1 1  #> No more results.  compositionsGeneral(6, 3, TRUE, lower = 2) #>       [,1] [,2] [,3] #>  [1,]    1    2    3 #>  [2,]    1    3    2 #>  [3,]    1    4    1 #>  [4,]    2    1    3 #>  [5,]    2    2    2 #>  [6,]    2    3    1 #>  [7,]    3    1    2 #>  [8,]    3    2    1 #>  [9,]    4    1    1  p@summary() #> $description #> [1] \"Compositions with repetition of 6 into 3 parts\" #>  #> $currentIndex #> [1] 11 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] -1  ## Using random access p[[7]] #> [1] 2 3 1  ## No previous iterators p@prevIter() #> Error in eval(expr, envir, enclos): no slot of name \"prevIter\" for this object of class \"Partitions\""},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"iterating-over-constrained-combinationspermutations","dir":"Articles","previous_headings":"New in Verison 2.5.0","what":"Iterating over Constrained Combinations/Permutations","title":"Combinatorial Iterators in RcppAlgos","text":"Now, combinatorial iterators features “general” analogs (.e. {combo|permute|partitions|compositions}General), includes constrained results. general constrained cases, iterators offer huge advantages “general” counterparts. Previously, one guess many results using upper parameter executing function constraints meant user waiting consume large amount resources. Another drawback difficult start generating particular point. “general” functions, lower parameter used, make decision order disambiguate use. Without constraints, using lower easy understand. simply means start generating results starting particular lexicographical result, can efficiently (.e. need generate first lower - 1 results). constraints, mean one two things: Start checking particular lexicographical result without considering constraint (normally). Start generating results particular result regards final constrained output. RcppAlgos always used first interpretation. big downside second point don’t fast algorithms enumerating total number results, reduces determining nth result brute force approach. iterators, can generate n results nextNIter(n) calling nextIter() n times (combination two). , want continue iterating, pick left fetching (n + 1)th result beyond (results left). allows us keep memory low without sacrificing current state. efficient well. Consider example use comboGeneral generate results without capping output. , situation don’t know priori many results obtain. Just 4 seconds isn’t bad, however 4 GBs put strain computer. Let’s use iterators instead generate ten thousand time keep memory low. mention iterators “smart” fear requesting results actually left. example, problem , iterated 38th million result requested 10 million , obtain 935,252 results. Wow! Using iterator approach easier RAM, faster well (4.64 / 1.475 ~= 3.1458)! gains came strictly memory efficiency (4 GBs just 1 MB) underlying algorithm exactly . Lastly, using iterators make problems possible otherwise intractable hardware. instance, using example , changed limitConstraints 83 81 tried first approach computer certainly become unusable (least mine ). memory usage shot 30 GB R became unresponsive. restart, tried second approach obtained result just 10 seconds barely noticing jumps memory:","code":"set.seed(55) s = runif(10, -5, 5)  print(s) #>  [1]  0.478135161 -2.818403214 -4.650360052  2.915492940  0.602420762 -4.257748260 #>  [7] -3.684770642 -2.058761222  0.007612633 -4.116755421  ## Using comboGeneral to retrieve all results comboGeneral(s, 5, constraintFun = \"mean\",              comparisonFun = \"<\", limitConstraints = -3) #>            [,1]      [,2]      [,3]      [,4]         [,5] #>  [1,] -4.650360 -4.257748 -4.116755 -3.684771 -2.818403214 #>  [2,] -4.650360 -4.257748 -4.116755 -3.684771 -2.058761222 #>  [3,] -4.650360 -4.257748 -4.116755 -3.684771  0.007612633 #>  [4,] -4.650360 -4.257748 -4.116755 -3.684771  0.478135161 #>  [5,] -4.650360 -4.257748 -4.116755 -3.684771  0.602420762 #>  [6,] -4.650360 -4.257748 -4.116755 -2.818403 -2.058761222 #>  [7,] -4.650360 -4.257748 -4.116755 -2.818403  0.007612633 #>  [8,] -4.650360 -4.257748 -4.116755 -2.818403  0.478135161 #>  [9,] -4.650360 -4.257748 -4.116755 -2.818403  0.602420762 #> [10,] -4.650360 -4.257748 -4.116755 -2.058761  0.007612633 #> [11,] -4.650360 -4.257748 -3.684771 -2.818403 -2.058761222 #> [12,] -4.650360 -4.257748 -3.684771 -2.818403  0.007612633 #> [13,] -4.650360 -4.116755 -3.684771 -2.818403 -2.058761222 #> [14,] -4.650360 -4.116755 -3.684771 -2.818403  0.007612633 #> [15,] -4.257748 -4.116755 -3.684771 -2.818403 -2.058761222   ## Using comboIter a = comboIter(s, 5, constraintFun = \"mean\",               comparisonFun = \"<\", limitConstraints = -3)  ## See the first result a@nextIter() #> [1] -4.650360 -4.257748 -4.116755 -3.684771 -2.818403  ## Get the next three a@nextNIter(3) #>          [,1]      [,2]      [,3]      [,4]         [,5] #> [1,] -4.65036 -4.257748 -4.116755 -3.684771 -2.058761222 #> [2,] -4.65036 -4.257748 -4.116755 -3.684771  0.007612633 #> [3,] -4.65036 -4.257748 -4.116755 -3.684771  0.478135161  ## See the summary... Note the totalResults and totalRemaining ## fields are NA as we are not able to calculate this upfront. a@summary() #> $description #> [1] \"Combinations of 10 choose 5 where the mean is < -3\" #>  #> $currentIndex #> [1] 4 #>  #> $totalResults #> [1] NA #>  #> $totalRemaining #> [1] NA   a@nextNIter(3) #>          [,1]      [,2]      [,3]      [,4]         [,5] #> [1,] -4.65036 -4.257748 -4.116755 -3.684771  0.602420762 #> [2,] -4.65036 -4.257748 -4.116755 -2.818403 -2.058761222 #> [3,] -4.65036 -4.257748 -4.116755 -2.818403  0.007612633  ## Get the rest a@nextRemaining() #>           [,1]      [,2]      [,3]      [,4]         [,5] #> [1,] -4.650360 -4.257748 -4.116755 -2.818403  0.478135161 #> [2,] -4.650360 -4.257748 -4.116755 -2.818403  0.602420762 #> [3,] -4.650360 -4.257748 -4.116755 -2.058761  0.007612633 #> [4,] -4.650360 -4.257748 -3.684771 -2.818403 -2.058761222 #> [5,] -4.650360 -4.257748 -3.684771 -2.818403  0.007612633 #> [6,] -4.650360 -4.116755 -3.684771 -2.818403 -2.058761222 #> [7,] -4.650360 -4.116755 -3.684771 -2.818403  0.007612633 #> [8,] -4.257748 -4.116755 -3.684771 -2.818403 -2.058761222 set.seed(77) s = runif(50, 20, 100)  ## Over one trillion results to sift through comboCount(s, 15) #> [1] 2.25083e+12  time_all <- system.time({     print(         nrow(             comboGeneral(s, 15,                          constraintFun = \"mean\",                          comparisonFun = \">\",                          limitConstraints = 83)         )     ) }) #> [1] 38935252 time_all #>    user  system elapsed  #>   1.628   2.117   4.640  ## Over 4 GBs of results (38935252 * 15 * 8) / 2^30 #> [1] 4.351353 invisible(gc()) time_iter <- system.time({     a = comboIter(s, 15,                   constraintFun = \"mean\",                   comparisonFun = \">\",                   limitConstraints = 83)     while (!is.null(a@nextNIter(1e4))) {}     print(a@summary()) }) #> No more results. #>  #> $description #> [1] \"Combinations of 50 choose 15 where the mean is > 83\" #>  #> $currentIndex #> [1] 38935252 #>  #> $totalResults #> [1] NA #>  #> $totalRemaining #> [1] NA time_iter #>    user  system elapsed  #>   1.175   0.293   1.475  ## Only 1 MBs per iteration (1e4 * 15 * 8) / 2^20 #> [1] 1.144409 ## Don't run... consumes a huge chunk of memory # time_all <- system.time({ #     print( #         nrow( #             comboGeneral(s, 15, #                          constraintFun = \"mean\", #                          comparisonFun = \">\", #                          limitConstraints = 81)  ## 83 -->> 81 #         ) #     ) # })  ## No problem with iterators invisible(gc()) system.time({     a = comboIter(s, 15,                   constraintFun = \"mean\",                   comparisonFun = \">\",                   limitConstraints = 81)   ## 83 -->> 81     while (!is.null(a@nextNIter(1e4))) {}     print(a@summary()) }) #> No more results. #>  #> $description #> [1] \"Combinations of 50 choose 15 where the mean is > 81\" #>  #> $currentIndex #> [1] 271309888 #>  #> $totalResults #> [1] NA #>  #> $totalRemaining #> [1] NA #>    user  system elapsed  #>   8.147   2.221  10.414"},{"path":"https://jwood000.github.io/RcppAlgos/articles/CombinatoricsIterators.html","id":"iterating-over-partitions-of-groups","dir":"Articles","previous_headings":"New in Verison 2.5.0","what":"Iterating over Partitions of Groups","title":"Combinatorial Iterators in RcppAlgos","text":"version 2.8.2, can iterate partitions groups comboGroupsIter. Just partitionsIter, capabilities standard comboIter permuteIter except bidirectionality (.e. prevIter methods).","code":"## Similar illustration of comboIter(5, 3) at the top cg = comboGroupsIter(6, 2, retType = \"3Darray\") cg@nextIter() #>      Grp1 Grp2 #> [1,]    1    4 #> [2,]    2    5 #> [3,]    3    6  cg@nextIter() #>      Grp1 Grp2 #> [1,]    1    3 #> [2,]    2    5 #> [3,]    4    6  iter = cg@currIter() i = 1  while (!is.null(iter)) {     cat(\"\\n \", i, \"-------------\\n\")     print(iter)     iter = cg@nextIter()     i = i + 1 } #>  #>   1 ------------- #>      Grp1 Grp2 #> [1,]    1    3 #> [2,]    2    5 #> [3,]    4    6 #>  #>   2 ------------- #>      Grp1 Grp2 #> [1,]    1    3 #> [2,]    2    4 #> [3,]    5    6 #>  #>   3 ------------- #>      Grp1 Grp2 #> [1,]    1    3 #> [2,]    2    4 #> [3,]    6    5 #>  #>   4 ------------- #>      Grp1 Grp2 #> [1,]    1    2 #> [2,]    3    5 #> [3,]    4    6 #>  #>   5 ------------- #>      Grp1 Grp2 #> [1,]    1    2 #> [2,]    3    4 #> [3,]    5    6 #>  #>   6 ------------- #>      Grp1 Grp2 #> [1,]    1    2 #> [2,]    3    4 #> [3,]    6    5 #>  #>   7 ------------- #>      Grp1 Grp2 #> [1,]    1    2 #> [2,]    4    3 #> [3,]    5    6 #>  #>   8 ------------- #>      Grp1 Grp2 #> [1,]    1    2 #> [2,]    4    3 #> [3,]    6    5 #>  #>   9 ------------- #>      Grp1 Grp2 #> [1,]    1    2 #> [2,]    5    3 #> [3,]    6    4 #> No more results.  comboGroups(6, 2, retType = \"3Darray\", lower = 2) #> , , Grp1 #>  #>       [,1] [,2] [,3] #>  [1,]    1    2    4 #>  [2,]    1    2    5 #>  [3,]    1    2    6 #>  [4,]    1    3    4 #>  [5,]    1    3    5 #>  [6,]    1    3    6 #>  [7,]    1    4    5 #>  [8,]    1    4    6 #>  [9,]    1    5    6 #>  #> , , Grp2 #>  #>       [,1] [,2] [,3] #>  [1,]    3    5    6 #>  [2,]    3    4    6 #>  [3,]    3    4    5 #>  [4,]    2    5    6 #>  [5,]    2    4    6 #>  [6,]    2    4    5 #>  [7,]    2    3    6 #>  [8,]    2    3    5 #>  [9,]    2    3    4  cg@summary() #> $description #> [1] \"Partition of v of length 6 into 2 uniform groups\" #>  #> $currentIndex #> [1] 11 #>  #> $totalResults #> [1] 10 #>  #> $totalRemaining #> [1] -1  ## Using random access cg[[7]] #>      Grp1 Grp2 #> [1,]    1    2 #> [2,]    3    4 #> [3,]    6    5  ## No previous iterators cg@prevIter() #> Error in eval(expr, envir, enclos): no slot of name \"prevIter\" for this object of class \"ComboGroups\""},{"path":"https://jwood000.github.io/RcppAlgos/articles/ComputationalMathematics.html","id":"primesieve","dir":"Articles","previous_headings":"","what":"primeSieve","title":"Computational Mathematics Overview","text":"primeSieve function based Segmented Sieve Eratosthenes. stated linked article, sieve already efficient. problem efficiency standpoint, due memory requirements. segmented version overcomes sieving small sections time, greatly facilitates use cache.","code":"library(RcppAlgos) library(microbenchmark) options(width = 90)  microbenchmark(primeSieve(1e6)) #> Warning in microbenchmark(primeSieve(1000000)): less accurate nanosecond times to avoid #> potential integer overflows #> Unit: microseconds #>               expr     min       lq    mean   median      uq     max neval #>  primeSieve(1e+06) 823.403 847.2855 863.829 855.1165 871.168 978.301   100  ## Single threaded primes under a billion!!! system.time(primeSieve(10^9)) #>    user  system elapsed  #>   0.923   0.032   0.959  ## Using 8 threads we can get under 0.5 seconds!!! system.time(primeSieve(10^9, nThreads = 8)) #>    user  system elapsed  #>   1.285   0.031   0.195  ## Quickly generate large primes over small interval. N.B. The ## order for the bounds does not matter. options(scipen = 50) system.time(myPs <- primeSieve(10^13 + 10^3, 10^13)) #>    user  system elapsed  #>   0.006   0.000   0.006  myPs #>  [1] 10000000000037 10000000000051 10000000000099 10000000000129 10000000000183 #>  [6] 10000000000259 10000000000267 10000000000273 10000000000279 10000000000283 #> [11] 10000000000313 10000000000343 10000000000391 10000000000411 10000000000433 #> [16] 10000000000453 10000000000591 10000000000609 10000000000643 10000000000649 #> [21] 10000000000657 10000000000687 10000000000691 10000000000717 10000000000729 #> [26] 10000000000751 10000000000759 10000000000777 10000000000853 10000000000883 #> [31] 10000000000943 10000000000957 10000000000987 10000000000993  ## Object created is small object.size(myPs) #> 320 bytes"},{"path":"https://jwood000.github.io/RcppAlgos/articles/ComputationalMathematics.html","id":"larger-primes","dir":"Articles","previous_headings":"primeSieve","what":"Larger primes","title":"Computational Mathematics Overview","text":"Since version 2.3.0, implementing cache-friendly improvements larger primes originally developed Tomás Oliveira.","code":"## Version <= 2.2.0.. i.e. older versions system.time(old <- RcppAlgos220::primeSieve(1e15, 1e15 + 1e9)) #>    user  system elapsed  #>   2.358   0.041   2.412  invisible(gc()) ## v2.3.0+ is faster system.time(a <- primeSieve(1e15, 1e15 + 1e9)) #>    user  system elapsed  #>   1.187   0.032   1.231  invisible(gc()) ## And using nThreads is much much faster system.time(b <- primeSieve(1e15, 1e15 + 1e9, nThreads = 8)) #>    user  system elapsed  #>   2.130   0.077   0.370  identical(old, a) #> [1] TRUE  identical(a, b) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/articles/ComputationalMathematics.html","id":"primecount","dir":"Articles","previous_headings":"","what":"primeCount","title":"Computational Mathematics Overview","text":"library Kim Walisch relies OpenMP parallel computation Legendre’s Formula. Currently, default compiler macOS clang, support OpenMP. James Balamuta (.k.. TheCoatlessProfessor… well least think ) written great article topic, can find : https://blog.thecoatlessprofessor.com/programming/openmp--r--os-x/index.html. One goals RcppAlgos accessible users. mind, set count primes parallel without OpenMP. first glance, seems trivial function Primes.cpp called phiWorker counts primes x. look phi.cpp primecount library Kim Walisch, see OpenMP magic loop makes repeated calls phi (phiWorker based ). need break loop n intervals n number threads. Simple, right? can certainly , find n - 1 threads complete quickly nth thread left heavy computation. order alleviate unbalanced load, divide loop mentioned smaller intervals. idea completely calculate phi limit m using n threads gradually increase m. advantage benefiting greatly caching done work previous n threads. mind, results:","code":"## Enumerate the number of primes below trillion system.time(underOneTrillion <- primeCount(10^12)) #>    user  system elapsed  #>   0.118   0.000   0.119  underOneTrillion #> [1] 37607912018  ## Enumerate the number of primes below ten billion in 2 milliseconds microbenchmark(primeCount(10^10)) #> Unit: milliseconds #>               expr      min       lq     mean   median       uq      max neval #>  primeCount(10^10) 1.657097 1.662406 1.692221 1.670934 1.695453 2.375786   100  system.time(underOneHundredTrillion <- primeCount(1e14, nThreads = 8)) #>    user  system elapsed  #>   6.583   0.411   1.204  underOneHundredTrillion #> [1] 3204941750802  ## Still not as fast as Kim Walisch's primecount library: cat(paste(     system(\"primecount 1e14 --legendre --time\", intern = TRUE),     collapse = \"\\n\" )) #> 3204941750802 #> Seconds: 0.392"},{"path":"https://jwood000.github.io/RcppAlgos/articles/ComputationalMathematics.html","id":"other-sieving-functions","dir":"Articles","previous_headings":"","what":"Other Sieving Functions","title":"Computational Mathematics Overview","text":"RcppAlgos comes equipped several functions quickly generating essential components problems common computational mathematics. functions can executed parallel using argument nThreads. following sieving functions (primeFactorizeSieve, divisorsSieve, numDivisorSieve, & eulerPhiSieve) useful flexible. Generate components number two bounds.","code":"## get the number of divisors for every number from 1 to n numDivisorSieve(20) #>  [1] 1 2 2 3 2 4 2 4 3 4 2 6 2 4 4 5 2 6 2 6  ## If you want the complete factorization from 1 to n, use divisorsList system.time(allFacs <- divisorsSieve(10^5, namedList = TRUE)) #>    user  system elapsed  #>   0.023   0.006   0.028  allFacs[c(4339, 15613, 22080)] #> $`4339` #> [1]    1 4339 #>  #> $`15613` #> [1]     1    13  1201 15613 #>  #> $`22080` #>  [1]     1     2     3     4     5     6     8    10    12    15    16    20    23    24 #> [15]    30    32    40    46    48    60    64    69    80    92    96   115   120   138 #> [29]   160   184   192   230   240   276   320   345   368   460   480   552   690   736 #> [43]   920   960  1104  1380  1472  1840  2208  2760  3680  4416  5520  7360 11040 22080   ## Between two bounds primeFactorizeSieve(10^12, 10^12 + 5) #> [[1]] #>  [1] 2 2 2 2 2 2 2 2 2 2 2 2 5 5 5 5 5 5 5 5 5 5 5 5 #>  #> [[2]] #> [1]       73      137 99990001 #>  #> [[3]] #> [1]            2            3 166666666667 #>  #> [[4]] #> [1]      61   14221 1152763 #>  #> [[5]] #> [1]      2      2     17    149    197 501001 #>  #> [[6]] #> [1]           3           5 66666666667   ## Creating a named object eulerPhiSieve(20, namedVector = TRUE) #>  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20  #>  1  1  2  2  4  2  6  4  6  4 10  4 12  6  8  8 16  6 18  8   system.time(a <- eulerPhiSieve(1e12, 1e12 + 1e7)) #>    user  system elapsed  #>   0.304   0.011   0.316  ## Using nThreads for greater efficiency system.time(b <- eulerPhiSieve(1e12, 1e12 + 1e7, nThreads = 8)) #>    user  system elapsed  #>   1.017   0.041   0.153  identical(a, b) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/articles/ComputationalMathematics.html","id":"vectorized-functions","dir":"Articles","previous_headings":"","what":"Vectorized Functions","title":"Computational Mathematics Overview","text":"three fast vectorized functions general factoring (e.g. divisors number), primality testing, well prime factoring (divisorsRcpp, isPrimeRcpp, primeFactorize).","code":"## get result for individual numbers primeFactorize(123456789) #> [1]    3    3 3607 3803   ## or for an entire vector ## N.B. The R Version you are using... random sampling ## has changed throughout the years R.version[[\"version.string\"]] #> [1] \"R version 4.4.2 (2024-10-31)\" set.seed(100)  myVec <- sample(-100000000:100000000, 5) divisorsRcpp(myVec, namedList = TRUE) #> $`33331928` #>  [1]        1        2        4        7        8       14       19       28       38 #> [10]       56       76      133      152      266      532     1064    31327    62654 #> [19]   125308   219289   250616   438578   595213   877156  1190426  1754312  2380852 #> [28]  4166491  4761704  8332982 16665964 33331928 #>  #> $`99961494` #>  [1]        1        2        3        6       37       74      111      222   450277 #> [10]   900554  1350831  2701662 16660249 33320498 49980747 99961494 #>  #> $`30377219` #> [1]        1       19  1598801 30377219 #>  #> $`-46085563` #> [1] -46085563   -201247      -229        -1         1       229    201247  46085563 #>  #> $`-26510714` #>  [1] -26510714 -13255357    -73846    -36923      -718      -359        -2        -1 #>  [9]         1         2       359       718     36923     73846  13255357  26510714   ## Creating a named object isPrimeRcpp(995:1000, namedVector = TRUE) #>   995   996   997   998   999  1000  #> FALSE FALSE  TRUE FALSE FALSE FALSE  system.time(a <- primeFactorize(1e12:(1e12 + 1e5))) #>    user  system elapsed  #>   0.648   0.006   0.658  ## Using nThreads for greater efficiency system.time(b <- primeFactorize(1e12:(1e12 + 1e5), nThreads = 8)) #>    user  system elapsed  #>   0.917   0.008   0.153  identical(a, b) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"introducing-combogeneral-and-permutegeneral","dir":"Articles","previous_headings":"","what":"Introducing comboGeneral and permuteGeneral","title":"Combination and Permutation Basics","text":"Easily executed simple interface. output lexicographical order. first look getting results without repetition. can pass integer n converted sequence 1:n, can pass vector atomic type (.e. logical, integer, numeric, complex, character, raw).","code":"library(RcppAlgos) options(width = 90)  ## combn output for reference combn(4, 3) #>      [,1] [,2] [,3] [,4] #> [1,]    1    1    1    2 #> [2,]    2    2    3    3 #> [3,]    3    4    4    4  ## This is the same as combn expect the output is transposed comboGeneral(4, 3) #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    1    2    4 #> [3,]    1    3    4 #> [4,]    2    3    4  ## Find all 3-tuple permutations without ## repetition of the numbers c(1, 2, 3, 4). head(permuteGeneral(4, 3)) #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    1    2    4 #> [3,]    1    3    2 #> [4,]    1    3    4 #> [5,]    1    4    2 #> [6,]    1    4    3  ## If you don't specify m, the length of v (if v is a vector) or v (if v is a ## scalar (see the examples above)) will be used v <- c(2, 3, 5, 7, 11, 13) comboGeneral(v) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    2    3    5    7   11   13  head(permuteGeneral(v)) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    2    3    5    7   11   13 #> [2,]    2    3    5    7   13   11 #> [3,]    2    3    5   11    7   13 #> [4,]    2    3    5   11   13    7 #> [5,]    2    3    5   13    7   11 #> [6,]    2    3    5   13   11    7  ## They are very efficient... system.time(comboGeneral(25, 12)) #>    user  system elapsed  #>   0.055   0.011   0.067  comboCount(25, 12) #> [1] 5200300  ht(comboGeneral(25, 12)) #> head --> #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,]    1    2    3    4    5    6    7    8    9    10    11    12 #> [2,]    1    2    3    4    5    6    7    8    9    10    11    13 #> [3,]    1    2    3    4    5    6    7    8    9    10    11    14 #> [4,]    1    2    3    4    5    6    7    8    9    10    11    15 #> [5,]    1    2    3    4    5    6    7    8    9    10    11    16 #> -------- #> tail --> #>            [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [5200296,]   13   14   15   16   18   19   20   21   22    23    24    25 #> [5200297,]   13   14   15   17   18   19   20   21   22    23    24    25 #> [5200298,]   13   14   16   17   18   19   20   21   22    23    24    25 #> [5200299,]   13   15   16   17   18   19   20   21   22    23    24    25 #> [5200300,]   14   15   16   17   18   19   20   21   22    23    24    25  ## And for permutations... over 8 million instantly system.time(permuteGeneral(13, 7)) #>    user  system elapsed  #>   0.023   0.011   0.034  permuteCount(13, 7) #> [1] 8648640  ht(permuteGeneral(13, 7)) #> head --> #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    1    2    3    4    5    6    7 #> [2,]    1    2    3    4    5    6    8 #> [3,]    1    2    3    4    5    6    9 #> [4,]    1    2    3    4    5    6   10 #> [5,]    1    2    3    4    5    6   11 #> -------- #> tail --> #>            [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [8648636,]   13   12   11   10    9    8    3 #> [8648637,]   13   12   11   10    9    8    4 #> [8648638,]   13   12   11   10    9    8    5 #> [8648639,]   13   12   11   10    9    8    6 #> [8648640,]   13   12   11   10    9    8    7  ## Factors are preserved permuteGeneral(factor(c(\"low\", \"med\", \"high\"),                levels = c(\"low\", \"med\", \"high\"),                ordered = TRUE)) #>      [,1] [,2] [,3] #> [1,] low  med  high #> [2,] low  high med  #> [3,] med  low  high #> [4,] med  high low  #> [5,] high low  med  #> [6,] high med  low  #> Levels: low < med < high"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"combinationspermutations-with-repetition","dir":"Articles","previous_headings":"","what":"Combinations/Permutations with Repetition","title":"Combination and Permutation Basics","text":"many problems combinatorics require finding combinations/permutations repetition. easily achieved setting repetition TRUE.","code":"fourDays <- weekdays(as.Date(\"2019-10-09\") + 0:3, TRUE) ht(comboGeneral(fourDays, repetition = TRUE)) #> head --> #>      [,1]  [,2]  [,3]  [,4]  #> [1,] \"Wed\" \"Wed\" \"Wed\" \"Wed\" #> [2,] \"Wed\" \"Wed\" \"Wed\" \"Thu\" #> [3,] \"Wed\" \"Wed\" \"Wed\" \"Fri\" #> [4,] \"Wed\" \"Wed\" \"Wed\" \"Sat\" #> [5,] \"Wed\" \"Wed\" \"Thu\" \"Thu\" #> -------- #> tail --> #>       [,1]  [,2]  [,3]  [,4]  #> [31,] \"Fri\" \"Fri\" \"Fri\" \"Fri\" #> [32,] \"Fri\" \"Fri\" \"Fri\" \"Sat\" #> [33,] \"Fri\" \"Fri\" \"Sat\" \"Sat\" #> [34,] \"Fri\" \"Sat\" \"Sat\" \"Sat\" #> [35,] \"Sat\" \"Sat\" \"Sat\" \"Sat\"  ## When repetition = TRUE, m can exceed length(v) ht(comboGeneral(fourDays, 8, TRUE)) #> head --> #>      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  #> [1,] \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" #> [2,] \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Thu\" #> [3,] \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Fri\" #> [4,] \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Sat\" #> [5,] \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Wed\" \"Thu\" \"Thu\" #> -------- #> tail --> #>        [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  #> [161,] \"Fri\" \"Fri\" \"Fri\" \"Fri\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" #> [162,] \"Fri\" \"Fri\" \"Fri\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" #> [163,] \"Fri\" \"Fri\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" #> [164,] \"Fri\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" #> [165,] \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\" \"Sat\"  fibonacci <- c(1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L) permsFib <- permuteGeneral(fibonacci, 5, TRUE)  ht(permsFib) #> head --> #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    1    1    1    1 #> [2,]    1    1    1    1    2 #> [3,]    1    1    1    1    3 #> [4,]    1    1    1    1    5 #> [5,]    1    1    1    1    8 #> -------- #> tail --> #>          [,1] [,2] [,3] [,4] [,5] #> [32764,]   34   34   34   34    5 #> [32765,]   34   34   34   34    8 #> [32766,]   34   34   34   34   13 #> [32767,]   34   34   34   34   21 #> [32768,]   34   34   34   34   34  ## N.B. class is preserved class(fibonacci) #> [1] \"integer\"  class(permsFib[1, ]) #> [1] \"integer\"  ## Binary representation of all numbers from 0 to 1023 ht(permuteGeneral(0:1, 10, T)) #> head --> #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    0    0    0    0    0    0    0    0    0     0 #> [2,]    0    0    0    0    0    0    0    0    0     1 #> [3,]    0    0    0    0    0    0    0    0    1     0 #> [4,]    0    0    0    0    0    0    0    0    1     1 #> [5,]    0    0    0    0    0    0    0    1    0     0 #> -------- #> tail --> #>         [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1020,]    1    1    1    1    1    1    1    0    1     1 #> [1021,]    1    1    1    1    1    1    1    1    0     0 #> [1022,]    1    1    1    1    1    1    1    1    0     1 #> [1023,]    1    1    1    1    1    1    1    1    1     0 #> [1024,]    1    1    1    1    1    1    1    1    1     1"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"working-with-multisets","dir":"Articles","previous_headings":"","what":"Working with Multisets","title":"Combination and Permutation Basics","text":"Sometimes, standard combination/permutation functions don’t quite get us desired goal. example, one may need permutations vector elements repeated specific number times (.e. multiset). Consider following vector <- c(1,1,1,1,2,2,2,7,7,7,7,7) one like find permutations length 6. Using traditional methods, need generate permutations, eliminate duplicate values. Even considering permuteGeneral efficient, approach clunky fast . Observe:","code":"getPermsWithSpecificRepetition <- function(z, n) {     b <- permuteGeneral(z, n)     myDupes <- duplicated(b)     b[!myDupes, ] }  a <- as.integer(c(1, 1, 1, 1, 2, 2, 2, 7, 7, 7, 7, 7))  system.time(test <- getPermsWithSpecificRepetition(a, 6)) #>    user  system elapsed  #>   1.299   0.013   1.319"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"enter-freqs","dir":"Articles","previous_headings":"Working with Multisets","what":"Enter freqs","title":"Combination and Permutation Basics","text":"Situations like call use freqs argument. Simply, enter number times unique element repeated Voila! general examples multisets:","code":"## Using the S3 method for class 'table' system.time(test2 <- permuteGeneral(table(a), 6)) #>    user  system elapsed  #>   0.000   0.000   0.001  identical(test, test2) #> [1] TRUE ## Generate all permutations of a vector with specific ## length of repetition for each element (i.e. multiset) ht(permuteGeneral(3, freqs = c(1,2,2))) #> head --> #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    2    2    3    3 #> [2,]    1    2    3    2    3 #> [3,]    1    2    3    3    2 #> [4,]    1    3    2    2    3 #> [5,]    1    3    2    3    2 #> -------- #> tail --> #>       [,1] [,2] [,3] [,4] [,5] #> [26,]    3    2    3    1    2 #> [27,]    3    2    3    2    1 #> [28,]    3    3    1    2    2 #> [29,]    3    3    2    1    2 #> [30,]    3    3    2    2    1  ## or combinations of a certain length comboGeneral(3, 2, freqs = c(1,2,2)) #>      [,1] [,2] #> [1,]    1    2 #> [2,]    1    3 #> [3,]    2    2 #> [4,]    2    3 #> [5,]    3    3"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"parallel-computing","dir":"Articles","previous_headings":"","what":"Parallel Computing","title":"Combination and Permutation Basics","text":"Using parameter Parallel nThreads, can generate combinations/permutations greater efficiency.","code":"library(microbenchmark)  ## RcppAlgos uses the \"number of threads available minus one\" when Parallel is TRUE RcppAlgos::stdThreadMax() #> [1] 8  comboCount(26, 13) #> [1] 10400600  ## Compared to combn using 4 threads microbenchmark(combn = combn(26, 13),                serAlgos = comboGeneral(26, 13),                parAlgos = comboGeneral(26, 13, nThreads = 4),                times = 10,                unit = \"relative\") #> Warning in microbenchmark(combn = combn(26, 13), serAlgos = comboGeneral(26, : less #> accurate nanosecond times to avoid potential integer overflows #> Unit: relative #>      expr        min         lq      mean     median        uq      max neval #>     combn 108.112753 106.224065 87.063350 104.034130 66.360069 65.92955    10 #>  serAlgos   2.396141   2.609698  2.256676   2.808838  1.832159  1.81923    10 #>  parAlgos   1.000000   1.000000  1.000000   1.000000  1.000000  1.00000    10  ## Using 7 cores w/ Parallel = TRUE microbenchmark(     serial = comboGeneral(20, 10, freqs = rep(1:4, 5)),     parallel = comboGeneral(20, 10, freqs = rep(1:4, 5), Parallel = TRUE),     unit = \"relative\" ) #> Unit: relative #>      expr      min       lq     mean   median       uq      max neval #>    serial 3.235211 3.201248 2.829496 2.633776 2.720016 1.538897   100 #>  parallel 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000   100"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"using-arguments-lower-and-upper","dir":"Articles","previous_headings":"Parallel Computing","what":"Using arguments lower and upper","title":"Combination and Permutation Basics","text":"arguments lower upper can utilized generate chunks combinations/permutations without generate followed subsetting. output lexicographical order, arguments specify start stop generating. example, comboGeneral(5, 3) outputs 10 combinations vector 1:5 chosen 3 time. can set lower 5 order start generation 5th lexicographical combination. Similarly, can set upper 4 order generate first 4 combinations. can also use together produce certain chunk combinations. example, setting lower 4 upper 6 produces 4th, 5th, 6th lexicographical combinations. Observe:","code":"comboGeneral(5, 3, lower = 4, upper = 6) #>      [,1] [,2] [,3] #> [1,]    1    3    4 #> [2,]    1    3    5 #> [3,]    1    4    5  ## is equivalent to the following: comboGeneral(5, 3)[4:6, ] #>      [,1] [,2] [,3] #> [1,]    1    3    4 #> [2,]    1    3    5 #> [3,]    1    4    5"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"generating-results-beyond--machineinteger-max","dir":"Articles","previous_headings":"Parallel Computing","what":"Generating Results Beyond .Machine$integer.max","title":"Combination and Permutation Basics","text":"addition useful avoiding unnecessary overhead generating combination/permutations followed subsetting just see specific results, lower upper can utilized generate large number combinations/permutations parallel (see stackoverflow post real use case). Observe:","code":"## Over 3 billion results comboCount(35, 15) #> [1] 3247943160  ## 10086780 evenly divides 3247943160, otherwise you need to ensure that ## upper does not exceed the total number of results (E.g. see below, we ## would have \"if ((x + foo) > 3247943160) {myUpper = 3247943160}\" where ## foo is the size of the increment you choose to use in seq()).  system.time(lapply(seq(1, 3247943160, 10086780), function(x) {      temp <- comboGeneral(35, 15, lower = x, upper = x + 10086779)      ## do something      x })) #>    user  system elapsed  #>  28.963  10.352  39.844  ## Enter parallel library(parallel) system.time(mclapply(seq(1, 3247943160, 10086780), function(x) {      temp <- comboGeneral(35, 15, lower = x, upper = x + 10086779)      ## do something      x }, mc.cores = 6)) #>    user  system elapsed  #>  31.877  13.658   9.939"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"gmp-support","dir":"Articles","previous_headings":"","what":"GMP Support","title":"Combination and Permutation Basics","text":"arguments lower upper also useful one needs explore combinations/permutations number results large:","code":"set.seed(222) myVec <- rnorm(1000)  ## HUGE number of combinations comboCount(myVec, 50, repetition = TRUE) #> Big Integer ('bigz') : #> [1] 109740941767310814894854141592555528130828577427079559745647393417766593803205094888320  ## Let's look at one hundred thousand combinations in the range (1e15 + 1, 1e15 + 1e5) system.time(b <- comboGeneral(myVec, 50, TRUE,                               lower = 1e15 + 1,                               upper = 1e15 + 1e5)) #>    user  system elapsed  #>   0.003   0.002   0.004  b[1:5, 45:50] #>           [,1]      [,2]      [,3]     [,4]      [,5]       [,6] #> [1,] 0.5454861 0.4787456 0.7797122 2.004614 -1.257629 -0.7740501 #> [2,] 0.5454861 0.4787456 0.7797122 2.004614 -1.257629  0.1224679 #> [3,] 0.5454861 0.4787456 0.7797122 2.004614 -1.257629 -0.2033493 #> [4,] 0.5454861 0.4787456 0.7797122 2.004614 -1.257629  1.5511027 #> [5,] 0.5454861 0.4787456 0.7797122 2.004614 -1.257629  1.0792094"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"user-defined-functions","dir":"Articles","previous_headings":"","what":"User Defined Functions","title":"Combination and Permutation Basics","text":"can also pass user defined functions utilizing argument FUN. feature’s main purpose convenience, however somewhat efficient generating combinations/permutations using function apply family (N.B. argument Parallel effect FUN employed).","code":"funCustomComb = function(n, r) {     combs = comboGeneral(n, r)     lapply(1:nrow(combs), function(x) cumprod(combs[x,])) }  identical(funCustomComb(15, 8), comboGeneral(15, 8, FUN = cumprod)) #> [1] TRUE  microbenchmark(f1 = funCustomComb(15, 8),                f2 = comboGeneral(15, 8, FUN = cumprod), unit = \"relative\") #> Unit: relative #>  expr      min       lq     mean   median       uq      max neval #>    f1 5.468995 5.458721 5.785135 5.416062 5.425471 15.54943   100 #>    f2 1.000000 1.000000 1.000000 1.000000 1.000000  1.00000   100  comboGeneral(15, 8, FUN = cumprod, upper = 3) #> [[1]] #> [1]     1     2     6    24   120   720  5040 40320 #>  #> [[2]] #> [1]     1     2     6    24   120   720  5040 45360 #>  #> [[3]] #> [1]     1     2     6    24   120   720  5040 50400  ## An example involving the powerset... Note, we could ## have used the FUN.VALUE parameter here instead of ## calling unlist. See the next section. unlist(comboGeneral(c(\"\", letters[1:3]), 3,                     freqs = c(2, rep(1, 3)),                     FUN = function(x) paste(x, collapse = \"\"))) #> [1] \"a\"   \"b\"   \"c\"   \"ab\"  \"ac\"  \"bc\"  \"abc\""},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"using-fun-value","dir":"Articles","previous_headings":"User Defined Functions","what":"Using FUN.VALUE","title":"Combination and Permutation Basics","text":"version 2.5.0, can make use FUN.VALUE serves template return value FUN. behavior nearly identical vapply:","code":"## Example from earlier involving the power set comboGeneral(c(\"\", letters[1:3]), 3, freqs = c(2, rep(1, 3)),              FUN = function(x) paste(x, collapse = \"\"), FUN.VALUE = \"a\") #> [1] \"a\"   \"b\"   \"c\"   \"ab\"  \"ac\"  \"bc\"  \"abc\"  comboGeneral(15, 8, FUN = cumprod, upper = 3, FUN.VALUE = as.numeric(1:8)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7]  [,8] #> [1,]    1    2    6   24  120  720 5040 40320 #> [2,]    1    2    6   24  120  720 5040 45360 #> [3,]    1    2    6   24  120  720 5040 50400  ## Fun example with binary representations... consider the following: permuteGeneral(0:1, 3, TRUE) #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    1 #> [3,]    0    1    0 #> [4,]    0    1    1 #> [5,]    1    0    0 #> [6,]    1    0    1 #> [7,]    1    1    0 #> [8,]    1    1    1  permuteGeneral(c(FALSE, TRUE), 3, TRUE, FUN.VALUE = 1,                FUN = function(x) sum(2^(which(rev(x)) - 1))) #> [1] 0 1 2 3 4 5 6 7"},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"passing-additional-arguments-with----","dir":"Articles","previous_headings":"User Defined Functions","what":"Passing additional arguments with ...","title":"Combination and Permutation Basics","text":"version 2.8.3, added ability pass arguments FUN via .... concludes discussion around user defined functions. several nice features allow user easily get desired output fewer function calls well fewer keystrokes. clearly seen example power set. started wrapping call comboGeneral unlist, alleviated parameter FUN.VALUE. simplified usage FUN allowing additional arguments passed via ....","code":"## Again, same example with the power set only this time we ## conveniently pass the additional arguments to paste via '...' comboGeneral(c(\"\", letters[1:3]), 3, freqs = c(2, rep(1, 3)),              FUN = paste, collapse = \"\", FUN.VALUE = \"a\") #> [1] \"a\"   \"b\"   \"c\"   \"ab\"  \"ac\"  \"bc\"  \"abc\""},{"path":"https://jwood000.github.io/RcppAlgos/articles/GeneralCombinatorics.html","id":"s3-methods","dir":"Articles","previous_headings":"","what":"S3 methods","title":"Combination and Permutation Basics","text":"version 2.8.3, added several S3 methods convenience. Take earlier example talking multisets. S3 methods defined simplify interface. Take example case want pass character vector. know underneath hood, character vectors thread safe Parallel nThreads argument ignored. also know constraints parameters applicable numeric vectors. reason, default method’s interface greatly simplified:  see necessary options. numeric types, options numerous:  also list method allows one find combinations permutations lists: feature inspired ggrothendieck : Issue 20.","code":"a <- as.integer(c(1, 1, 1, 1, 2, 2, 2, 7, 7, 7, 7, 7))  ## Explicitly utilizing the freqs argument and determining the unique ## values for v... Still works, but clunky t1 <- permuteGeneral(rle(a)$values, 6, freqs = rle(a)$lengths)  ## Now using the table method... much cleaner t2 <- permuteGeneral(table(a), 6)  identical(t1, t2) #> [1] TRUE comboGeneral(     list(         numbers   = rnorm(4),         states    = state.abb[1:5],         some_data = data.frame(a = c('a', 'b'), b = c(10, 100))     ),     m = 2 ) #> [[1]] #> [[1]]$numbers #> [1] -1.9376332  0.2583997 -0.7198657 -0.8985872 #>  #> [[1]]$states #> [1] \"AL\" \"AK\" \"AZ\" \"AR\" \"CA\" #>  #>  #> [[2]] #> [[2]]$numbers #> [1] -1.9376332  0.2583997 -0.7198657 -0.8985872 #>  #> [[2]]$some_data #>   a   b #> 1 a  10 #> 2 b 100 #>  #>  #> [[3]] #> [[3]]$states #> [1] \"AL\" \"AK\" \"AZ\" \"AR\" \"CA\" #>  #> [[3]]$some_data #>   a   b #> 1 a  10 #> 2 b 100"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"setup-information","dir":"Articles","previous_headings":"","what":"Setup Information","title":"High Performance Benchmarks","text":"benchmarks , used 2022 Macbook Air Apple M2 24 GB machine.","code":"library(RcppAlgos) library(partitions) library(arrangements) #>  #> Attaching package: 'arrangements' #> The following object is masked from 'package:partitions': #>  #>     compositions library(microbenchmark)  options(digits = 4) options(width = 90)  pertinent_output <- capture.output(sessionInfo()) cat(paste(pertinent_output[1:3], collapse = \"\\n\")) #> R version 4.4.2 (2024-10-31) #> Platform: aarch64-apple-darwin20 #> Running under: macOS Sonoma 14.5  pkgs <- c(\"RcppAlgos\", \"arrangements\", \"partitions\", \"microbenchmark\") sapply(pkgs, packageVersion, simplify = FALSE) #> $RcppAlgos #> [1] '2.9.2' #>  #> $arrangements #> [1] '1.1.9' #>  #> $partitions #> [1] '1.10.7' #>  #> $microbenchmark #> [1] '1.4.10'  numThreads <- min(as.integer(RcppAlgos::stdThreadMax() / 2), 6) numThreads #> [1] 4"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"combinations---distinct","dir":"Articles","previous_headings":"Combinations","what":"Combinations - Distinct","title":"High Performance Benchmarks","text":"","code":"set.seed(13) v1 <- sort(sample(100, 30)) m <- 21 t1 <- comboGeneral(v1, m, Parallel = T) t2 <- combinations(v1, m) stopifnot(identical(t1, t2)) dim(t1) #> [1] 14307150       21 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = comboGeneral(v1, m, nThreads = numThreads),                cbRcppAlgosSer = comboGeneral(v1, m),                cbArrangements = combinations(v1, m),                times = 15, unit = \"relative\") #> Warning in microbenchmark(cbRcppAlgosPar = comboGeneral(v1, m, nThreads = numThreads), : #> less accurate nanosecond times to avoid potential integer overflows #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    15 #>  cbRcppAlgosSer 2.666 2.427 2.432  2.423 2.402 2.401    15 #>  cbArrangements 2.517 2.290 2.292  2.282 2.263 2.252    15"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"combinations---repetition","dir":"Articles","previous_headings":"Combinations","what":"Combinations - Repetition","title":"High Performance Benchmarks","text":"","code":"v2 <- v1[1:10] m <- 20 t1 <- comboGeneral(v2, m, repetition = TRUE, nThreads = numThreads) t2 <- combinations(v2, m, replace = TRUE) stopifnot(identical(t1, t2)) dim(t1) #> [1] 10015005       20 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = comboGeneral(v2, m, TRUE, nThreads = numThreads),                cbRcppAlgosSer = comboGeneral(v2, m, TRUE),                cbArrangements = combinations(v2, m, replace = TRUE),                times = 15, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    15 #>  cbRcppAlgosSer 3.014 2.937 2.910  2.921 2.850 2.844    15 #>  cbArrangements 2.771 2.782 2.766  2.762 2.689 2.944    15"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"combinations---multisets","dir":"Articles","previous_headings":"Combinations","what":"Combinations - Multisets","title":"High Performance Benchmarks","text":"","code":"myFreqs <- c(2, 4, 4, 5, 3, 2, 2, 2, 3, 4, 1, 4, 2, 5) v3 <- as.integer(c(1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610)) t1 <- comboGeneral(v3, 20, freqs = myFreqs, nThreads = numThreads) t2 <- combinations(freq = myFreqs, k = 20, x = v3) stopifnot(identical(t1, t2)) dim(t1) #> [1] 14594082       20 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = comboGeneral(v3, 20, freqs = myFreqs, nThreads = numThreads),                cbRcppAlgosSer = comboGeneral(v3, 20, freqs = myFreqs),                cbArrangements = combinations(freq = myFreqs, k = 20, x = v3),                times = 10, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    10 #>  cbRcppAlgosSer 3.105 3.069 3.058  3.040 2.996 3.170    10 #>  cbArrangements 5.664 5.726 5.662  5.672 5.598 5.604    10"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"permutations---distinct","dir":"Articles","previous_headings":"Permutations","what":"Permutations - Distinct","title":"High Performance Benchmarks","text":"","code":"v4 <- as.integer(c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59)) t1 <- permuteGeneral(v4, 6, nThreads = numThreads) t2 <- permutations(v4, 6) stopifnot(identical(t1, t2)) dim(t1) #> [1] 8910720       6 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = permuteGeneral(v4, 6, nThreads = numThreads),                cbRcppAlgosSer = permuteGeneral(v4, 6),                cbArrangements = permutations(v4, 6),                times = 15, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    15 #>  cbRcppAlgosSer 1.167 1.174 1.090  1.160 1.132 1.056    15 #>  cbArrangements 2.042 2.052 1.953  2.025 2.167 1.656    15   ## Indexing permutation example with the partitions package t1 <- permuteGeneral(11, nThreads = 4) t2 <- permutations(11) t3 <- perms(11)  dim(t1) #> [1] 39916800       11  stopifnot(identical(t1, t2), identical(t1, t(as.matrix(t3)))) rm(t1, t2, t3) invisible(gc())  microbenchmark(cbRcppAlgosPar = permuteGeneral(11, nThreads = 4),                cbRcppAlgosSer = permuteGeneral(11),                cbArrangements = permutations(11),                cbPartitions   = perms(11),                times = 5, unit = \"relative\") #> Unit: relative #>            expr    min     lq  mean median     uq   max neval #>  cbRcppAlgosPar  1.000  1.000 1.000  1.000  1.000 1.000     5 #>  cbRcppAlgosSer  2.540  2.477 2.434  2.841  2.825 1.867     5 #>  cbArrangements  3.915  4.136 3.692  4.158  4.246 2.684     5 #>    cbPartitions 10.436 10.282 9.375 10.392 10.990 6.637     5"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"permutations---repetition","dir":"Articles","previous_headings":"Permutations","what":"Permutations - Repetition","title":"High Performance Benchmarks","text":"","code":"v5 <- v3[1:5] t1 <- permuteGeneral(v5, 10, repetition = TRUE, nThreads = numThreads) t2 <- permutations(v5, 10, replace = TRUE) stopifnot(identical(t1, t2)) dim(t1) #> [1] 9765625      10 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = permuteGeneral(v5, 10, TRUE, nThreads = numThreads),                cbRcppAlgosSer = permuteGeneral(v5, 10, TRUE),                cbArrangements = permutations(x = v5, k = 10, replace = TRUE),                times = 10, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    10 #>  cbRcppAlgosSer 3.002 2.803 2.334  2.778 2.780 0.937    10 #>  cbArrangements 3.289 3.055 2.739  3.077 3.077 1.668    10"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"permutations---multisets","dir":"Articles","previous_headings":"Permutations","what":"Permutations - Multisets","title":"High Performance Benchmarks","text":"","code":"v6 <- sort(runif(12)) t1 <- permuteGeneral(v6, 7, freqs = rep(1:3, 4), nThreads = numThreads) t2 <- permutations(freq = rep(1:3, 4), k = 7, x = v6) stopifnot(identical(t1, t2)) dim(t1) #> [1] 19520760        7 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = permuteGeneral(v6, 7, freqs = rep(1:3, 4), nThreads = numThreads),                cbRcppAlgosSer = permuteGeneral(v6, 7, freqs = rep(1:3, 4)),                cbArrangements = permutations(freq = rep(1:3, 4), k = 7, x = v6),                times = 10, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    10 #>  cbRcppAlgosSer 3.531 3.460 3.217  3.437 2.758 2.815    10 #>  cbArrangements 3.901 3.824 3.591  3.816 3.128 3.084    10"},{"path":[]},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"all-distinct-partitions","dir":"Articles","previous_headings":"Partitions > Partitions - Distinct","what":"All Distinct Partitions","title":"High Performance Benchmarks","text":"","code":"t1 <- comboGeneral(0:140, freqs=c(140, rep(1, 140)),                    constraintFun = \"sum\", comparisonFun = \"==\",                    limitConstraints = 140) t2 <- partitions(140, distinct = TRUE) t3 <- diffparts(140)  # Each package has different output formats... we only examine dimensions # and that each result is a partition of 140 stopifnot(identical(dim(t1), dim(t2)), identical(dim(t1), dim(t(t3))),                     all(rowSums(t1) == 140), all(rowSums(t2) == 140),                     all(colSums(t3) == 140)) dim(t1) #> [1] 9617150      16 rm(t1, t2, t3) invisible(gc()) microbenchmark(cbRcppAlgosPar = partitionsGeneral(0:140, freqs=c(140, rep(1, 140)), nThreads = numThreads),                cbRcppAlgosSer = partitionsGeneral(0:140, freqs=c(140, rep(1, 140))),                cbArrangements = partitions(140, distinct = TRUE),                cbPartitions   = diffparts(140),                times = 10, unit = \"relative\") #> Unit: relative #>            expr    min     lq   mean median     uq    max neval #>  cbRcppAlgosPar  1.000  1.000  1.000  1.000  1.000  1.000    10 #>  cbRcppAlgosSer  3.172  3.178  2.887  3.098  2.696  2.539    10 #>  cbArrangements  2.510  2.528  2.316  2.488  2.205  2.173    10 #>    cbPartitions 16.918 17.160 15.042 17.001 13.310 12.298    10"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"restricted-distinct-partitions","dir":"Articles","previous_headings":"Partitions > Partitions - Distinct","what":"Restricted Distinct Partitions","title":"High Performance Benchmarks","text":"","code":"t1 <- comboGeneral(160, 10,                    constraintFun = \"sum\", comparisonFun = \"==\",                    limitConstraints = 160) t2 <- partitions(160, 10, distinct = TRUE) stopifnot(identical(t1, t2)) dim(t1) #> [1] 8942920      10 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = partitionsGeneral(160, 10, nThreads = numThreads),                cbRcppAlgosSer = partitionsGeneral(160, 10),                cbArrangements = partitions(160, 10, distinct = TRUE),                times = 10, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    10 #>  cbRcppAlgosSer 3.428 3.401 3.013  3.220 3.200 2.316    10 #>  cbArrangements 4.657 4.587 3.951  4.307 4.274 2.936    10"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"all-partitions","dir":"Articles","previous_headings":"Partitions > Partitions - Repetition","what":"All Partitions","title":"High Performance Benchmarks","text":"","code":"t1 <- comboGeneral(0:65, repetition = TRUE, constraintFun = \"sum\",                    comparisonFun = \"==\", limitConstraints = 65) t2 <- partitions(65) t3 <- parts(65)  # Each package has different output formats... we only examine dimensions # and that each result is a partition of 65 stopifnot(identical(dim(t1), dim(t2)), identical(dim(t1), dim(t(t3))),           all(rowSums(t1) == 65), all(rowSums(t2) == 65),           all(colSums(t3) == 65)) dim(t1) #> [1] 2012558      65 rm(t1, t2, t3) invisible(gc()) microbenchmark(cbRcppAlgosPar = partitionsGeneral(0:65, repetition = TRUE,                                                   nThreads = numThreads),                cbRcppAlgosSer = partitionsGeneral(0:65, repetition = TRUE),                cbArrangements = partitions(65),                cbPartitions   = parts(65),                times = 20, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    20 #>  cbRcppAlgosSer 2.849 2.767 2.311  2.461 2.313 1.751    20 #>  cbArrangements 2.122 2.047 1.712  1.834 1.794 1.130    20 #>    cbPartitions 8.855 8.639 6.886  7.736 6.792 4.217    20"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"restricted-partitions","dir":"Articles","previous_headings":"Partitions > Partitions - Repetition","what":"Restricted Partitions","title":"High Performance Benchmarks","text":"","code":"t1 <- comboGeneral(100, 15, TRUE, constraintFun = \"sum\",                    comparisonFun = \"==\", limitConstraints = 100) t2 <- partitions(100, 15) stopifnot(identical(t1, t2)) dim(t1) #> [1] 9921212      15 rm(t1, t2)  # This takes a really long time... not because of restrictedparts, # but because apply is not that fast. This transformation is # needed for proper comparisons. As a result, we will compare # a smaller example # t3 <- t(apply(as.matrix(restrictedparts(100, 15, include.zero = F)), 2, sort)) t3 <- t(apply(as.matrix(restrictedparts(50, 15, include.zero = F)), 2, sort)) stopifnot(identical(partitions(50, 15), t3)) rm(t3) invisible(gc()) microbenchmark(cbRcppAlgosPar = partitionsGeneral(100, 15, TRUE,                                                   nThreads = numThreads),                cbRcppAlgosSer = partitionsGeneral(100, 15, TRUE),                cbArrangements = partitions(100, 15),                cbPartitions   = restrictedparts(100, 15,                                                 include.zero = FALSE),                times = 10, unit = \"relative\") #> Unit: relative #>            expr    min     lq   mean median    uq    max neval #>  cbRcppAlgosPar  1.000  1.000  1.000  1.000  1.00  1.000    10 #>  cbRcppAlgosSer  3.402  3.281  3.055  3.150  2.85  2.827    10 #>  cbArrangements  4.194  4.045  3.884  4.087  3.51  3.985    10 #>    cbPartitions 14.250 14.076 12.877 13.534 11.57 11.824    10"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"partitions---multisets","dir":"Articles","previous_headings":"Partitions","what":"Partitions - Multisets","title":"High Performance Benchmarks","text":"Currenlty, RcppAlgos package capable efficiently generating partitions multisets. Therefore, time RcppAlgos use reference future improvements.","code":"t1 <- comboGeneral(120, 10, freqs=rep(1:8, 15),                    constraintFun = \"sum\", comparisonFun = \"==\",                    limitConstraints = 120) dim(t1) #> [1] 7340225      10 stopifnot(all(rowSums(t1) == 120)) microbenchmark(cbRcppAlgos = partitionsGeneral(120, 10, freqs=rep(1:8, 15)),                times = 10) #> Unit: milliseconds #>         expr   min    lq  mean median    uq   max neval #>  cbRcppAlgos 246.8 250.6 255.3  252.6 256.4 269.3    10"},{"path":[]},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"all-compositions-small-case","dir":"Articles","previous_headings":"Compositions > Compositions - Repetition","what":"All Compositions (Small case)","title":"High Performance Benchmarks","text":"next two examples, exclude partitions package efficiency reasons.","code":"t1 <- compositionsGeneral(0:15, repetition = TRUE) t2 <- arrangements::compositions(15) t3 <- partitions::compositions(15)  # Each package has different output formats... we only examine dimensions # and that each result is a partition of 15 stopifnot(identical(dim(t1), dim(t2)), identical(dim(t1), dim(t(t3))),           all(rowSums(t1) == 15), all(rowSums(t2) == 15),           all(colSums(t3) == 15)) dim(t1) #> [1] 16384    15 rm(t1, t2, t3) invisible(gc()) microbenchmark(cbRcppAlgosSer = compositionsGeneral(0:15, repetition = TRUE),                cbArrangements = arrangements::compositions(15),                cbPartitions   = partitions::compositions(15),                times = 20, unit = \"relative\") #> Unit: relative #>            expr     min      lq   mean  median      uq     max neval #>  cbRcppAlgosSer   1.000   1.000   1.00   1.000   1.000   1.000    20 #>  cbArrangements   1.182   1.205   1.18   1.194   1.179   1.054    20 #>    cbPartitions 129.267 145.992 186.50 192.884 219.196 230.413    20"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"all-compositions-larger-case","dir":"Articles","previous_headings":"Compositions > Compositions - Repetition","what":"All Compositions (Larger case)","title":"High Performance Benchmarks","text":"","code":"t1 <- compositionsGeneral(0:23, repetition = TRUE) t2 <- arrangements::compositions(23)  # Each package has different output formats... we only examine dimensions # and that each result is a partition of 23 stopifnot(identical(dim(t1), dim(t2)), all(rowSums(t1) == 23),           all(rowSums(t2) == 23)) dim(t1) #> [1] 4194304      23 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = compositionsGeneral(0:23, repetition = TRUE,                                                     nThreads = numThreads),                cbRcppAlgosSer = compositionsGeneral(0:23, repetition = TRUE),                cbArrangements = arrangements::compositions(23),                times = 20, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    20 #>  cbRcppAlgosSer 3.410 3.329 3.331  3.327 3.324 3.397    20 #>  cbArrangements 3.797 3.699 3.691  3.698 3.689 3.611    20"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"restricted-compositions","dir":"Articles","previous_headings":"Compositions > Compositions - Repetition","what":"Restricted Compositions","title":"High Performance Benchmarks","text":"","code":"t1 <- compositionsGeneral(30, 10, repetition = TRUE) t2 <- arrangements::compositions(30, 10)  stopifnot(identical(t1, t2), all(rowSums(t1) == 30)) dim(t1) #> [1] 10015005       10 rm(t1, t2) invisible(gc()) microbenchmark(cbRcppAlgosPar = compositionsGeneral(30, 10, repetition = TRUE,                                                     nThreads = numThreads),                cbRcppAlgosSer = compositionsGeneral(30, 10, repetition = TRUE),                cbArrangements = arrangements::compositions(30, 10),                times = 20, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>  cbRcppAlgosPar 1.000 1.000 1.000  1.000 1.000 1.000    20 #>  cbRcppAlgosSer 2.988 3.077 2.952  3.020 3.082 1.924    20 #>  cbArrangements 3.199 3.170 3.036  3.113 3.074 2.213    20"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"iterators","dir":"Articles","previous_headings":"","what":"Iterators","title":"High Performance Benchmarks","text":"show one example category demonstrate efficiency iterators RcppAlgos. results similar rest cases shown.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"combinations-1","dir":"Articles","previous_headings":"Iterators","what":"Combinations","title":"High Performance Benchmarks","text":"","code":"pkg_arrangements <- function(n, total) {     a <- icombinations(n, as.integer(n / 2))     for (i in 1:total) a$getnext() }  pkg_RcppAlgos <- function(n, total) {     a <- comboIter(n, as.integer(n / 2))     for (i in 1:total) a@nextIter() }  total <- comboCount(18, 9) total #> [1] 48620  microbenchmark(cbRcppAlgos    = pkg_RcppAlgos(18, total),                cbArrangements = pkg_arrangements(18, total),                times = 15, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median   uq   max neval #>     cbRcppAlgos  1.00  1.00  1.00   1.00  1.0  1.00    15 #>  cbArrangements 19.31 19.12 18.91  18.81 18.6 18.81    15"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"permutations-1","dir":"Articles","previous_headings":"Iterators","what":"Permutations","title":"High Performance Benchmarks","text":"","code":"pkg_arrangements <- function(n, total) {     a <- ipermutations(n)     for (i in 1:total) a$getnext() }  pkg_RcppAlgos <- function(n, total) {     a <- permuteIter(n)     for (i in 1:total) a@nextIter() }  total <- permuteCount(8) total #> [1] 40320  microbenchmark(cbRcppAlgos    = pkg_RcppAlgos(8, total),                cbArrangements = pkg_arrangements(8, total),                times = 15, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>     cbRcppAlgos  1.00  1.00  1.00   1.00  1.00  1.00    15 #>  cbArrangements 19.61 19.41 18.93  19.14 18.66 17.41    15"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"partitions-1","dir":"Articles","previous_headings":"Iterators","what":"Partitions","title":"High Performance Benchmarks","text":"","code":"pkg_partitions <- function(n, total) {     a <- firstpart(n)     for (i in 1:(total - 1)) a <- nextpart(a) }  pkg_arrangements <- function(n, total) {     a <- ipartitions(n)     for (i in 1:total) a$getnext() }  pkg_RcppAlgos <- function(n, total) {     a <- partitionsIter(0:n, repetition = TRUE)     for (i in 1:total) a@nextIter() }  total <- partitionsCount(0:40, repetition = TRUE) total #> [1] 37338  microbenchmark(cbRcppAlgos    = pkg_RcppAlgos(40, total),                cbArrangements = pkg_arrangements(40, total),                cbPartitions   = pkg_partitions(40, total),                times = 15, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>     cbRcppAlgos  1.00  1.00  1.00   1.00  1.00  1.00    15 #>  cbArrangements 15.40 15.11 14.18  14.50 13.21 13.74    15 #>    cbPartitions 24.79 24.45 23.08  23.48 21.81 21.54    15"},{"path":"https://jwood000.github.io/RcppAlgos/articles/HighPerformanceBenchmarks.html","id":"compositions-1","dir":"Articles","previous_headings":"Iterators","what":"Compositions","title":"High Performance Benchmarks","text":"","code":"pkg_partitions <- function(n, total) {     a <- firstcomposition(n)     for (i in 1:(total - 1)) a <- nextcomposition(a, FALSE) }  pkg_arrangements <- function(n, total) {     a <- icompositions(n)     for (i in 1:total) a$getnext() }  pkg_RcppAlgos <- function(n, total) {     a <- compositionsIter(0:n, repetition = TRUE)     for (i in 1:total) a@nextIter() }  total <- compositionsCount(0:15, repetition = TRUE) total #> [1] 16384  microbenchmark(cbRcppAlgos    = pkg_RcppAlgos(15, total),                cbArrangements = pkg_arrangements(15, total),                cbPartitions   = pkg_partitions(15, total),                times = 15, unit = \"relative\") #> Unit: relative #>            expr   min    lq  mean median    uq   max neval #>     cbRcppAlgos  1.00  1.00  1.00   1.00  1.00  1.00    15 #>  cbArrangements 14.23 14.15 13.45  14.01 12.98 12.10    15 #>    cbPartitions 43.88 43.91 41.42  43.40 40.17 34.25    15"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"expandgrid","dir":"Articles","previous_headings":"","what":"expandGrid","title":"Cartesian Products and Partitions of Groups","text":"Just like base R counterpart expand.grid, can generate Cartesian product using expandGrid. caveats discussed detail docs (see ?expandGrid). main difference expandGrid varies first column slowest inputs type, matrix returned.","code":"library(RcppAlgos)  ht <- function(d, m = 5, n = m) {     ## print the head and tail together     cat(\"head -->\\n\")     print(head(d, m))     cat(\"--------\\n\")     cat(\"tail -->\\n\")     print(tail(d, n)) }  ## Base R first. Example inspired by expand.grid docs. expand.grid(height = seq(60, 80, 10), weight = seq(100, 200, 50),             sex = c(\"Male\",\"Female\")) #>    height weight    sex #> 1      60    100   Male #> 2      70    100   Male #> 3      80    100   Male #> 4      60    150   Male #> 5      70    150   Male #> 6      80    150   Male #> 7      60    200   Male #> 8      70    200   Male #> 9      80    200   Male #> 10     60    100 Female #> 11     70    100 Female #> 12     80    100 Female #> 13     60    150 Female #> 14     70    150 Female #> 15     80    150 Female #> 16     60    200 Female #> 17     70    200 Female #> 18     80    200 Female  ## Now RcppAlgos::expandGrid expandGrid(height = seq(60, 80, 10), weight = seq(100, 200, 50),            sex = c(\"Male\",\"Female\")) #>    height weight    sex #> 1      60    100   Male #> 2      60    100 Female #> 3      60    150   Male #> 4      60    150 Female #> 5      60    200   Male #> 6      60    200 Female #> 7      70    100   Male #> 8      70    100 Female #> 9      70    150   Male #> 10     70    150 Female #> 11     70    200   Male #> 12     70    200 Female #> 13     80    100   Male #> 14     80    100 Female #> 15     80    150   Male #> 16     80    150 Female #> 17     80    200   Male #> 18     80    200 Female"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"matrix-vs-data-frame-output","dir":"Articles","previous_headings":"expandGrid","what":"Matrix vs Data.Frame Output","title":"Cartesian Products and Partitions of Groups","text":"","code":"lst = Map(\\(x, y) x:y, 8:12, 13:17)  class(expand.grid(lst)) #> [1] \"data.frame\"  ## ht defined above ht(expand.grid(lst)) #> head --> #>   Var1 Var2 Var3 Var4 Var5 #> 1    8    9   10   11   12 #> 2    9    9   10   11   12 #> 3   10    9   10   11   12 #> 4   11    9   10   11   12 #> 5   12    9   10   11   12 #> -------- #> tail --> #>      Var1 Var2 Var3 Var4 Var5 #> 7772    9   14   15   16   17 #> 7773   10   14   15   16   17 #> 7774   11   14   15   16   17 #> 7775   12   14   15   16   17 #> 7776   13   14   15   16   17  class(expandGrid(lst)) #> [1] \"matrix\" \"array\"  ht(expandGrid(lst)) #> head --> #>      Var1 Var2 Var3 Var4 Var5 #> [1,]    8    9   10   11   12 #> [2,]    8    9   10   11   13 #> [3,]    8    9   10   11   14 #> [4,]    8    9   10   11   15 #> [5,]    8    9   10   11   16 #> -------- #> tail --> #>         Var1 Var2 Var3 Var4 Var5 #> [7772,]   13   14   15   16   13 #> [7773,]   13   14   15   16   14 #> [7774,]   13   14   15   16   15 #> [7775,]   13   14   15   16   16 #> [7776,]   13   14   15   16   17"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"always-return-data-frame","dir":"Articles","previous_headings":"expandGrid","what":"Always Return data.frame","title":"Cartesian Products and Partitions of Groups","text":"really need always return data.frame, can utilize argument return_df:","code":"class(expandGrid(lst, return_df = TRUE)) #> [1] \"data.frame\"  ht(expandGrid(lst, return_df = TRUE)) #> head --> #>   Var1 Var2 Var3 Var4 Var5 #> 1    8    9   10   11   12 #> 2    8    9   10   11   13 #> 3    8    9   10   11   14 #> 4    8    9   10   11   15 #> 5    8    9   10   11   16 #> -------- #> tail --> #>      Var1 Var2 Var3 Var4 Var5 #> 7772   13   14   15   16   13 #> 7773   13   14   15   16   14 #> 7774   13   14   15   16   15 #> 7775   13   14   15   16   16 #> 7776   13   14   15   16   17"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"familiar-rcppalgos-api-components","dir":"Articles","previous_headings":"expandGrid","what":"Familiar RcppAlgos API Components","title":"Cartesian Products and Partitions of Groups","text":"Just RcppAlgos functions, can take advantage arguments lower, upper, nThreads. example, can see decrease execution time using nThreads:","code":"library(microbenchmark) options(digits = 4) stdThreadMax() #> [1] 8  numThreads = as.integer(stdThreadMax() / 2) lst_med = Map(\\(x, y) x:y, 8:17, 11:20) expandGridCount(lst_med) #> [1] 1048576  microbenchmark(     baseR = expand.grid(lst_med),     RcppAlgos_Ser = expandGrid(lst_med),     RcppAlgos_Par = expandGrid(lst_med, nThreads = numThreads),     unit = \"relative\" ) #> Warning in microbenchmark(baseR = expand.grid(lst_med), RcppAlgos_Ser = #> expandGrid(lst_med), : less accurate nanosecond times to avoid potential #> integer overflows #> Unit: relative #>           expr    min     lq  mean median    uq   max neval #>          baseR 13.911 11.572 7.035 10.306 8.829 2.589   100 #>  RcppAlgos_Ser  3.516  2.999 1.962  2.762 2.324 1.415   100 #>  RcppAlgos_Par  1.000  1.000 1.000  1.000 1.000 1.000   100"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"expandgridsample","dir":"Articles","previous_headings":"expandGrid","what":"expandGridSample","title":"Cartesian Products and Partitions of Groups","text":"want random sample Cartesian product, can call upon expandGridSample. Just RcppAlgos sampling functions, can utlize n, sampleVec, nThreads, namedSample arguments.","code":"## lst_med is defined above all_carts = expandGrid(lst_med)  cart_samp = expandGridSample(lst_med, n = 5, seed = 42, namedSample = TRUE) cart_samp #>        Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 #> 61413     8    9   13   13   15   16   17   17   17    17 #> 54425     8    9   13   12   13   13   16   16   18    17 #> 623844   10   10   12   11   13   13   17   17   16    20 #> 74362     8   10   10   13   12   15   15   18   18    18 #> 46208     8    9   12   14   13   13   15   18   19    20  as.numeric(rownames(cart_samp)) #> [1]  61413  54425 623844  74362  46208  ## cart_samp has same output as subsetting all_carts all_carts[as.numeric(rownames(cart_samp)), ] #>      Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 #> [1,]    8    9   13   13   15   16   17   17   17    17 #> [2,]    8    9   13   12   13   13   16   16   18    17 #> [3,]   10   10   12   11   13   13   17   17   16    20 #> [4,]    8   10   10   13   12   15   15   18   18    18 #> [5,]    8    9   12   14   13   13   15   18   19    20"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"powerful-iterators-with-expandgriditer","dir":"Articles","previous_headings":"expandGrid","what":"Powerful Iterators with expandGridIter","title":"Cartesian Products and Partitions of Groups","text":"many functions RcppAlgos, iterator offering Cartesian product expandGridIter. iterators memory efficient computationally efficient. flexible well allowing users grab next iteration, next n iterations, random access, . example docs (see ?expandGridIter): Now discuss two problems can get unwieldy quickly.","code":"a = expandGridIter(factor(state.abb), euro, islands) a@nextIter() #>   Var1  Var2  Var3 #> 1   AL 13.76 11506  a@nextNIter(3) #>   Var1  Var2  Var3 #> 1   AL 13.76  5500 #> 2   AL 13.76 16988 #> 3   AL 13.76  2968  a@front() #>   Var1  Var2  Var3 #> 1   AL 13.76 11506  all_remaining = a@nextRemaining() dim(all_remaining) #> [1] 26399     3  a@summary() #> $description #> [1] \"Cartesian Product of the source (see the sourceVector method for more info)\" #>  #> $currentIndex #> [1] 26401 #>  #> $totalResults #> [1] 26400 #>  #> $totalRemaining #> [1] -1  a@back() #>   Var1  Var2 Var3 #> 1   WY 200.5   82  a[[5]] #>   Var1  Var2 Var3 #> 1   AL 13.76   16  a@summary() #> $description #> [1] \"Cartesian Product of the source (see the sourceVector method for more info)\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 26400 #>  #> $totalRemaining #> [1] 26395  a[[c(1, 17, 3)]] #>   Var1  Var2  Var3 #> 1   AL 13.76 11506 #> 2   AL 13.76    13 #> 3   AL 13.76 16988  a@summary() #> $description #> [1] \"Cartesian Product of the source (see the sourceVector method for more info)\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 26400 #>  #> $totalRemaining #> [1] 26395"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"cartesian-product-where-order-does-not-matter","dir":"Articles","previous_headings":"","what":"Cartesian Product where Order does not Matter","title":"Cartesian Products and Partitions of Groups","text":"Given list vectors, v1, v2, … , vn, intersection two vectors non-empty, find unique combinations (order matter) elements Cartesian product vectors. example, lets say : v1 = 1:4 v2 = 2:5. Cartesian product given expand.grid(v1, v2) (continue use ht function defined Combination Permutation Basics vignette): don’t care order, following row pairs considered equal can therefore pruned obtain desired results: (r3, r6) (r4, r10) (r8, r11) comboGrid duplicates generated: Note order expand.grid comboGrid differ. order comboGrid lexicographical meaning last column vary fastest whereas expand.grid, first column vary fastest. also note output expand.grid data.frame whereas comboGrid, get matrix. comboGrid, get data.frame classes vector different generally speaking, working matrices preferable. small example , filter 3 16 total results (less 20%). isn’t bad. general case, might well just stick expand.grid efficient. Unfortunately, general case number vectors overlap increases, filtering become impractical. Consider following example: function comboGrid highly inspired following question stackoverflow: Picking unordered combinations pools overlap Currenlty, underlying algorithm gold standard. , mean results generated one one. Efforts underway achieve , point proven quite difficult (See comprehensive answer Tim Peters (yes, Tim Peters)). algorithm comboGrid leverages Fundamental Theorem Arithmetic efficiently generate keys used hash function determine particular combination elements encountered. greater efficiency, make use deduplication user2357112 suggests.","code":"expand.grid(1:4, 2:5) #>    Var1 Var2 #> 1     1    2 #> 2     2    2 #> 3     3    2  ### <-- Same as row 6 #> 4     4    2  ### <-- Same as row 10 #> 5     1    3 #> 6     2    3  ### <-- Same as row 3 #> 7     3    3 #> 8     4    3  ### <-- Same as row 11 #> 9     1    4 #> 10    2    4  ### <-- Same as row 4 #> 11    3    4  ### <-- Same as row 8 #> 12    4    4 #> 13    1    5 #> 14    2    5 #> 15    3    5 #> 16    4    5 comboGrid(1:4, 2:5) #>       Var1 Var2 #>  [1,]    1    2 #>  [2,]    1    3 #>  [3,]    1    4 #>  [4,]    1    5 #>  [5,]    2    2 #>  [6,]    2    3 #>  [7,]    2    4 #>  [8,]    2    5 #>  [9,]    3    3 #> [10,]    3    4 #> [11,]    3    5 #> [12,]    4    4 #> [13,]    4    5 pools = list(c(1, 10, 14, 6),              c(7, 2, 4, 8, 3, 11, 12),              c(11, 3, 13, 4, 15, 8, 6, 5),              c(10, 1, 3, 2, 9, 5,  7),              c(1, 5, 10, 3, 8, 14),              c(15, 3, 7, 10, 4, 5, 8, 6),              c(14, 9, 11, 15),              c(7, 6, 13, 14, 10, 11, 9, 4),              c(6,  3,  2, 14,  7, 12,  9),              c(6, 11,  2,  5, 15,  7))  ## If we used expand.grid, we would have to filter ## more than 100 million results prod(lengths(pools)) #> [1] 101154816  ## With comboGrid, this is no problem system.time(myCombs <- comboGrid(pools)) #>    user  system elapsed  #>   0.256   0.022   0.279  print(object.size(myCombs), unit = \"Mb\") #> 92 Mb  ht(myCombs) #> head --> #>      Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 #> [1,]    1    2    3    1    1    3    9    4    2     2 #> [2,]    1    2    3    1    1    3    9    4    2     5 #> [3,]    1    2    3    1    1    3    9    4    2     6 #> [4,]    1    2    3    1    1    3    9    4    2     7 #> [5,]    1    2    3    1    1    3    9    4    2    11 #> -------- #> tail --> #>            Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 #> [1205736,]   14   12   15   10   14   15   15   11   12    15 #> [1205737,]   14   12   15   10   14   15   15   13   12    15 #> [1205738,]   14   12   15   10   14   15   15   13   14    15 #> [1205739,]   14   12   15   10   14   15   15   14   12    15 #> [1205740,]   14   12   15   10   14   15   15   14   14    15  ## This is just the time to create the cartesian product ## Generating keys, then filtering will take much more time system.time(cartProd <- expand.grid(pools)) #>    user  system elapsed  #>   3.565   0.755   4.358  ## Creates huge object print(object.size(cartProd), unit = \"Mb\") #> 7717.5 Mb  ## What if we want results with unique values... ## Simply set repetition = FALSE system.time(myCombsNoRep <- comboGrid(pools, repetition = FALSE)) #>    user  system elapsed  #>   0.004   0.000   0.004  ht(myCombsNoRep) #> head --> #>      Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 #> [1,]    1    2    3    5    8    4    9    6    7    11 #> [2,]    1    2    3    5    8    4    9    6    7    15 #> [3,]    1    2    3    5    8    4    9    6   12     7 #> [4,]    1    2    3    5    8    4    9    6   12    11 #> [5,]    1    2    3    5    8    4    9    6   12    15 #> -------- #> tail --> #>         Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 #> [2977,]   14    3    4    5    8   15    9   13   12    11 #> [2978,]   14    3    4    7    5   15    9   13   12    11 #> [2979,]   14    3    4    7    8   15    9   13   12    11 #> [2980,]   14    3    5    7    8   15    9   13   12    11 #> [2981,]   14    4    5    7    8   15    9   13   12    11"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"in-the-wild","dir":"Articles","previous_headings":"Cartesian Product where Order does not Matter","what":"In the Wild","title":"Cartesian Products and Partitions of Groups","text":"R - Expand Grid Without Duplicates Non-redundant version expand.grid","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"partitions-of-groups-with-combogroups","dir":"Articles","previous_headings":"","what":"Partitions of Groups with comboGroups","title":"Cartesian Products and Partitions of Groups","text":"Given vector length n k groups, k divides n, group comprised combination vector chosen g = n / k time. stated documentation (see ?comboGroups), can constructed first generating permutations vector subsequently removing entries permuted groups. Let us consider following example. Given v = 1:12, generate partitions v 3 groups size 4. starting see pattern. new partition exactly 24 spots away. makes sense factorial(4) = 24 permutations size 4. Now, oversimplification simply generate every 24th permutation, still get duplication start carry groups. Observe: gets muddled number groups increases. also inefficient, however exercise hopefully serves better illustrate structures. algorithm comboGroups avoids duplication implementing novel algorithm akin std::next_permutation algorithm library C++. Just {combo|permute}General, can utilize arguments lower, upper, Parallel, nThreads.","code":"funBruteGrp <- function(myLow = 1, myUp) {     mat <- do.call(         rbind,         permuteGeneral(12, lower = myLow, upper = myUp,             FUN = \\(x) {                 sapply(seq(0, 8, 4), \\(y) {                      paste(c(\"(\", x[(y + 1):(y + 4)], \")\"), collapse = \" \")                 })             }         )     )     colnames(mat) <- paste0(\"Grp\", 1:3)     rownames(mat) <- myLow:myUp     mat }  ## All of these are the same as only the 3rd group is being permuted funBruteGrp(myUp = 6) #>   Grp1          Grp2          Grp3             #> 1 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 9 10 11 12 )\" #> 2 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 9 10 12 11 )\" #> 3 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 9 11 10 12 )\" #> 4 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 9 11 12 10 )\" #> 5 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 9 12 10 11 )\" #> 6 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 9 12 11 10 )\"  ## We found our second distinct partition funBruteGrp(myLow = 23, myUp = 26) #>    Grp1          Grp2          Grp3             #> 23 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 12 11 9 10 )\" #> 24 \"( 1 2 3 4 )\" \"( 5 6 7 8 )\" \"( 12 11 10 9 )\" #> 25 \"( 1 2 3 4 )\" \"( 5 6 7 9 )\" \"( 8 10 11 12 )\"  ### <-- 2nd distinct partition of groups #> 26 \"( 1 2 3 4 )\" \"( 5 6 7 9 )\" \"( 8 10 12 11 )\"  funBruteGrp(myLow = 48, myUp = 50) #>    Grp1          Grp2           Grp3             #> 48 \"( 1 2 3 4 )\" \"( 5 6 7 9 )\"  \"( 12 11 10 8 )\" #> 49 \"( 1 2 3 4 )\" \"( 5 6 7 10 )\" \"( 8 9 11 12 )\"  ### <-- 3rd distinct partition of groups #> 50 \"( 1 2 3 4 )\" \"( 5 6 7 10 )\" \"( 8 9 12 11 )\" do.call(rbind, lapply(seq(1, 169, 24), function(x) {     funBruteGrp(myLow = x, myUp = x) })) #>     Grp1          Grp2           Grp3             #> 1   \"( 1 2 3 4 )\" \"( 5 6 7 8 )\"  \"( 9 10 11 12 )\" #> 25  \"( 1 2 3 4 )\" \"( 5 6 7 9 )\"  \"( 8 10 11 12 )\" #> 49  \"( 1 2 3 4 )\" \"( 5 6 7 10 )\" \"( 8 9 11 12 )\"  #> 73  \"( 1 2 3 4 )\" \"( 5 6 7 11 )\" \"( 8 9 10 12 )\"  #> 97  \"( 1 2 3 4 )\" \"( 5 6 7 12 )\" \"( 8 9 10 11 )\"  #> 121 \"( 1 2 3 4 )\" \"( 5 6 8 7 )\"  \"( 9 10 11 12 )\"  ### <-- This is the same as the 1st #> 145 \"( 1 2 3 4 )\" \"( 5 6 8 9 )\"  \"( 7 10 11 12 )\"  ### partition. The only difference is #> 169 \"( 1 2 3 4 )\" \"( 5 6 8 10 )\" \"( 7 9 11 12 )\"   ### that the 2nd Grp has been permuted system.time(comboGroups(12, numGroups = 3)) #>    user  system elapsed  #>       0       0       0  ht(comboGroups(12, numGroups = 3)) #> head --> #>      Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3 #> [1,]    1    2    3    4    5    6    7    8    9   10   11   12 #> [2,]    1    2    3    4    5    6    7    9    8   10   11   12 #> [3,]    1    2    3    4    5    6    7   10    8    9   11   12 #> [4,]    1    2    3    4    5    6    7   11    8    9   10   12 #> [5,]    1    2    3    4    5    6    7   12    8    9   10   11 #> -------- #> tail --> #>         Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3 #> [5771,]    1   10   11   12    2    5    8    9    3    4    6    7 #> [5772,]    1   10   11   12    2    6    7    8    3    4    5    9 #> [5773,]    1   10   11   12    2    6    7    9    3    4    5    8 #> [5774,]    1   10   11   12    2    6    8    9    3    4    5    7 #> [5775,]    1   10   11   12    2    7    8    9    3    4    5    6 comboGroupsCount(30, 6) #> Big Integer ('bigz') : #> [1] 123378675083039376  system.time(a1 <- comboGroups(30, numGroups = 6,                               lower = \"123378675000000000\",                               upper = \"123378675005000000\")) #>    user  system elapsed  #>   0.121   0.034   0.164  ## Use specific number of threads system.time(a2 <- comboGroups(30, numGroups = 6,                               lower = \"123378675000000000\",                               upper = \"123378675005000000\", nThreads = 4)) #>    user  system elapsed  #>   0.144   0.060   0.109  ## Use n - 1 number of threads (in this case, there are 7) system.time(a3 <- comboGroups(30, numGroups = 6,                               lower = \"123378675000000000\",                               upper = \"123378675005000000\", Parallel = TRUE)) #>    user  system elapsed  #>   0.161   0.074   0.078  identical(a1, a2) #> [1] TRUE  identical(a1, a3) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"partitions-of-groups-of-varying-sizes","dir":"Articles","previous_headings":"Partitions of Groups with comboGroups","what":"Partitions of Groups of Varying Sizes","title":"Cartesian Products and Partitions of Groups","text":"2.8.+ can generate partitions groups varying sizes. example, say want generate partitions vector v = 1:15 2 groups 3, 1 groups 4, 1 group 5: flexibility offered groups equal size present groups varying sizes well. example, can generate groups varying sizes parallel: one additional argument (.e. retType) present two general functions allows user specify type object returned. user can select \"matrix\" (default) \"3Darray\". structure natural connection 3D space size group uniform. particular result (1st dimension) broken groups (2nd dimension) certain size (3rd dimension).","code":"system.time(a4 <- comboGroups(15, grpSizes = c(3, 3, 4, 5))) #>    user  system elapsed  #>   0.125   0.030   0.164  ht(a4) #> head --> #>      Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3 Grp4 Grp4 Grp4 Grp4 Grp4 #> [1,]    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15 #> [2,]    1    2    3    4    5    6    7    8    9   11   10   12   13   14   15 #> [3,]    1    2    3    4    5    6    7    8    9   12   10   11   13   14   15 #> [4,]    1    2    3    4    5    6    7    8    9   13   10   11   12   14   15 #> [5,]    1    2    3    4    5    6    7    8    9   14   10   11   12   13   15 #> -------- #> tail --> #>            Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3 Grp4 Grp4 Grp4 #> [6306296,]   10   14   15   11   12   13    5    6    7    8    1    2    3 #> [6306297,]   10   14   15   11   12   13    5    6    7    9    1    2    3 #> [6306298,]   10   14   15   11   12   13    5    6    8    9    1    2    3 #> [6306299,]   10   14   15   11   12   13    5    7    8    9    1    2    3 #> [6306300,]   10   14   15   11   12   13    6    7    8    9    1    2    3 #>            Grp4 Grp4 #> [6306296,]    4    9 #> [6306297,]    4    8 #> [6306298,]    4    7 #> [6306299,]    4    6 #> [6306300,]    4    5  dim(a4) #> [1] 6306300      15 system.time(a5 <- comboGroups(15, grpSizes = c(3, 3, 4, 5), nThreads = 4)) #>    user  system elapsed  #>   0.143   0.034   0.058  identical(a4, a5) #> [1] TRUE my3D <- comboGroups(factor(month.abb), 4, retType = \"3Darray\") my3D[1, , ] #>      Grp1 Grp2 Grp3 Grp4 #> [1,] Jan  Apr  Jul  Oct  #> [2,] Feb  May  Aug  Nov  #> [3,] Mar  Jun  Sep  Dec  #> Levels: Apr Aug Dec Feb Jan Jul Jun Mar May Nov Oct Sep  comboGroupsCount(12, 4) #> [1] 15400  my3D[15400, , ] #>      Grp1 Grp2 Grp3 Grp4 #> [1,] Jan  Feb  Mar  Apr  #> [2,] Nov  Sep  Jul  May  #> [3,] Dec  Oct  Aug  Jun  #> Levels: Apr Aug Dec Feb Jan Jul Jun Mar May Nov Oct Sep"},{"path":"https://jwood000.github.io/RcppAlgos/articles/OtherCombinatorics.html","id":"relevant-posts-on-stackoverflow-as-well-as-oeis-","dir":"Articles","previous_headings":"Partitions of Groups with comboGroups","what":"Relevant Posts on Stackoverflow as well as OEIS.","title":"Cartesian Products and Partitions of Groups","text":"Iterating combinations groups 4 within group 16 Create Combinations R Groups Algorithm can create combinations groups combinations R expand.grid repeated combinations vector groups Find possible teams R https://oeis.org/A025035 (See also sequences A025036-A025042)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/articles/SubsetSum.html","id":"building-on-integer-partitions","dir":"Articles","previous_headings":"","what":"Building on Integer Partitions","title":"Attacking Problems Related to the Subset Sum Problem","text":"integer partition problem presents question “can write n sum positive integers?” well-known algorithms enumerating partitions integer n. even algorithms generating partitions specific length distinct parts . enumerate partitions n specific set numbers? enumerating partitions specific length m n given specific set numbers? example, using numbers 3:18, find partitions 50 length 5. RcppAlgos, easily achieved. simply use template Constraints Integer Partitions. Observe (continue use ht function defined Combination Permutation Basics vignette): fact, optimized algorithms can applied vector passed quality sort , difference element ’s neighbor constant (E.g. c(121, 126, 131, 136, ..., 221)).","code":"library(RcppAlgos) options(width = 90)  ht <- function(d, m = 5, n = m) {     ## print the head and tail together     cat(\"head -->\\n\")     print(head(d, m))     cat(\"--------\\n\")     cat(\"tail -->\\n\")     print(tail(d, n)) }  ## Each element can only occur once ht(partitionsGeneral(3:18, 5, target = 50)) #> head --> #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    3    4    8   17   18 #> [2,]    3    4    9   16   18 #> [3,]    3    4   10   15   18 #> [4,]    3    4   10   16   17 #> [5,]    3    4   11   14   18 #> -------- #> tail --> #>        [,1] [,2] [,3] [,4] [,5] #> [180,]    7    8    9   12   14 #> [181,]    7    8   10   11   14 #> [182,]    7    8   10   12   13 #> [183,]    7    9   10   11   13 #> [184,]    8    9   10   11   12  ## What about allowing repetition? ht(partitionsGeneral(3:18, 5, TRUE, target = 50)) #> head --> #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    3    3    8   18   18 #> [2,]    3    3    9   17   18 #> [3,]    3    3   10   16   18 #> [4,]    3    3   10   17   17 #> [5,]    3    3   11   15   18 #> -------- #> tail --> #>        [,1] [,2] [,3] [,4] [,5] #> [507,]    9    9    9   11   12 #> [508,]    9    9   10   10   12 #> [509,]    9    9   10   11   11 #> [510,]    9   10   10   10   11 #> [511,]   10   10   10   10   10  ## Even works on multisets ht(partitionsGeneral(3:18, 5, freqs = rep(1:4, 4), target = 50)) #> head --> #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    3    4    7   18   18 #> [2,]    3    4    8   17   18 #> [3,]    3    4    9   16   18 #> [4,]    3    4    9   17   17 #> [5,]    3    4   10   15   18 #> -------- #> tail --> #>        [,1] [,2] [,3] [,4] [,5] #> [401,]    8   10   10   10   12 #> [402,]    9    9    9   10   13 #> [403,]    9    9    9   11   12 #> [404,]    9    9   10   10   12 #> [405,]    9   10   10   10   11 even_time <- system.time({     genParts <- partitionsGeneral(seq(121, 221, 5), 13,                                   TRUE, target = 2613) }) even_time #>    user  system elapsed  #>   0.002   0.000   0.002  ht(genParts) #> head --> #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [1,]  121  121  161  221  221  221  221  221  221   221   221   221   221 #> [2,]  121  121  166  216  221  221  221  221  221   221   221   221   221 #> [3,]  121  121  171  211  221  221  221  221  221   221   221   221   221 #> [4,]  121  121  171  216  216  221  221  221  221   221   221   221   221 #> [5,]  121  121  176  206  221  221  221  221  221   221   221   221   221 #> -------- #> tail --> #>           [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [119542,]  196  196  196  201  201  201  201  201  201   201   206   206   206 #> [119543,]  196  196  201  201  201  201  201  201  201   201   201   201   211 #> [119544,]  196  196  201  201  201  201  201  201  201   201   201   206   206 #> [119545,]  196  201  201  201  201  201  201  201  201   201   201   201   206 #> [119546,]  201  201  201  201  201  201  201  201  201   201   201   201   201  prettyNum(comboCount(seq(121, 221, 5), 13, TRUE), big.mark = \",\") #> [1] \"573,166,440\"  system.time(genMultiParts <- partitionsGeneral(seq(121, 221, 5), 13,                                                freqs = rep(1:7, 3),                                                targe = 2613)) #>    user  system elapsed  #>   0.003   0.002   0.005  ht(genMultiParts) #> head --> #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [1,]  121  126  171  216  216  216  221  221  221   221   221   221   221 #> [2,]  121  126  176  211  216  216  221  221  221   221   221   221   221 #> [3,]  121  126  176  216  216  216  216  221  221   221   221   221   221 #> [4,]  121  126  181  206  216  216  221  221  221   221   221   221   221 #> [5,]  121  126  181  211  211  216  221  221  221   221   221   221   221 #> -------- #> tail --> #>          [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [70291,]  186  186  191  196  196  201  201  206  206   211   211   211   211 #> [70292,]  186  186  191  196  196  201  206  206  206   206   211   211   211 #> [70293,]  186  186  191  196  201  201  201  206  206   206   206   211   216 #> [70294,]  186  186  191  196  201  201  201  206  206   206   211   211   211 #> [70295,]  186  186  196  196  201  201  201  206  206   206   206   211   211  prettyNum(comboCount(seq(121, 221, 5), 13, freqs = rep(1:7, 3)), big.mark = \",\") #> [1] \"256,047,675\""},{"path":"https://jwood000.github.io/RcppAlgos/articles/SubsetSum.html","id":"working-with-negative-numbers","dir":"Articles","previous_headings":"Building on Integer Partitions","what":"Working with Negative Numbers","title":"Attacking Problems Related to the Subset Sum Problem","text":"Generally, integer partition algorithms restricted positive integers. However, generalized partition algorithms RcppAlgos, can make light work vectors negative numbers (, sorted vector property difference element ’s neighbor constant).","code":"system.time({     genDistParts <- partitionsGeneral(seq(-173L, 204L, 13L),                                       11, target = -460) }) #>    user  system elapsed  #>   0.001   0.000   0.002  all(rowSums(genDistParts) == -460L) #> [1] TRUE  ht(genDistParts) #> head --> #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #> [1,] -173 -160 -147 -134 -121 -108  -95  -82  165   191   204 #> [2,] -173 -160 -147 -134 -121 -108  -95  -69  152   191   204 #> [3,] -173 -160 -147 -134 -121 -108  -95  -69  165   178   204 #> [4,] -173 -160 -147 -134 -121 -108  -95  -56  139   191   204 #> [5,] -173 -160 -147 -134 -121 -108  -95  -56  152   178   204 #> -------- #> tail --> #>           [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #> [108940,] -121 -108  -82  -69  -56  -43  -30  -17   -4    22    48 #> [108941,] -121 -108  -82  -69  -56  -43  -30  -17    9    22    35 #> [108942,] -121  -95  -82  -69  -56  -43  -30  -17   -4     9    48 #> [108943,] -121  -95  -82  -69  -56  -43  -30  -17   -4    22    35 #> [108944,] -108  -95  -82  -69  -56  -43  -30  -17   -4     9    35"},{"path":"https://jwood000.github.io/RcppAlgos/articles/SubsetSum.html","id":"partitions-with-no-restrictions","dir":"Articles","previous_headings":"","what":"Partitions with no Restrictions","title":"Attacking Problems Related to the Subset Sum Problem","text":"examples illustrated , restriction sorted input vector property difference element ’s neighbor constant. requirement broken, means use particular algorithm must fall back general algorithm. Fret !! general algorithms extremely efficient flexible. can use random input vectors, random targets, well ranges. Let us revisit example slight variation breaks requirement. Although 26 times slower first example dealing 573 million combinations (0.053 milliseconds vs. 0.002 milliseconds), still dealing milliseconds!!! reference, version 2.3.4 takes 18 seconds find 118,560 solutions. exotic examples demonstrating power algorithms. function permuteGeneral benefits optimized algorithms well. However, just discussed Output Order permuteGeneral, output lexicographical order.","code":"inpVec <- c(116, seq(126, 221, 5))  ## Non-constant difference... The specialized algo can't be used diff(inpVec) #>  [1] 10  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  uneven_time <- system.time({     genParts2 <- partitionsGeneral(inpVec, 13, TRUE, target = 2613) }) uneven_time    ## out of a possible 573 million in under a second #>    user  system elapsed  #>   0.051   0.002   0.053  ht(genParts2) #> head --> #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [1,]  116  116  171  221  221  221  221  221  221   221   221   221   221 #> [2,]  116  116  176  216  221  221  221  221  221   221   221   221   221 #> [3,]  116  116  181  211  221  221  221  221  221   221   221   221   221 #> [4,]  116  116  181  216  216  221  221  221  221   221   221   221   221 #> [5,]  116  116  186  206  221  221  221  221  221   221   221   221   221 #> -------- #> tail --> #>           [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [118556,]  196  196  196  201  201  201  201  201  201   201   206   206   206 #> [118557,]  196  196  201  201  201  201  201  201  201   201   201   201   211 #> [118558,]  196  196  201  201  201  201  201  201  201   201   201   206   206 #> [118559,]  196  201  201  201  201  201  201  201  201   201   201   201   206 #> [118560,]  201  201  201  201  201  201  201  201  201   201   201   201   201 set.seed(42) mySamp <- sample(-100:100, 50)  sort(mySamp) #>  [1] -98 -97 -96 -95 -81 -77 -74 -65 -60 -59 -58 -54 -52 -43 -36 -33 -30 -27 -12  -9  -2 #> [22]  -1   3   8   9  10  13  21  27  30  33  35  42  45  49  52  53  57  61  63  64  70 #> [43]  73  76  83  84  88  91  96 100  system.time(exotic <- partitionsGeneral(mySamp, 8, freqs = rep(1:5, 10),                                         target = 496)) #>    user  system elapsed  #>   0.133   0.001   0.135  dim(exotic) #> [1] 102241      8  ## Over 1 billion total combinations prettyNum(comboCount(mySamp, 8, freqs = rep(1:5, 10)), big.mark = \",\") #> [1] \"1,343,133,680\"  ## Only getting a few (a thousand in this case) is much faster system.time(partitionsGeneral(mySamp, 8, freqs = rep(1:5, 10),                               target = 496, upper = 1e3)) #>    user  system elapsed  #>   0.002   0.000   0.002"},{"path":"https://jwood000.github.io/RcppAlgos/articles/SubsetSum.html","id":"taming-floating-point-numbers","dir":"Articles","previous_headings":"","what":"Taming Floating Point Numbers","title":"Attacking Problems Related to the Subset Sum Problem","text":"Oftentimes working numerical vectors, can hard find combinations sum particular number floating point errors (See Using tolerance). practice, may need exact match close approximation suffice. example, let’s say football team 100 players (including practice squad) interested trade involving 6 players total salary 20 million dollars. may able find 6 players whose sum salaries exactly 20 million, can find many 6 player combinations whose sum salaries within tolerance 20 million. increase tolerance $1000 (Honestly… ’s $1000 talking 20 million dollars)? intent explore options, take advantage upper argument anticipation obtain many results meet criteria. obtain upper bound, decrease tolerance (needed) repeat.","code":"set.seed(22213) football_player_salaries <- 2e7 * rbeta(100, 2, 25)  summary(football_player_salaries) #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #>   115308   768338  1261683  1612271  1950565 10895883  ## Over 1 billion combinations... ## An exhaustive search will not be feasible prettyNum(comboCount(football_player_salaries, 6), big.mark = \",\") #> [1] \"1,192,052,400\"  system.time(exactly20 <- partitionsGeneral(football_player_salaries, 6,                                            target = 2e7, tolerance = 0)) #>    user  system elapsed  #>   1.523   0.001   1.529  ## No results that equal exactly 2e7 dim(exactly20) #> [1] 0 6 ## N.B. This is much more efficient. Also, we set keepResults ## to TRUE so we can see the total sum of salaries. system.time(almost20 <- comboGeneral(football_player_salaries, 6,                                      constraintFun = \"sum\", comparisonFun = \"==\",                                      limitConstraints = 2e7, tolerance = 1000,                                      upper = 1000, keepResults = TRUE)) #>    user  system elapsed  #>   0.067   0.000   0.066  dim(almost20) #> [1] 1000    7  ht(almost20) #> head --> #>          [,1]     [,2]      [,3]    [,4]    [,5]     [,6]     [,7] #> [1,] 115307.7 152563.4  809407.9 3163109 4863446 10895883 19999717 #> [2,] 115307.7 152563.4 1590746.9 2381655 4863446 10895883 19999602 #> [3,] 115307.7 152563.4 1669898.9 2302265 4863446 10895883 19999365 #> [4,] 115307.7 152563.4 1746659.2 2225285 4863446 10895883 19999145 #> [5,] 115307.7 152563.4 1853727.8 2850338 4132545 10895883 20000364 #> -------- #> tail --> #>             [,1]     [,2]    [,3]    [,4]    [,5]     [,6]     [,7] #>  [996,] 200278.8 550414.4 1751652 2984500 3618110 10895883 20000838 #>  [997,] 200278.8 550414.4 1855829 3163109 3334046 10895883 19999560 #>  [998,] 200278.8 550414.4 1884764 2850338 3618110 10895883 19999788 #>  [999,] 200278.8 550414.4 2013884 2850338 3489156 10895883 19999953 #> [1000,] 200278.8 550414.4 2051845 2984500 3316996 10895883 19999917  ## decreasing the tolerance to $10 further we obtain 158 results system.time(superClose20 <- comboGeneral(football_player_salaries, 6,                                          constraintFun = \"sum\", comparisonFun = \"==\",                                          limitConstraints = 2e7, tolerance = 10,                                          upper = 1000, keepResults = TRUE)) #>    user  system elapsed  #>   1.518   0.001   1.522  ht(superClose20) #> head --> #>          [,1]      [,2]      [,3]    [,4]    [,5]     [,6]     [,7] #> [1,] 115307.7  266606.5  695657.2 3163109 4863446 10895883 20000009 #> [2,] 115307.7 1117835.0 1318811.6 1688714 4863446 10895883 19999998 #> [3,] 152563.4  628078.8 1117835.0 3334046 3871591 10895883 19999997 #> [4,] 152563.4  695657.2 1635144.3 2984500 3636247 10895883 19999995 #> [5,] 200278.8  765448.4 1174496.9 1923219 5040664 10895883 19999990 #> -------- #> tail --> #>           [,1]    [,2]    [,3]    [,4]    [,5]     [,6]     [,7] #> [154,] 1318812 1359188 1512157 1929459 2984500 10895883 19999997 #> [155,] 1318812 1371670 1771874 2225285 2416482 10895883 20000006 #> [156,] 1338303 1706514 1823915 1853728 2381655 10895883 19999998 #> [157,] 1371670 1512157 1516215 1853728 2850338 10895883 19999990 #> [158,] 1371670 1516215 1635144 2189663 2391419 10895883 19999994"},{"path":"https://jwood000.github.io/RcppAlgos/articles/SubsetSum.html","id":"prod-and-mean","dir":"Articles","previous_headings":"","what":"prod and mean","title":"Attacking Problems Related to the Subset Sum Problem","text":"optimized algorithms also employed constraintFun \"prod\" \"mean\".","code":"getAllThenFilter <- function(n, m, lim) {     t <- comboGeneral(n, m, constraintFun = \"prod\")     t[t[, m + 1] == lim, -(m+1)] }  library(microbenchmark) microbenchmark(optimized = comboGeneral(25, 10, constraintFun = \"prod\",                                         comparisonFun = \"==\",                                         limitConstraints = 1037836800),                brute = getAllThenFilter(25, 10, 1037836800), times = 20,                unit = \"relative\", check = \"equal\") #> Warning in microbenchmark(optimized = comboGeneral(25, 10, constraintFun = \"prod\", : less #> accurate nanosecond times to avoid potential integer overflows #> Unit: relative #>       expr      min       lq    mean   median       uq      max neval #>  optimized  1.00000  1.00000  1.0000  1.00000  1.00000  1.00000    20 #>      brute 21.05821 21.11253 21.5206 21.17071 20.90307 25.66376    20  ## What about cases when brute force isn't feasible set.seed(101) v <- runif(1000, 1, 2)  prettyNum(comboCount(v, 100), big.mark = \",\") #> [1] \"63,850,511,926,305,130,236,698,511,142,022,274,281,262,900,693,853,331,776,286,816,221,524,376,994,750,901,948,920,974,351,797,699,894,319,420,811,933,446,197,797,592,213,357,065,053,890\"  system.time(prodAlmost100 <- comboGeneral(v, 100, constraintFun = \"prod\",                                           comparisonFun = \"==\",                                           limitConstraints = 100,                                           tolerance = 0.0001, upper = 20)) #>    user  system elapsed  #>   0.016   0.000   0.016  dim(prodAlmost100) #> [1]  20 100  apply(prodAlmost100, 1, prod) #>  [1] 100.00008 100.00003 100.00003 100.00006 100.00010 100.00000  99.99993  99.99995 #>  [9] 100.00002  99.99992 100.00004  99.99994 100.00002 100.00005  99.99992  99.99996 #> [17] 100.00006 100.00003 100.00006 100.00002  ## Showcasing mean system.time(meanAlmost1.5 <- comboGeneral(v, 100, constraintFun = \"mean\",                                           comparisonFun = \"==\",                                           limitConstraints = 1.5,                                           tolerance = 0.0001, upper = 20)) #>    user  system elapsed  #>       0       0       0  dim(meanAlmost1.5) #> [1]  20 100  rowMeans(meanAlmost1.5) #>  [1] 1.500000 1.499999 1.500001 1.500000 1.500000 1.500001 1.500000 1.500000 1.500000 #> [10] 1.500000 1.499999 1.500000 1.500001 1.500001 1.499999 1.499999 1.500001 1.500000 #> [19] 1.500001 1.500000"},{"path":"https://jwood000.github.io/RcppAlgos/articles/SubsetSum.html","id":"using-iterators","dir":"Articles","previous_headings":"","what":"Using Iterators","title":"Attacking Problems Related to the Subset Sum Problem","text":"version 2.5.0 cases can attacked iterators (See Combinatorial Iterators RcppAlgos). mentioned suggested reading, iterators flexible just efficient “general” counterparts. added benefit allowing one save current state, allowing one generate n results time. demonstrations using examples earlier sections.","code":"## The football salary example salary <- partitionsIter(football_player_salaries, 6,                          target = 2e7, tolerance = 1000)  ## Or use comboIter: ## ## comboIter(football_player_salaries, 6, constraintFun = \"sum\", ##           comparisonFun = \"==\", limitConstraints = 2e7, ##           tolerance = 1000, upper = 1000, keepResults = TRUE))  system.time(almost20withIter <- salary@nextNIter(1e3)) #>    user  system elapsed  #>   0.066   0.000   0.066  ## almost20 was generated above with comboGeneral all.equal(almost20[, 1:6], almost20withIter) #> [1] TRUE  ## With iterators we can easily continue iterating. With the general ## functions if we wanted the next 1000 results, we would have to ## generate the first 1000 along with the next 1000 system.time(nextAlmost20withIter <- salary@nextNIter(1e3)) #>    user  system elapsed  #>   0.065   0.000   0.065  ht(nextAlmost20withIter) #> head --> #>          [,1]     [,2]      [,3]    [,4]    [,5]     [,6] #> [1,] 200278.8 550414.4 2189662.6 2829267 3334046 10895883 #> [2,] 200278.8 628078.8  653771.4 3489156 4132545 10895883 #> [3,] 200278.8 628078.8  809407.9 3334046 4132545 10895883 #> [4,] 200278.8 628078.8  852693.7 2381655 5040664 10895883 #> [5,] 200278.8 628078.8 1165478.3 3239395 3871591 10895883 #> -------- #> tail --> #>             [,1]   [,2]    [,3]    [,4]    [,5]     [,6] #>  [996,] 264972.3 663453 1318812 3239395 3618110 10895883 #>  [997,] 264972.3 663453 1376878 3163109 3636247 10895883 #>  [998,] 264972.3 663453 1688714 2850338 3636247 10895883 #>  [999,] 264972.3 663453 1706514 2850338 3618110 10895883 #> [1000,] 264972.3 663453 1853728 2189663 4132545 10895883  salary@summary() #> $description #> [1] \"Combinations of 100 choose 6 where the sum is between 19999000 and 20001000\" #>  #> $currentIndex #> [1] 2000 #>  #> $totalResults #> [1] NA #>  #> $totalRemaining #> [1] NA   ## The prodAlmost100 example prodIter <- comboIter(v, 100,                       constraintFun = \"prod\", comparisonFun = \"==\",                       limitConstraints = 100, tolerance = 0.0001)  system.time(prodAlmost100WithIter <- prodIter@nextNIter(20)) #>    user  system elapsed  #>   0.016   0.000   0.016  all.equal(prodAlmost100, prodAlmost100WithIter) #> [1] TRUE  ## Again, with iterators, we can continue iterating from ## where we left off system.time(nextAlmost100WithIter <- prodIter@nextNIter(20)) #>    user  system elapsed  #>   0.011   0.000   0.011  dim(nextAlmost100WithIter) #> [1]  20 100  ## Use @ or $ to access methods. If one needs to access these methods ## often (e.g. nextIter inside a loop), it is recommended to use the ## @ accessor as it is much more efficient. prodIter$summary() #> $description #> [1] \"Combinations of 1000 choose 100 where the prod is between 99.999899999999997 and 100.0001\" #>  #> $currentIndex #> [1] 40 #>  #> $totalResults #> [1] NA #>  #> $totalRemaining #> [1] NA"},{"path":"https://jwood000.github.io/RcppAlgos/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joseph Wood. Author, maintainer.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wood J (2026). RcppAlgos: High Performance Tools Combinatorics Computational Mathematics. RcppAlgos package version 2.9.5. https://jwood000.github.io/RcppAlgos/","code":"@Manual{,   title = {RcppAlgos: High Performance Tools for Combinatorics and Computational Mathematics},   author = {Joseph Wood},   year = {2026},   note = {RcppAlgos package version 2.9.5},   url = {https://jwood000.github.io/RcppAlgos/}, }"},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"rcppalgos-","dir":"","previous_headings":"","what":"High Performance Tools for Combinatorics and Computational Mathematics","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"collection high performance functions iterators implemented C++ solving problems combinatorics computational mathematics.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"featured-functions","dir":"","previous_headings":"","what":"Featured Functions","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"{combo|permute}General: Generate combinations/permutations vector (including multisets) meeting specific criteria. {partitions|compositions}General: Efficient algorithms partitioning numbers various constraints {expandGrid|comboGrid}: Generate traditional Cartesian product well product order matter. {combo|permute|partitions|compositions|expandGrid|comboGroups}Sample: Generate reproducible random samples {combo|permute|partitions|compositions|expandGrid|comboGroups}Iter: Flexible iterators allow bidirectional iteration well random access. primeSieve: Fast prime number generator primeCount: Prime counting function using Legendre’s formula primeSieve function primeCount function based excellent work Kim Walisch. respective repos can found : kimwalisch/primesieve; kimwalisch/primecount Additionally, many sieving functions make use fast integer division library libdivide ridiculousfish.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"benchmarks","dir":"","previous_headings":"","what":"Benchmarks","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"High Performance Benchmarks","code":""},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"","code":"install.packages(\"RcppAlgos\")  ## install the development version devtools::install_github(\"jwood000/RcppAlgos\")"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"combinatorics-basics","dir":"","previous_headings":"Usage","what":"Combinatorics Basics","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"","code":"## Find all 3-tuples combinations of 1:4 comboGeneral(4, 3) #>      [,1] [,2] [,3] #> [1,]   1    2    3 #> [2,]   1    2    4 #> [3,]   1    3    4 #> [4,]   2    3    4   ## Alternatively, iterate over combinations a = comboIter(4, 3) a@nextIter() #> [1] 1 2 3  a@back() #> [1] 2 3 4  a[[2]] #> [1] 1 2 4   ## Pass any atomic type vector permuteGeneral(letters, 3, upper = 4) #>      [,1] [,2] [,3] #> [1,] \"a\"  \"b\"  \"c\" #> [2,] \"a\"  \"b\"  \"d\" #> [3,] \"a\"  \"b\"  \"e\" #> [4,] \"a\"  \"b\"  \"f\"   ## Generate a reproducible sample comboSample(10, 8, TRUE, n = 5, seed = 84) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    3    3    3    6    6   10   10   10 #> [2,]    1    3    3    4    4    7    9   10 #> [3,]    3    7    7    7    9   10   10   10 #> [4,]    3    3    3    9   10   10   10   10 #> [5,]    1    2    2    3    3    4    4    7"},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"integer-partitions-and-constraints","dir":"","previous_headings":"Usage","what":"Integer Partitions and Constraints","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"","code":"## Flexible partitioning algorithms partitionsGeneral(0:5, 3, freqs = rep(1:2, 3), target = 6) #>      [,1] [,2] [,3] #> [1,]    0    1    5 #> [2,]    0    2    4 #> [3,]    0    3    3 #> [4,]    1    1    4 #> [5,]    1    2    3   ## And compositions compositionsGeneral(0:3, repetition = TRUE) #>      [,1] [,2] [,3] #> [1,]    0    0    3 #> [2,]    0    1    2 #> [3,]    0    2    1 #> [4,]    1    1    1   ## Get combinations such that the product is between ## 3600 and 4000 (including 3600 but not 4000) comboGeneral(5, 7, TRUE, constraintFun = \"prod\",              comparisonFun = c(\">=\",\"<\"),              limitConstraints = c(3600, 4000),              keepResults = TRUE) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    2    3    5    5    5    5 3750 #> [2,]    1    3    3    4    4    5    5 3600 #> [3,]    1    3    4    4    4    4    5 3840 #> [4,]    2    2    3    3    4    5    5 3600 #> [5,]    2    2    3    4    4    4    5 3840 #> [6,]    3    3    3    3    3    3    5 3645 #> [7,]    3    3    3    3    3    4    4 3888   ## We can even iterate over constrained cases. These are ## great when we don't know how many results there are upfront. ## Save on memory and still at the speed of C++!! p = permuteIter(5, 7, TRUE, constraintFun = \"prod\",                 comparisonFun = c(\">=\",\"<\"),                 limitConstraints = c(3600, 4000),                 keepResults = TRUE)  ## Get the next n results t = p@nextNIter(1048)  ## N.B. keepResults = TRUE adds the 8th column tail(t) #>         [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1043,]    5    4    4    3    4    1    4 3840 #> [1044,]    5    4    4    3    4    4    1 3840 #> [1045,]    5    4    4    4    1    3    4 3840 #> [1046,]    5    4    4    4    1    4    3 3840 #> [1047,]    5    4    4    4    3    1    4 3840 #> [1048,]    5    4    4    4    3    4    1 3840  ## Continue iterating from where we left off p@nextIter() #> [1]    5    4    4    4    4    1    3 3840  p@nextIter() #> [1]    5    4    4    4    4    3    1 3840  p@nextIter() #> [1]    2    2    3    3    4    5    5 3600  ## N.B. totalResults and totalRemaining are NA because there is no ## closed form solution for determining this. p@summary() #> $description #> [1] \"Permutations with repetition of 5 choose 7 where the prod is between 3600 and 4000\" #>  #> $currentIndex #> [1] 1051 #>  #> $totalResults #> [1] NA #>  #> $totalRemaining #> [1] NA"},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"cartesian-products","dir":"","previous_headings":"Usage","what":"Cartesian Products","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"","code":"## Base R expand.grid returns a data.frame by default ## and varies the first column the fastest bR = expand.grid(rep(list(1:3), 3)) head(bR, n = 3) #>   Var1 Var2 Var3 #> 1    1    1    1 #> 2    2    1    1 #> 3    3    1    1  tail(bR, n = 3) #>    Var1 Var2 Var3 #> 25    1    3    3 #> 26    2    3    3 #> 27    3    3    3   ## RcppAlgos::expandGrid returns a matrix if the input is of ## the same class, otherwise it returns a data.frame. Also ## varies the first column the slowest. algos = expandGrid(rep(list(1:3), 3)) head(algos, n = 3) #>      Var1 Var2 Var3 #> [1,]    1    1    1 #> [2,]    1    1    2 #> [3,]    1    1    3  tail(algos, n = 3) #>       Var1 Var2 Var3 #> [25,]    3    3    1 #> [26,]    3    3    2 #> [27,]    3    3    3   ## N.B. Since we are passing more than one type, a data.frame is returned expandGrid(     c(rep(list(letters[1:3]), 3), list(1:3)),     upper = 3 ) #>   Var1 Var2 Var3 Var4 #> 1    a    a    a    1 #> 2    a    a    a    2 #> 3    a    a    a    3   ## With RcppAlgos::comboGrid order doesn't matter, so c(1, 1, 2), ## c(1, 2, 1), and c(2, 1, 1) are the same. comboGrid(rep(list(1:3), 3)) #>       Var1 Var2 Var3 #>  [1,]    1    1    1 #>  [2,]    1    1    2 #>  [3,]    1    1    3 #>  [4,]    1    2    2 #>  [5,]    1    2    3 #>  [6,]    1    3    3 #>  [7,]    2    2    2 #>  [8,]    2    2    3 #>  [9,]    2    3    3 #> [10,]    3    3    3   ## If you don't want any repeats, set repetition = FALSE comboGrid(rep(list(1:3), 3), repetition = FALSE) #>      Var1 Var2 Var3 #> [1,]    1    2    3"},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"partitions-of-groups","dir":"","previous_headings":"Usage","what":"Partitions of Groups","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"Efficiently partition vector groups comboGroups. example, code finds possible pairings groups size 3 vs groups size 2 (See stackoverflow post: Find possible team pairing schemes).","code":"players <- c(\"Ross\", \"Bobby\", \"Max\", \"Casper\", \"Jake\") comboGroups(players, grpSizes = c(2, 3)) #>       Grp1     Grp1     Grp2    Grp2     Grp2     #>  [1,] \"Ross\"   \"Bobby\"  \"Max\"   \"Casper\" \"Jake\"   #>  [2,] \"Ross\"   \"Max\"    \"Bobby\" \"Casper\" \"Jake\"   #>  [3,] \"Ross\"   \"Casper\" \"Bobby\" \"Max\"    \"Jake\"   #>  [4,] \"Ross\"   \"Jake\"   \"Bobby\" \"Max\"    \"Casper\" #>  [5,] \"Bobby\"  \"Max\"    \"Ross\"  \"Casper\" \"Jake\"   #>  [6,] \"Bobby\"  \"Casper\" \"Ross\"  \"Max\"    \"Jake\"   #>  [7,] \"Bobby\"  \"Jake\"   \"Ross\"  \"Max\"    \"Casper\" #>  [8,] \"Max\"    \"Casper\" \"Ross\"  \"Bobby\"  \"Jake\"   #>  [9,] \"Max\"    \"Jake\"   \"Ross\"  \"Bobby\"  \"Casper\" #> [10,] \"Casper\" \"Jake\"   \"Ross\"  \"Bobby\"  \"Max\""},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"computational-mathematics","dir":"","previous_headings":"Usage","what":"Computational Mathematics","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"","code":"## Generate prime numbers primeSieve(50) #> [1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47  ## Many of the functions can produce results in ## parallel for even greater performance p = primeSieve(1e15, 1e15 + 1e8, nThreads = 4)  head(p) #> [1] 1000000000000037 1000000000000091 1000000000000159 #> [4] 1000000000000187 1000000000000223 1000000000000241 tail(p) #> [1] 1000000099999847 1000000099999867 1000000099999907 #> [4] 1000000099999919 1000000099999931 1000000099999963   ## Count prime numbers less than n primeCount(1e10) #> [1] 455052511  ## Get the prime factorization set.seed(24028) primeFactorize(sample(1e15, 3), namedList = TRUE) #> $`701030825091514` #> [1]             2           149 2352452433193 #>  #> $`83054168594779` #> [1]  3098071 26808349 #>  #> $`397803024735610` #> [1]            2            5           13           13 235386405169"},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"further-reading","dir":"","previous_headings":"","what":"Further Reading","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"Function Documentation Computational Mathematics Overview Combination Permutation Basics Combinatorial Sampling Constraints, Partitions, Compositions Attacking Problems Related Subset Sum Problem Combinatorial Iterators RcppAlgos Cartesian Products Partitions Groups","code":""},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"why-rcppalgos-but-no-rcpp","dir":"","previous_headings":"","what":"Why RcppAlgos but no Rcpp?","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"Previous versions RcppAlgos relied Rcpp ease burden exposing C++ R. current version RcppAlgos utilize Rcpp, possible without myriad excellent contributions Rcpp.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"High Performance Tools for Combinatorics and Computational Mathematics","text":"like report bug, question, suggestions possible improvements, please file issue.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Cartesian-Class.html","id":null,"dir":"Reference","previous_headings":"","what":"S4-class for Exposing C++ Cartesian Class — Cartesian-class","title":"S4-class for Exposing C++ Cartesian Class — Cartesian-class","text":"Cartesian class S4-class exposes C++ classes provide access iterators useful methods.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Cartesian-Class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"S4-class for Exposing C++ Cartesian Class — Cartesian-class","text":"nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result randomAccess Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Cartesian-Class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"S4-class for Exposing C++ Cartesian Class — Cartesian-class","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/Cartesian-Class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S4-class for Exposing C++ Cartesian Class — Cartesian-class","text":"","code":"showClass(\"Cartesian\") #> Class \"Cartesian\" [package \"RcppAlgos\"] #>  #> Slots: #>                                                                              #> Name:            ptr     startOver      nextIter     nextNIter nextRemaining #> Class:   externalptr      function      function      function      function #>                                                                              #> Name:       currIter  randomAccess  sourceVector         front          back #> Class:      function      function      function      function      function #>                      #> Name:        summary #> Class:      function"},{"path":"https://jwood000.github.io/RcppAlgos/reference/Combo-Class.html","id":null,"dir":"Reference","previous_headings":"","what":"S4-classes for Exposing C++ Combinatorial Classes — Combo-class","title":"S4-classes for Exposing C++ Combinatorial Classes — Combo-class","text":"Combo class family S4-classes expose C++ classes provide access iterators useful methods.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Combo-Class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"S4-classes for Exposing C++ Combinatorial Classes — Combo-class","text":"\"Combo\" classes inheriting : nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration prevIter Retrieve previous lexicographical result (next reverse lexicographical result) prevNIter Pass integer n retrieve previous n lexicographical results (next n reverse lexicographical results) prevRemaining Retrieve remaining reverse lexicographical results startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result randomAccess Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Combo-Class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"S4-classes for Exposing C++ Combinatorial Classes — Combo-class","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/Combo-Class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S4-classes for Exposing C++ Combinatorial Classes — Combo-class","text":"","code":"showClass(\"Combo\") #> Class \"Combo\" [package \"RcppAlgos\"] #>  #> Slots: #>                                                                              #> Name:            ptr     startOver      nextIter     nextNIter nextRemaining #> Class:   externalptr      function      function      function      function #>                                                                              #> Name:       prevIter     prevNIter prevRemaining      currIter  randomAccess #> Class:      function      function      function      function      function #>                                                                #> Name:   sourceVector         front          back       summary #> Class:      function      function      function      function #>  #> Known Subclasses: \"ComboApply\", \"ComboRes\""},{"path":"https://jwood000.github.io/RcppAlgos/reference/ComboGroups-Class.html","id":null,"dir":"Reference","previous_headings":"","what":"S4-class for Exposing C++ ComboGroups Class — ComboGroups-class","title":"S4-class for Exposing C++ ComboGroups Class — ComboGroups-class","text":"ComboGroups class S4-class exposes C++ classes provide access iterators useful methods.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/ComboGroups-Class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"S4-class for Exposing C++ ComboGroups Class — ComboGroups-class","text":"nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result randomAccess Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/ComboGroups-Class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"S4-class for Exposing C++ ComboGroups Class — ComboGroups-class","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/ComboGroups-Class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S4-class for Exposing C++ ComboGroups Class — ComboGroups-class","text":"","code":"showClass(\"ComboGroups\") #> Class \"ComboGroups\" [package \"RcppAlgos\"] #>  #> Slots: #>                                                                              #> Name:            ptr     startOver      nextIter     nextNIter nextRemaining #> Class:   externalptr      function      function      function      function #>                                                                              #> Name:       currIter  randomAccess  sourceVector         front          back #> Class:      function      function      function      function      function #>                      #> Name:        summary #> Class:      function"},{"path":"https://jwood000.github.io/RcppAlgos/reference/Constraints-Class.html","id":null,"dir":"Reference","previous_headings":"","what":"S4-class for Exposing C++ Constraints Class — Constraints-class","title":"S4-class for Exposing C++ Constraints Class — Constraints-class","text":"Constraints class S4-class exposes C++ classes provide access iterators useful methods.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Constraints-Class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"S4-class for Exposing C++ Constraints Class — Constraints-class","text":"nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Constraints-Class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"S4-class for Exposing C++ Constraints Class — Constraints-class","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/Constraints-Class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S4-class for Exposing C++ Constraints Class — Constraints-class","text":"","code":"showClass(\"Constraints\") #> Class \"Constraints\" [package \"RcppAlgos\"] #>  #> Slots: #>                                                                              #> Name:            ptr     startOver      nextIter     nextNIter nextRemaining #> Class:   externalptr      function      function      function      function #>                                                  #> Name:       currIter  sourceVector       summary #> Class:      function      function      function"},{"path":"https://jwood000.github.io/RcppAlgos/reference/Partitions-Class.html","id":null,"dir":"Reference","previous_headings":"","what":"S4-class for Exposing C++ Partitions Class — Partitions-class","title":"S4-class for Exposing C++ Partitions Class — Partitions-class","text":"Partitions class S4-class exposes C++ classes provide access iterators useful methods.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Partitions-Class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"S4-class for Exposing C++ Partitions Class — Partitions-class","text":"nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result randomAccess Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/Partitions-Class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"S4-class for Exposing C++ Partitions Class — Partitions-class","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/Partitions-Class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S4-class for Exposing C++ Partitions Class — Partitions-class","text":"","code":"showClass(\"Partitions\") #> Class \"Partitions\" [package \"RcppAlgos\"] #>  #> Slots: #>                                                                              #> Name:            ptr     startOver      nextIter     nextNIter nextRemaining #> Class:   externalptr      function      function      function      function #>                                                                              #> Name:       currIter  randomAccess  sourceVector         front          back #> Class:      function      function      function      function      function #>                      #> Name:        summary #> Class:      function"},{"path":"https://jwood000.github.io/RcppAlgos/reference/RcppAlgos-package.html","id":null,"dir":"Reference","previous_headings":"","what":"High Performance Tools for Combinatorics and Computational Mathematics — RcppAlgos-package","title":"High Performance Tools for Combinatorics and Computational Mathematics — RcppAlgos-package","text":"RcppAlgos package attacks age-old problems combinatorics computational mathematics.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/RcppAlgos-package.html","id":"goals","dir":"Reference","previous_headings":"","what":"Goals","title":"High Performance Tools for Combinatorics and Computational Mathematics — RcppAlgos-package","text":"main goal encourage fresh creative approaches foundational problems. question appropriately summarizes RcppAlgos : \"Can better?\". Provide highly optimized functions facilitates broader spectrum researchable cases. E.g Investigating structure large numbers wide ranges: primeFactorizeSieve(10^13 - 10^7, 10^13 + 10^7) primeSieve(2^53 - 10^10, 2^53 - 1, nThreads = 32) Easily explore combinations/permutations/partitions otherwise inaccessible due time execution/memory constraints:   comboGeneral(150, 5, constraintFun = \"sum\", Parallel = TRUE)   permuteSample(rnorm(100), 10, freqs = rep(1:4, 25), n = 15, seed = 123)  Speed!!!.... find functions RcppAlgos fastest type available R.","code":"c_iter = comboIter(10000, 100) bigSamp = gmp::urand.bigz(3, gmp::log2.bigz(comboCount(10000, 100))) c_iter[[bigSamp]] ## flexible iterator allows random sampling p_iter = partitionsIter(5000, 100, target = 6000) p_iter[[1e9]] ## start iterating from index = 1e9 p_iter@nextIter() p_iter@nextNIter(1e3) parallel::mclapply(seq(...), function(x) {             temp = permuteGeneral(15, 10, lower = x, upper = y)             ## analyze permutations             ## output results     }, mc.cores = detectCores() - 1)) partitionsGeneral(0:80, repetition = TRUE) set.seed(123) comboGeneral(runif(42, 0, 50), 10,              constraintFun = \"mean\",              comparisonFun = c(\">\",\"<\"),              limitConstraints = c(39.876, 42.123))"},{"path":"https://jwood000.github.io/RcppAlgos/reference/RcppAlgos-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"High Performance Tools for Combinatorics and Computational Mathematics — RcppAlgos-package","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsCount.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of combinations/permutations — comboCount","title":"Number of combinations/permutations — comboCount","text":"Calculate number combinations/permutations vector chosen \\(m\\) time without replacement. Additionally, functions can calculate number combinations/permutations multisets.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsCount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of combinations/permutations — comboCount","text":"","code":"comboCount(v, m = NULL, ...) permuteCount(v, m = NULL, ...)  # Default S3 method comboCount(v, m = NULL, repetition = FALSE, freqs = NULL, ...) # Default S3 method permuteCount(v, m = NULL, repetition = FALSE, freqs = NULL, ...)  # S3 method for class 'table' comboCount(v, m = NULL, ...) # S3 method for class 'table' permuteCount(v, m = NULL, ...)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsCount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of combinations/permutations — comboCount","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). m Number elements choose.  repetition = TRUE freqs utilized, m can exceed length v. m = NULL, length default length(v) sum(freqs). ... arguments passed methods. repetition Logical value indicating whether combinations/permutations without repetition. default FALSE. freqs vector frequencies used producing combinations/permutations multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsCount.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of combinations/permutations — comboCount","text":"numerical value representing total number combinations/permutations.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsCount.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Number of combinations/permutations — comboCount","text":"number results exceeds \\(2^{53} - 1\\), number class bigz returned.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsCount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of combinations/permutations — comboCount","text":"","code":"## Same interface as the respective \"general\" functions: ## i.e. comboGeneral & permuteGeneral  permuteCount(-5) #> [1] 120 permuteCount(5) #> [1] 120 comboCount(25, 12) #> [1] 5200300 permuteCount(15, 7, TRUE) #> [1] 170859375 comboCount(25, 12, freqs = rep(2, 25)) #> [1] 458917850  ## Return object of class 'bigz' comboCount(250, 15, freqs = rep(2, 250)) #> Big Integer ('bigz') : #> [1] 1035444613157684247678300"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"Generate combinations permutations vector without constraints. Produce results parallel using Parallel nThreads arguments. can also apply five compiled functions given argument constraintFun parallel. arguments lower upper make possible generate combinations/permutations chunks allowing parallelization via parallel-package. convenient want apply custom function output parallel. Attack integer partition general subset sum problems. GMP support allows exploration combinations/permutations vectors many elements. output lexicographical order.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"","code":"comboGeneral(v, m = NULL, ...) permuteGeneral(v, m = NULL, ...)  # S3 method for class 'numeric' comboGeneral(v, m = NULL, repetition = FALSE, freqs = NULL,              lower = NULL, upper = NULL, constraintFun = NULL,              comparisonFun = NULL, limitConstraints = NULL,              keepResults = NULL, FUN = NULL, Parallel = FALSE,              nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...)  # S3 method for class 'numeric' permuteGeneral(v, m = NULL, repetition = FALSE, freqs = NULL,                lower = NULL, upper = NULL, constraintFun = NULL,                comparisonFun = NULL, limitConstraints = NULL,                keepResults = NULL, FUN = NULL, Parallel = FALSE,                nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...)  # S3 method for class 'factor' comboGeneral(     v, m = NULL, repetition = FALSE, freqs = NULL, lower = NULL, upper = NULL,     FUN = NULL, Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ... ) # S3 method for class 'factor' permuteGeneral(     v, m = NULL, repetition = FALSE, freqs = NULL, lower = NULL, upper = NULL,     FUN = NULL, Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ... )  # Default S3 method comboGeneral(v, m = NULL, repetition = FALSE,              freqs = NULL, lower = NULL, upper = NULL,              FUN = NULL, FUN.VALUE = NULL, ...) # Default S3 method permuteGeneral(v, m = NULL, repetition = FALSE,                freqs = NULL, lower = NULL, upper = NULL,                FUN = NULL, FUN.VALUE = NULL, ...)  # S3 method for class 'table' comboGeneral(     v, m = NULL, lower = NULL, upper = NULL, constraintFun = NULL,     comparisonFun = NULL, limitConstraints = NULL, keepResults = NULL,     FUN = NULL, Parallel = FALSE, nThreads = NULL, tolerance = NULL,     FUN.VALUE = NULL, ... ) # S3 method for class 'table' permuteGeneral(     v, m = NULL, lower = NULL, upper = NULL, constraintFun = NULL,     comparisonFun = NULL, limitConstraints = NULL, keepResults = NULL,     FUN = NULL, Parallel = FALSE, nThreads = NULL, tolerance = NULL,     FUN.VALUE = NULL, ... )  # S3 method for class 'list' comboGeneral(v, m = NULL, repetition = FALSE,              freqs = NULL, lower = NULL, upper = NULL, ...) # S3 method for class 'list' permuteGeneral(v, m = NULL, repetition = FALSE,                freqs = NULL, lower = NULL, upper = NULL, ...)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). m Number elements choose.  repetition = TRUE freqs utilized, m can exceed length v. m = NULL, length default length(v) sum(freqs). ... arguments passed methods. repetition Logical value indicating whether combinations/permutations without repetition. default FALSE. freqs vector frequencies used producing combinations/permutations multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. lower lower bound. Combinations/permutations generated lexicographically, thus utilizing argument determine specific combination/permutation start generating (e.g. comboGeneral(5, 3, lower = 6) equivalent comboGeneral(5, 3)[6:choose(5, 3), ]). argument along upper useful generating combinations/permutations chunks allowing easy parallelization. upper upper bound. Similar lower, however parameter allows user stop generation specific combination/permutation (e.g. comboGeneral(5, 3, upper = 5) equivalent comboGeneral(5, 3)[1:5, ]) output constrained lower supplied, upper serves cap many results returned meet criteria (e.g. setting upper = 100 alone return first 100 results meet criteria, setting lower = 1 upper = 100 test first 100 results criteria). addition benefits listed lower, parameter useful total number combinations/permutations without constraint large expect/need small number combinations/permutations meet certain criteria. Using upper can improve run time used judiciously call member function reserve std::vector. See examples . constraintFun Function applied elements v passed string (e.g. constraintFun = \"sum\"). possible constraint functions : \"sum\", \"prod\", \"mean\", \"max\", & \"min\". default NULL, meaning function applied. comparisonFun Comparison operator used compare limitConstraints result constraintFun applied v. passed string vector two strings (e.g. comparisonFun = \"<=\"  comparisonFun = c(\">\",\"<\")). possible comparison operators : \"<\", \">\", \"<=\", \">=\", \"==\". default NULL. comparisonFun vector two comparison strings, e.g comparisonFun = c(comp1, comp2), limitConstraints vector two numerical values, e.g limitConstraints = c(x1, x2), combinations/permutations filtered one following two ways: comp1 one 'greater-' operators (.e. \">=\" \">\"), comp2 one 'less-' operators (.e. \"<=\" \"<\"), x1 < x2, combinations/permutations returned value (constraintFun applied) x1 x2. comp1 comp2 defined #1 x1 > x2, combinations/permutations returned value outside range x1 x2. See examples . words, first comparison operator applied first limit second operator applied second limit. limitConstraints value(s) used comparison. Can passed single value vector two numerical values. default NULL. See definition comparisonFun well examples information. keepResults logical flag indicating result constraintFun applied v displayed; TRUE, additional column results added resulting matrix. default FALSE. user applying constraintFun, keepResults default TRUE. E.g. following equivalent produce \\(4^{th}\\) column row sums: comboGeneral(5, 3 constraintFun = \"sum\", keepResults = TRUE) comboGeneral(5, 3 constraintFun = \"sum\")  FUN Function applied combination/permutation. default NULL. Parallel Logical value indicating whether combinations/permutations generated parallel using \\(n - 1\\) threads, \\(n\\) maximum number threads. default FALSE. nThreads NULL, given preference (e.g. user 8 threads Parallel = TRUE nThreads = 4, 4 threads spawned). system single-threaded, arguments Parallel nThreads ignored. nThreads Specific number threads used. default NULL. See Parallel. tolerance numeric value greater equal zero. parameter utilized constraint applied numeric vector. default value 0 can determined whole values utilized, otherwise sqrt(.Machine$double.eps) approximately \\(1.5e-8\\). N.B. input vector type integer, parameter ignored strict equality enforced. FUN.VALUE template return value FUN. See 'Details' vapply information.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"general, matrix \\(m\\) \\(m + 1\\) columns, depending value keepResults FUN utilized FUN.VALUE = NULL, list returned FUN FUN.VALUE NULL, return modeled return vapply. See 'Value' section vapply.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"general case, finding combinations/permutations constraints optimized organizing way constraintFun applied, partially monotonic sequence produced. Combinations/permutations added successively, particular combination exceeds given constraint value given constraint/comparison function combo. point, can safely skip several combinations knowing exceed given constraint value. special cases efficient algorithms dyncamically deployed. cases center around subject integer partitions. See partitionsGeneral information. negative values v constraintFun = \"prod\", producing monotonic set non-trivial general case. result, performance suffer combinations/permutations must tested constraint criteria.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"Parallel nThreads ignored following cases: output constrained (except partitions cases) class vector passed character, raw, complex (N.B. Rcpp::CharacterMatrix thread safe). Alternatively, can generate indexing matrix parallel. FUN utilized. either constraintFun, comparisonFun limitConstraints NULL –– class vector passed logical, character, raw, factor, complex, constraint check carried . equivalent simply finding combinations/permutations \\(v\\) choose \\(m\\). maximum number combinations/permutations can generated one time \\(2^{31} - 1\\). Utilizing lower upper makes possible generate additional combinations/permutations. Factor vectors accepted. Class level attributes preserved except FUN used. Lexicographical ordering guaranteed permutations lower supplied output constrained. lower supplied output constrained, combinations/permutations tested lexicographical range lower upper total possible number results upper given. See second paragraph definition upper. FUN ignored constraint check satisfied.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"Passing user-supplied C++ functions Monotonic Sequence Multiset Lexicographical Order Subset Sum Problem Partition (Number Theory)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsGeneral.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Combinations and Permutations of a Vector with/without Constraints — comboGeneral","text":"","code":"comboGeneral(4, 3) #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    1    2    4 #> [3,]    1    3    4 #> [4,]    2    3    4 permuteGeneral(3) #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    1    3    2 #> [3,]    2    1    3 #> [4,]    2    3    1 #> [5,]    3    1    2 #> [6,]    3    2    1  permuteGeneral(factor(letters[1:3]), repetition = TRUE) #>       [,1] [,2] [,3] #>  [1,] a    a    a    #>  [2,] a    a    b    #>  [3,] a    a    c    #>  [4,] a    b    a    #>  [5,] a    b    b    #>  [6,] a    b    c    #>  [7,] a    c    a    #>  [8,] a    c    b    #>  [9,] a    c    c    #> [10,] b    a    a    #> [11,] b    a    b    #> [12,] b    a    c    #> [13,] b    b    a    #> [14,] b    b    b    #> [15,] b    b    c    #> [16,] b    c    a    #> [17,] b    c    b    #> [18,] b    c    c    #> [19,] c    a    a    #> [20,] c    a    b    #> [21,] c    a    c    #> [22,] c    b    a    #> [23,] c    b    b    #> [24,] c    b    c    #> [25,] c    c    a    #> [26,] c    c    b    #> [27,] c    c    c    #> Levels: a b c  ## permutations of the multiset : ## c(1,1,1,2,2,3) permuteGeneral(table(c(1,1,1,2,2,3))) #>       [,1] [,2] [,3] [,4] [,5] [,6] #>  [1,]    1    1    1    2    2    3 #>  [2,]    1    1    1    2    3    2 #>  [3,]    1    1    1    3    2    2 #>  [4,]    1    1    2    1    2    3 #>  [5,]    1    1    2    1    3    2 #>  [6,]    1    1    2    2    1    3 #>  [7,]    1    1    2    2    3    1 #>  [8,]    1    1    2    3    1    2 #>  [9,]    1    1    2    3    2    1 #> [10,]    1    1    3    1    2    2 #> [11,]    1    1    3    2    1    2 #> [12,]    1    1    3    2    2    1 #> [13,]    1    2    1    1    2    3 #> [14,]    1    2    1    1    3    2 #> [15,]    1    2    1    2    1    3 #> [16,]    1    2    1    2    3    1 #> [17,]    1    2    1    3    1    2 #> [18,]    1    2    1    3    2    1 #> [19,]    1    2    2    1    1    3 #> [20,]    1    2    2    1    3    1 #> [21,]    1    2    2    3    1    1 #> [22,]    1    2    3    1    1    2 #> [23,]    1    2    3    1    2    1 #> [24,]    1    2    3    2    1    1 #> [25,]    1    3    1    1    2    2 #> [26,]    1    3    1    2    1    2 #> [27,]    1    3    1    2    2    1 #> [28,]    1    3    2    1    1    2 #> [29,]    1    3    2    1    2    1 #> [30,]    1    3    2    2    1    1 #> [31,]    2    1    1    1    2    3 #> [32,]    2    1    1    1    3    2 #> [33,]    2    1    1    2    1    3 #> [34,]    2    1    1    2    3    1 #> [35,]    2    1    1    3    1    2 #> [36,]    2    1    1    3    2    1 #> [37,]    2    1    2    1    1    3 #> [38,]    2    1    2    1    3    1 #> [39,]    2    1    2    3    1    1 #> [40,]    2    1    3    1    1    2 #> [41,]    2    1    3    1    2    1 #> [42,]    2    1    3    2    1    1 #> [43,]    2    2    1    1    1    3 #> [44,]    2    2    1    1    3    1 #> [45,]    2    2    1    3    1    1 #> [46,]    2    2    3    1    1    1 #> [47,]    2    3    1    1    1    2 #> [48,]    2    3    1    1    2    1 #> [49,]    2    3    1    2    1    1 #> [50,]    2    3    2    1    1    1 #> [51,]    3    1    1    1    2    2 #> [52,]    3    1    1    2    1    2 #> [53,]    3    1    1    2    2    1 #> [54,]    3    1    2    1    1    2 #> [55,]    3    1    2    1    2    1 #> [56,]    3    1    2    2    1    1 #> [57,]    3    2    1    1    1    2 #> [58,]    3    2    1    1    2    1 #> [59,]    3    2    1    2    1    1 #> [60,]    3    2    2    1    1    1  ## Example with list comboGeneral(     v = list(         p1 = matrix(1:10, ncol = 2),         p2 = data.frame(a = letters, b = 1:26),         p3 = as.complex(1:10)     ),     m = 2 ) #> [[1]] #> [[1]]$p1 #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #>  #> [[1]]$p2 #>    a  b #> 1  a  1 #> 2  b  2 #> 3  c  3 #> 4  d  4 #> 5  e  5 #> 6  f  6 #> 7  g  7 #> 8  h  8 #> 9  i  9 #> 10 j 10 #> 11 k 11 #> 12 l 12 #> 13 m 13 #> 14 n 14 #> 15 o 15 #> 16 p 16 #> 17 q 17 #> 18 r 18 #> 19 s 19 #> 20 t 20 #> 21 u 21 #> 22 v 22 #> 23 w 23 #> 24 x 24 #> 25 y 25 #> 26 z 26 #>  #>  #> [[2]] #> [[2]]$p1 #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #>  #> [[2]]$p3 #>  [1]  1+0i  2+0i  3+0i  4+0i  5+0i  6+0i  7+0i  8+0i  9+0i 10+0i #>  #>  #> [[3]] #> [[3]]$p2 #>    a  b #> 1  a  1 #> 2  b  2 #> 3  c  3 #> 4  d  4 #> 5  e  5 #> 6  f  6 #> 7  g  7 #> 8  h  8 #> 9  i  9 #> 10 j 10 #> 11 k 11 #> 12 l 12 #> 13 m 13 #> 14 n 14 #> 15 o 15 #> 16 p 16 #> 17 q 17 #> 18 r 18 #> 19 s 19 #> 20 t 20 #> 21 u 21 #> 22 v 22 #> 23 w 23 #> 24 x 24 #> 25 y 25 #> 26 z 26 #>  #> [[3]]$p3 #>  [1]  1+0i  2+0i  3+0i  4+0i  5+0i  6+0i  7+0i  8+0i  9+0i 10+0i #>  #>   #### Examples using \"upper\" and \"lower\": ## See specific range of permutations permuteGeneral(75, 10, freqs = rep(1:3, 25),                lower = 1e12, upper = 1e12 + 10) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    1    2    2   10   22   18   69   57   47    25 #>  [2,]    1    2    2   10   22   18   69   57   47    26 #>  [3,]    1    2    2   10   22   18   69   57   47    27 #>  [4,]    1    2    2   10   22   18   69   57   47    28 #>  [5,]    1    2    2   10   22   18   69   57   47    29 #>  [6,]    1    2    2   10   22   18   69   57   47    30 #>  [7,]    1    2    2   10   22   18   69   57   47    31 #>  [8,]    1    2    2   10   22   18   69   57   47    32 #>  [9,]    1    2    2   10   22   18   69   57   47    33 #> [10,]    1    2    2   10   22   18   69   57   47    34 #> [11,]    1    2    2   10   22   18   69   57   47    35  ## Researcher only needs 10 7-tuples of mySamp ## such that the sum is greater than 7200. ## Generate some random data set.seed(1009) mySamp = rnorm(75, 997, 23) comboGeneral(mySamp, 7, constraintFun = \"sum\",              comparisonFun = \">\", limitConstraints = 7200, upper = 10) #>           [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7] #>  [1,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1025.575 #>  [2,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1024.763 #>  [3,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1021.563 #>  [4,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1019.610 #>  [5,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1019.538 #>  [6,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1018.049 #>  [7,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1017.300 #>  [8,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1014.765 #>  [9,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1013.674 #> [10,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1012.299  ## Similarly, you can use \"lower\" to obtain the last rows. ## Generate the last 10 rows comboGeneral(mySamp, 7, lower = choose(75, 7) - 9) #>            [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7] #>  [1,]  982.8377 1001.800 976.6742 981.6386 980.9146 963.3604 985.2435 #>  [2,]  982.8377  985.326 976.6742 981.6386 980.9146 963.3604 985.2435 #>  [3,]  992.2474 1001.800 985.3260 976.6742 981.6386 980.9146 963.3604 #>  [4,]  992.2474 1001.800 985.3260 976.6742 981.6386 980.9146 985.2435 #>  [5,]  992.2474 1001.800 985.3260 976.6742 981.6386 963.3604 985.2435 #>  [6,]  992.2474 1001.800 985.3260 976.6742 980.9146 963.3604 985.2435 #>  [7,]  992.2474 1001.800 985.3260 981.6386 980.9146 963.3604 985.2435 #>  [8,]  992.2474 1001.800 976.6742 981.6386 980.9146 963.3604 985.2435 #>  [9,]  992.2474  985.326 976.6742 981.6386 980.9146 963.3604 985.2435 #> [10,] 1001.7997  985.326 976.6742 981.6386 980.9146 963.3604 985.2435  ## Or if you would like to generate a specific chunk, ## use both \"lower\" and \"upper\". E.g. Generate one ## million combinations starting with the 900,000,001 ## lexicographic combination. t1 = comboGeneral(mySamp, 7,                   lower = 9*10^8 + 1,                   upper = 9*10^8 + 10^6)  ## class of the source vector is preserved class(comboGeneral(5,3)[1,]) == class(1:5) #> [1] TRUE class(comboGeneral(c(1,2:5),3)[1,]) == class(c(1,2:5)) #> [1] TRUE class(comboGeneral(factor(month.name),3)[1,]) == class(factor(month.name)) #> [1] TRUE  ## Using keepResults will add a column of results comboGeneral(-3, 6, TRUE,              constraintFun = \"sum\",              comparisonFun = \"==\",              limitConstraints = -8,              keepResults = TRUE) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]   -3   -1   -1   -1   -1   -1   -8 #> [2,]   -2   -2   -1   -1   -1   -1   -8  ## Using multiple constraints:  ## Get combinations such that the product ## is between 3000 and 4000 inclusive comboGeneral(5, 7, TRUE, constraintFun = \"prod\",              comparisonFun = c(\">=\",\"<=\"),              limitConstraints = c(3000, 4000),              keepResults = TRUE) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]    1    1    5    5    5    5    5 3125 #>  [2,]    1    2    3    4    5    5    5 3000 #>  [3,]    1    2    3    5    5    5    5 3750 #>  [4,]    1    2    4    4    4    5    5 3200 #>  [5,]    1    2    4    4    5    5    5 4000 #>  [6,]    1    3    3    3    5    5    5 3375 #>  [7,]    1    3    3    4    4    5    5 3600 #>  [8,]    1    3    4    4    4    4    4 3072 #>  [9,]    1    3    4    4    4    4    5 3840 #> [10,]    2    2    2    3    5    5    5 3000 #> [11,]    2    2    2    4    4    5    5 3200 #> [12,]    2    2    2    4    5    5    5 4000 #> [13,]    2    2    3    3    4    5    5 3600 #> [14,]    2    2    3    4    4    4    4 3072 #> [15,]    2    2    3    4    4    4    5 3840 #> [16,]    2    3    3    3    3    4    5 3240 #> [17,]    2    3    3    3    4    4    4 3456 #> [18,]    3    3    3    3    3    3    5 3645 #> [19,]    3    3    3    3    3    4    4 3888  ## Or, get the combinations such that the ## product is less than or equal to 10 or ## greater than or equal to 40000 comboGeneral(5, 7, TRUE, constraintFun = \"prod\",              comparisonFun = c(\"<=\",\">=\"),              limitConstraints = c(10, 40000),              keepResults = TRUE) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7]  [,8] #>  [1,]    1    1    1    1    1    1    1     1 #>  [2,]    1    1    1    1    1    1    2     2 #>  [3,]    1    1    1    1    1    1    3     3 #>  [4,]    1    1    1    1    1    1    4     4 #>  [5,]    1    1    1    1    1    1    5     5 #>  [6,]    1    1    1    1    1    2    2     4 #>  [7,]    1    1    1    1    1    2    3     6 #>  [8,]    1    1    1    1    1    2    4     8 #>  [9,]    1    1    1    1    1    2    5    10 #> [10,]    1    1    1    1    1    3    3     9 #> [11,]    1    1    1    1    2    2    2     8 #> [12,]    5    5    5    5    5    5    5 78125 #> [13,]    5    5    5    5    5    5    4 62500 #> [14,]    5    5    5    5    5    5    3 46875 #> [15,]    5    5    5    5    5    4    4 50000 #> [16,]    5    5    5    5    4    4    4 40000  #### General subset sum problem set.seed(516781810) comboGeneral(runif(100, 0, 42), 5, constraintFun = \"mean\",              comparisonFun = \"==\", limitConstraints = 30,              tolerance = 0.0000002) #>          [,1]     [,2]    [,3]     [,4]     [,5] #> [1,] 7.554598 31.01344 34.7431 37.39019 39.29867   #### Integer Partitions comboGeneral(0:5, 5, TRUE, constraintFun = \"sum\",              comparisonFun = \"==\", limitConstraints = 5) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    0    5 #> [2,]    0    0    0    1    4 #> [3,]    0    0    0    2    3 #> [4,]    0    0    1    1    3 #> [5,]    0    0    1    2    2 #> [6,]    0    1    1    1    2 #> [7,]    1    1    1    1    1   ## Using FUN comboGeneral(10000, 5, lower = 20, upper = 22,              FUN = function(x) {                  which(cummax(x) %% 2 == 1)              }) #> [[1]] #> [1] 1 3 #>  #> [[2]] #> [1] 1 3 5 #>  #> [[3]] #> [1] 1 3 #>   if (FALSE) { # \\dontrun{ ## Parallel example generating more than 2^31 - 1 combinations. library(parallel) numCores = detectCores() - 1  ## 10086780 evenly divides choose(35, 15) and is \"small enough\" to ## generate quickly in chunks. system.time(mclapply(seq(1, comboCount(35, 15), 10086780), function(x) {     a = comboGeneral(35, 15, lower = x, upper = x + 10086779)     ## do something     x }, mc.cores = numCores))   ## Find 13-tuple combinations of 1:25 such ## that the mean is less than 10 system.time(myComb <- comboGeneral(25, 13, FALSE,                                    constraintFun = \"mean\",                                    comparisonFun = \"<\",                                    limitConstraints = 10))  ## Alternatively, you must generate all combinations and subsequently ## subset to obtain the combinations that meet the criteria system.time(myComb2 <- combn(25, 13)) system.time(myCols <- which(colMeans(myComb2) < 10)) system.time(myComb2 <- myComb2[, myCols])  ## Any variation is much slower system.time(myComb2 <- combn(25, 13)[,combn(25, 13, mean) < 10])  ## Test equality with myComb above all.equal(myComb, t(myComb2))  ## Fun example... see stackoverflow: ## https://stackoverflow.com/q/22218640/4408538 system.time(permuteGeneral(seq(0L,100L,10L), 8, TRUE,                            constraintFun = \"sum\",                            comparisonFun = \"==\",                            limitConstraints = 100))  ## These are called weak integer compositions. Below, we call ## compositionsGeneral which gives the same output except it ## in lexicographical order. See 'Note' above system.time(compositionsGeneral(seq(0L,100L,10L), 8, TRUE, weak = TRUE)) } # }"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":null,"dir":"Reference","previous_headings":"","what":"Combination and Permutation Iterator — comboIter","title":"Combination and Permutation Iterator — comboIter","text":"Returns iterator iterating combinations permutations vector without constraints. Supports random access via [[ method. GMP support allows exploration combinations/permutations vectors many elements. output lexicographical order next methods reverse lexicographical order prev methods. Learn vignette(\"iterators\").","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combination and Permutation Iterator — comboIter","text":"","code":"comboIter(v, m = NULL, ...) permuteIter(v, m = NULL, ...)  # S3 method for class 'numeric' comboIter(v, m = NULL, repetition = FALSE, freqs = NULL,           constraintFun = NULL, comparisonFun = NULL,           limitConstraints = NULL, keepResults = NULL,           FUN = NULL, Parallel = FALSE, nThreads = NULL,           tolerance = NULL, FUN.VALUE = NULL, ...)  # S3 method for class 'numeric' permuteIter(v, m = NULL, repetition = FALSE, freqs = NULL,             constraintFun = NULL, comparisonFun = NULL,             limitConstraints = NULL, keepResults = NULL,             FUN = NULL, Parallel = FALSE, nThreads = NULL,             tolerance = NULL, FUN.VALUE = NULL, ...)  # S3 method for class 'factor' comboIter(     v, m = NULL, repetition = FALSE, freqs = NULL, FUN = NULL,     Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ... ) # S3 method for class 'factor' permuteIter(     v, m = NULL, repetition = FALSE, freqs = NULL, FUN = NULL,     Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ... )  # Default S3 method comboIter(     v, m = NULL, repetition = FALSE, freqs = NULL,     FUN = NULL, FUN.VALUE = NULL, ... ) # Default S3 method permuteIter(     v, m = NULL, repetition = FALSE, freqs = NULL,     FUN = NULL, FUN.VALUE = NULL, ... )  # S3 method for class 'table' comboIter(     v, m = NULL, constraintFun = NULL, comparisonFun = NULL,     limitConstraints = NULL, keepResults = NULL, FUN = NULL,     Parallel = FALSE, nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ... ) # S3 method for class 'table' permuteIter(     v, m = NULL, constraintFun = NULL, comparisonFun = NULL,     limitConstraints = NULL, keepResults = NULL, FUN = NULL,     Parallel = FALSE, nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ... )  # S3 method for class 'list' comboIter(v, m = NULL, repetition = FALSE, freqs = NULL, ...) # S3 method for class 'list' permuteIter(v, m = NULL, repetition = FALSE, freqs = NULL, ...)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combination and Permutation Iterator — comboIter","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). m Number elements choose.  repetition = TRUE freqs utilized, m can exceed length v. m = NULL, length default length(v) sum(freqs). ... arguments passed methods. repetition Logical value indicating whether combinations/permutations without repetition. default FALSE. freqs vector frequencies used producing combinations/permutations multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. constraintFun Function applied elements v passed string (e.g. constraintFun = \"sum\"). possible constraint functions : \"sum\", \"prod\", \"mean\", \"max\", & \"min\". default NULL, meaning function applied. comparisonFun Comparison operator used compare limitConstraints result constraintFun applied v. passed string vector two strings (e.g. comparisonFun = \"<=\"  comparisonFun = c(\">\",\"<\")). possible comparison operators : \"<\", \">\", \"<=\", \">=\", \"==\". default NULL. comparisonFun vector two comparison strings, e.g comparisonFun = c(comp1, comp2), limitConstraints vector two numerical values, e.g limitConstraints = c(x1, x2), combinations/permutations filtered one following two ways: comp1 one 'greater-' operators (.e. \">=\" \">\"), comp2 one 'less-' operators (.e. \"<=\" \"<\"), x1 < x2, combinations/permutations returned value (constraintFun applied) x1 x2. comp1 comp2 defined #1 x1 > x2, combinations/permutations returned value outside range x1 x2. See examples . words, first comparison operator applied first limit second operator applied second limit. limitConstraints value(s) used comparison. Can passed single value vector two numerical values. default NULL. See definition comparisonFun well examples information. keepResults logical flag indicating result constraintFun applied v displayed; TRUE, additional column results added resulting matrix. default FALSE. user applying constraintFun, keepResults default TRUE. FUN Function applied combination/permutation. default NULL. Parallel Logical value indicating whether combinations/permutations generated parallel using \\(n - 1\\) threads, \\(n\\) maximum number threads. default FALSE. nThreads NULL, given preference (e.g. user 8 threads Parallel = TRUE nThreads = 4, 4 threads spawned). system single-threaded, arguments Parallel nThreads ignored. nThreads Specific number threads used. default NULL. See Parallel. tolerance numeric value greater equal zero. parameter utilized constraint applied numeric vector. default value 0 can determined whole values utilized, otherwise sqrt(.Machine$double.eps) approximately \\(1.5e-8\\). N.B. input vector type integer, parameter ignored strict equality enforced. FUN.VALUE template return value FUN. See 'Details' vapply information.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combination and Permutation Iterator — comboIter","text":"nextIter prevIter called, vector returned Otherwise, matrix \\(m\\) \\(m + 1\\) columns, depending value keepResults FUN utilized, FUN.VALUE = NULL, either nextIter prevIter called, result determined FUN, otherwise list returned. FUN FUN.VALUE NULL, return modeled return vapply. See 'Value' section vapply.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combination and Permutation Iterator — comboIter","text":"initialize new iterator, following methods available via @ (e.g. @nextIter()) $ (e.g. $nextIter()). preferred practice use @ much efficient (See examples ). Also note methods available cases. See Combo-class, Constraints-class, Partitions-class: nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration prevIter Retrieve previous lexicographical result (next reverse lexicographical result) prevNIter Pass integer n retrieve previous n lexicographical results (next n reverse lexicographical results) prevRemaining Retrieve remaining reverse lexicographical results startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result [[ Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Combination and Permutation Iterator — comboIter","text":"Parallel nThreads ignored following cases: output constrained (except partitions cases) class vector passed character, raw, complex (N.B. Rcpp::CharacterMatrix thread safe). Alternatively, can generate indexing matrix parallel. FUN utilized. either constraintFun, comparisonFun limitConstraints NULL –– class vector passed logical, character, raw, factor, complex, constraint check carried . equivalent simply finding combinations/permutations \\(v\\) choose \\(m\\). maximum number combinations/permutations can generated one time \\(2^{31} - 1\\). Factor vectors accepted. Class level attributes preserved except FUN used. Lexicographical ordering guaranteed permutations output constrained. FUN ignored constraint check satisfied.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Combination and Permutation Iterator — comboIter","text":"Lexicographical Order Reverse Lexicographical Order","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combination and Permutation Iterator — comboIter","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsIterator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combination and Permutation Iterator — comboIter","text":"","code":"## Typical usage a = permuteIter(unique(state.region)) a@nextIter() #> [1] South         West          Northeast     North Central #> Levels: Northeast South North Central West a@nextNIter(3) #>      [,1]  [,2]      [,3]          [,4]          #> [1,] South West      North Central Northeast     #> [2,] South Northeast West          North Central #> [3,] South Northeast North Central West          #> Levels: Northeast South North Central West a@front() #> [1] South         West          Northeast     North Central #> Levels: Northeast South North Central West a@nextRemaining() #>       [,1]          [,2]          [,3]          [,4]          #>  [1,] South         West          North Central Northeast     #>  [2,] South         Northeast     West          North Central #>  [3,] South         Northeast     North Central West          #>  [4,] South         North Central West          Northeast     #>  [5,] South         North Central Northeast     West          #>  [6,] West          South         Northeast     North Central #>  [7,] West          South         North Central Northeast     #>  [8,] West          Northeast     South         North Central #>  [9,] West          Northeast     North Central South         #> [10,] West          North Central South         Northeast     #> [11,] West          North Central Northeast     South         #> [12,] Northeast     South         West          North Central #> [13,] Northeast     South         North Central West          #> [14,] Northeast     West          South         North Central #> [15,] Northeast     West          North Central South         #> [16,] Northeast     North Central South         West          #> [17,] Northeast     North Central West          South         #> [18,] North Central South         West          Northeast     #> [19,] North Central South         Northeast     West          #> [20,] North Central West          South         Northeast     #> [21,] North Central West          Northeast     South         #> [22,] North Central Northeast     South         West          #> [23,] North Central Northeast     West          South         #> Levels: Northeast South North Central West a@prevIter() #> [1] North Central Northeast     West          South         #> Levels: Northeast South North Central West a@prevNIter(15) #>       [,1]          [,2]          [,3]          [,4]          #>  [1,] North Central Northeast     South         West          #>  [2,] North Central West          Northeast     South         #>  [3,] North Central West          South         Northeast     #>  [4,] North Central South         Northeast     West          #>  [5,] North Central South         West          Northeast     #>  [6,] Northeast     North Central West          South         #>  [7,] Northeast     North Central South         West          #>  [8,] Northeast     West          North Central South         #>  [9,] Northeast     West          South         North Central #> [10,] Northeast     South         North Central West          #> [11,] Northeast     South         West          North Central #> [12,] West          North Central Northeast     South         #> [13,] West          North Central South         Northeast     #> [14,] West          Northeast     North Central South         #> [15,] West          Northeast     South         North Central #> Levels: Northeast South North Central West a@summary() #> $description #> [1] \"Permutations of 4 choose 4\" #>  #> $currentIndex #> [1] 9 #>  #> $totalResults #> [1] 24 #>  #> $totalRemaining #> [1] 15 #>  a@back() #> [1] North Central Northeast     West          South         #> Levels: Northeast South North Central West a@prevRemaining() #>       [,1]          [,2]          [,3]          [,4]          #>  [1,] North Central Northeast     South         West          #>  [2,] North Central West          Northeast     South         #>  [3,] North Central West          South         Northeast     #>  [4,] North Central South         Northeast     West          #>  [5,] North Central South         West          Northeast     #>  [6,] Northeast     North Central West          South         #>  [7,] Northeast     North Central South         West          #>  [8,] Northeast     West          North Central South         #>  [9,] Northeast     West          South         North Central #> [10,] Northeast     South         North Central West          #> [11,] Northeast     South         West          North Central #> [12,] West          North Central Northeast     South         #> [13,] West          North Central South         Northeast     #> [14,] West          Northeast     North Central South         #> [15,] West          Northeast     South         North Central #> [16,] West          South         North Central Northeast     #> [17,] West          South         Northeast     North Central #> [18,] South         North Central Northeast     West          #> [19,] South         North Central West          Northeast     #> [20,] South         Northeast     North Central West          #> [21,] South         Northeast     West          North Central #> [22,] South         West          North Central Northeast     #> [23,] South         West          Northeast     North Central #> Levels: Northeast South North Central West a[[5]] #> [1] South         North Central West          Northeast     #> Levels: Northeast South North Central West a@summary() #> $description #> [1] \"Permutations of 4 choose 4\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 24 #>  #> $totalRemaining #> [1] 19 #>  a[[c(1, 17, 3)]] #>      [,1]      [,2]          [,3]      [,4]          #> [1,] South     West          Northeast North Central #> [2,] Northeast North Central South     West          #> [3,] South     Northeast     West      North Central #> Levels: Northeast South North Central West a@summary() #> $description #> [1] \"Permutations of 4 choose 4\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 24 #>  #> $totalRemaining #> [1] 19 #>   ## See examples for comboGeneral where lower and upper are used set.seed(1009) mySamp = sort(rnorm(75, 997, 23))  b = comboIter(mySamp, 7,               constraintFun = \"sum\",               comparisonFun = \">\",               limitConstraints = 7200) b@nextIter() #> [1] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1025.575 b@nextNIter(3) #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7] #> [1,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1024.763 #> [2,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1021.563 #> [3,] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1019.610 b@summary() #> $description #> [1] \"Combinations of 75 choose 7 where the sum is > 7200\" #>  #> $currentIndex #> [1] 4 #>  #> $totalResults #> [1] NA #>  #> $totalRemaining #> [1] NA #>  b@currIter() #> [1] 1056.087 1038.314 1036.531 1035.189 1029.416 1026.804 1019.610  if (FALSE) { # \\dontrun{ ## We don't have random access or previous methods b@back() #> Error: no slot of name \"back\" for this object of class \"Constraints\" b@prevIter() #> Error: no slot of name \"prevIter\" for this object of class \"Constraints\" } # }"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank Combinations and Permutations — comboRank","title":"Rank Combinations and Permutations — comboRank","text":"Generate rank (lexicographically) combinations/permutations. functions complement comboSample permuteSample. See examples . GMP support allows exploration combinations/permutations vectors many elements.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank Combinations and Permutations — comboRank","text":"","code":"comboRank(..., v, repetition = FALSE, freqs = NULL) permuteRank(..., v, repetition = FALSE, freqs = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank Combinations and Permutations — comboRank","text":"... vectors matrices ranked. v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). repetition Logical value indicating whether combinations/permutations without repetition. default FALSE. freqs vector frequencies used producing combinations/permutations multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank Combinations and Permutations — comboRank","text":"algorithms rely efficiently ranking \\(n^{th}\\) lexicographical combination/permutation.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank Combinations and Permutations — comboRank","text":"vector class integer, numeric, bigz determined total number combinations/permutations","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rank Combinations and Permutations — comboRank","text":"Lexicographical order ranking/unranking","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rank Combinations and Permutations — comboRank","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Rank Combinations and Permutations — comboRank","text":"v must supplied.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsRank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rank Combinations and Permutations — comboRank","text":"","code":"mySamp = comboSample(30, 8, TRUE, n = 5, seed = 10, namedSample = TRUE) myRank = comboRank(mySamp, v = 30, repetition = TRUE) all.equal(as.integer(rownames(mySamp)), myRank) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Combinations and Permutations — comboSample","title":"Sample Combinations and Permutations — comboSample","text":"Generate specific (lexicographically) random sample combinations/permutations. Produce results parallel using Parallel nThreads arguments. GMP support allows exploration combinations/permutations vectors many elements.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Combinations and Permutations — comboSample","text":"","code":"comboSample(v, m = NULL, ...) permuteSample(v, m = NULL, ...)  # S3 method for class 'numeric' comboSample(v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,             sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,             nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...)  # S3 method for class 'numeric' permuteSample(v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,               sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,               nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...)  # S3 method for class 'factor' comboSample(     v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,     sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,     nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ... ) # S3 method for class 'factor' permuteSample(     v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,     sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,     nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ... )  # Default S3 method comboSample(     v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL, sampleVec = NULL,     seed = NULL, FUN = NULL, namedSample = FALSE, FUN.VALUE = NULL, ... ) # Default S3 method permuteSample(     v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL, sampleVec = NULL,     seed = NULL, FUN = NULL, namedSample = FALSE, FUN.VALUE = NULL, ... )  # S3 method for class 'table' comboSample(     v, m = NULL, n = NULL, sampleVec = NULL, seed = NULL, FUN = NULL,     Parallel = FALSE, nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ... ) # S3 method for class 'table' permuteSample(     v, m = NULL, n = NULL, sampleVec = NULL, seed = NULL, FUN = NULL,     Parallel = FALSE, nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ... )  # S3 method for class 'list' comboSample(     v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,     sampleVec = NULL, seed = NULL, namedSample = FALSE, ... ) # S3 method for class 'list' permuteSample(     v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,     sampleVec = NULL, seed = NULL, namedSample = FALSE, ... )"},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Combinations and Permutations — comboSample","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). m Number elements choose.  repetition = TRUE freqs utilized, m can exceed length v. m = NULL, length default length(v) sum(freqs). ... arguments passed methods. repetition Logical value indicating whether combinations/permutations without repetition. default FALSE. freqs vector frequencies used producing combinations/permutations multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. n Number combinations/permutations return. default NULL. sampleVec vector indices representing lexicographical combination/permutations return. Accepts whole numbers well vectors class bigz well vectors characters seed Random seed initialization. default NULL. N.B. gmp library needed, parameter must set order reproducible results (E.g set.seed() effect cases). FUN Function applied combination/permutation. default NULL. Parallel Logical value indicating whether combinations/permutations generated parallel. default FALSE. TRUE nThreads = NULL, number threads used equal minimum one minus number threads available system number results requested (e.g. user 16 threads needs 5 results, 5 threads used (.e. min(16 - 1, 5) = 5)). nThreads NULL, given preference (e.g. user 8 threads Parallel = TRUE nThreads = 4, 4 threads spawned). system single-threaded, arguments Parallel nThreads ignored. nThreads Specific number threads used. default NULL. See Parallel. namedSample Logical flag. TRUE, rownames corresponding lexicographical combination/permutation, added returned matrix. default FALSE. FUN.VALUE template return value FUN. See 'Details' vapply information.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Combinations and Permutations — comboSample","text":"algorithms rely efficiently generating \\(n^{th}\\) lexicographical combination/permutation. process unranking.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Combinations and Permutations — comboSample","text":"general, matrix \\(m\\) \\(m + 1\\) columns, depending value keepResults FUN utilized FUN.VALUE = NULL, list returned FUN FUN.VALUE NULL, return modeled return vapply. See 'Value' section vapply.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample Combinations and Permutations — comboSample","text":"Lexicographical order","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample Combinations and Permutations — comboSample","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample Combinations and Permutations — comboSample","text":"Parallel nThreads ignored following cases: class vector passed character (N.B. Rcpp::CharacterMatrix thread safe). Alternatively, can generate indexing matrix parallel. FUN utilized. n sampleVec NULL. Factor vectors accepted. Class level attributes preserved except FUN used.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/combinatoricsSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Combinations and Permutations — comboSample","text":"","code":"## generate 10 random combinations comboSample(30, 8, TRUE, n = 5, seed = 10) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    7   11   11   17   20   22   23   27 #> [2,]    4    5    6   15   20   22   22   28 #> [3,]    6   11   11   17   17   21   24   24 #> [4,]   15   17   18   25   27   27   29   30 #> [5,]    5   12   14   18   21   22   25   27  ## Using sampleVec to generate specific permutations fqs   = c(1,2,2,1,2,2,1,2,1,2,2,1,2,1,1) s_idx = c(1, 10^2, 10^5, 10^8, 10^11)  permuteSample(15, 10, freqs = fqs, sampleVec = s_idx) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    2    2    3    3    4    5    5    6     6 #> [2,]    1    2    2    3    3    4    5    6    5    10 #> [3,]    1    2    2    3    3   11    8    4   15     6 #> [4,]    1    2    5    3   10    7    6   11    9    13 #> [5,]   13   15    8   11    5    5    6    1   11    12  ## Same example using 'table' method permuteSample(table(rep(1:15, times = fqs)), 10, sampleVec = s_idx) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    2    2    3    3    4    5    5    6     6 #> [2,]    1    2    2    3    3    4    5    6    5    10 #> [3,]    1    2    2    3    3   11    8    4   15     6 #> [4,]    1    2    5    3   10    7    6   11    9    13 #> [5,]   13   15    8   11    5    5    6    1   11    12  ## Generate each result one by one... ## Same, but not as efficient as generating iteratively all.equal(comboSample(10, 5, sampleVec = 1:comboCount(10, 5)),           comboGeneral(10, 5)) #> [1] TRUE  ## Examples with enormous number of total permutations num = permuteCount(10000, 20) gmp::log2.bigz(num) #> [1] 265.7268  first  = gmp::urand.bigz(n = 1, size = 265, seed = 123) #> Seed default initialisation #> Seed initialisation mySamp = do.call(c, lapply(0:10, function(x) gmp::add.bigz(first, x)))  class(mySamp) #> [1] \"bigz\"  ## using permuteSample pSamp = permuteSample(10000, 20, sampleVec = mySamp)  ## using permuteGeneral pGeneral = permuteGeneral(10000, 20,                           lower = first,                           upper = gmp::add.bigz(first, 10))  identical(pSamp, pGeneral) #> [1] TRUE  ## Using nThreads permPar = permuteSample(10000, 50, n = 8, seed = 10, nThreads = 2)  ## Using FUN permuteSample(10000, 50, n = 4, seed = 10, FUN = sd) #> [[1]] #> [1] 2694.073 #>  #> [[2]] #> [1] 2923.153 #>  #> [[3]] #> [1] 2971.491 #>  #> [[4]] #> [1] 2711.457 #>   if (FALSE) { # \\dontrun{ ## Using Parallel permuteSample(10000, 50, n = 80, seed = 10, Parallel = TRUE) } # }"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Unordered Cartesian Product — comboGrid","title":"Unordered Cartesian Product — comboGrid","text":"Efficient version expand.grid order matter. combinatorial variant groups elements treated equivalent regardless order. example, given: {1, 2}, {1, 2}, unordered Cartesian product {1, 1}, {1, 2}, {2, 2}. loosely equivalent following: t = expand.grid(lst) t = t[.call(order, t), ] key = apply(t, 1, function(x) paste0(sort(x), collapse = \"\")) t[!duplicated(key), ]","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unordered Cartesian Product — comboGrid","text":"","code":"comboGrid(..., repetition = TRUE, return_df = FALSE)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unordered Cartesian Product — comboGrid","text":"... vectors, factors list containing . (See ?expand.grid). repetition Logical value indicating whether results without repetition. default TRUE. return_df Logical flag force output data.frame. default FALSE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unordered Cartesian Product — comboGrid","text":"input type, default comboGrid produce matrix (data.frame otherwise). can ignored setting argument return_df = TRUE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGrid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Unordered Cartesian Product — comboGrid","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unordered Cartesian Product — comboGrid","text":"","code":"## description example lst = list(1:2, 1:2)  t = expand.grid(lst) t = t[do.call(order, t), ] key = apply(t, 1, function(x) paste0(sort(x), collapse = \"\")) t[!duplicated(key), ] #>   Var1 Var2 #> 1    1    1 #> 3    1    2 #> 4    2    2  ## vs using comboGrid. N.B. Output is a matrix comboGrid(lst) #>      Var1 Var2 #> [1,]    1    1 #> [2,]    1    2 #> [3,]    2    2  ## Force a data.frame to be returned comboGrid(lst, return_df = TRUE) #>   Var1 Var2 #> 1    1    1 #> 2    1    2 #> 3    2    2  ## Input vectors are of different type, so a data.frame is returned expGridNoOrder = comboGrid(1:5, 3:9, letters[1:5], letters[c(1,4,5,8)]) head(expGridNoOrder) #>   Var1 Var2 Var3 Var4 #> 1    1    3    a    a #> 2    1    3    a    d #> 3    1    3    a    e #> 4    1    3    a    h #> 5    1    3    b    a #> 6    1    3    b    d tail(expGridNoOrder) #>     Var1 Var2 Var3 Var4 #> 539    5    9    c    h #> 540    5    9    d    d #> 541    5    9    d    e #> 542    5    9    d    h #> 543    5    9    e    e #> 544    5    9    e    h  expGridNoOrderNoRep = comboGrid(1:5, 3:9, letters[1:5],                                 letters[c(1,4,5,8)], repetition = FALSE)  head(expGridNoOrderNoRep) #>   Var1 Var2 Var3 Var4 #> 1    1    3    a    d #> 2    1    3    a    e #> 3    1    3    a    h #> 4    1    3    b    a #> 5    1    3    b    d #> 6    1    3    b    e tail(expGridNoOrderNoRep) #>     Var1 Var2 Var3 Var4 #> 401    5    9    c    d #> 402    5    9    c    e #> 403    5    9    c    h #> 404    5    9    d    e #> 405    5    9    d    h #> 406    5    9    e    h"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":null,"dir":"Reference","previous_headings":"","what":"Partition a Vector into Groups — comboGroups","title":"Partition a Vector into Groups — comboGroups","text":"Generate partitions vector groups. See Create Combinations R Groups https://stackoverflow.com direct use case groups sizes equal. Produce results parallel using Parallel nThreads arguments. GMP support allows exploration number results large. output lexicographical order groups.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partition a Vector into Groups — comboGroups","text":"","code":"comboGroups(v, numGroups = NULL, grpSizes = NULL,             retType = \"matrix\", lower = NULL, upper = NULL,             Parallel = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partition a Vector into Groups — comboGroups","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). numGroups Integer. number groups vector partitioned . default NULL. provided grpSize NULL, must divide length v (v vector) v (v scalar). grpSizes vector whole numbers representing size group. default NULL. provided, sum elements must total length v (v vector) v (v scalar). retType string, \"3Darray\" \"matrix\", determines shape output. default \"matrix\". Note, \"3Darray\" can used size group uniform. size group varies, return output always matrix. lower lower bound. Partitions groups generated lexicographically, thus utilizing argument determine specific result start generating (e.g. comboGroups(8, 2, lower = 30) equivalent comboGroups(8, 2)[30:comboGroupsCount(8, 2), ]). argument along upper useful generating results chunks allowing easy parallelization. upper upper bound. Similar lower, however parameter allows user stop generation specific result (e.g. comboGroups(8, 2, upper = 5) equivalent comboGroups(8, 2)[1:5, ]) Parallel Logical value indicating whether results generated parallel using \\(n - 1\\) threads, \\(n\\) maximum number threads. default FALSE. nThreads NULL, given preference (e.g. user 8 threads Parallel = TRUE nThreads = 4, 4 threads spawned). system single-threaded, arguments Parallel nThreads ignored. nThreads Specific number threads used. default NULL. See Parallel.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partition a Vector into Groups — comboGroups","text":"Conceptually, problem can viewed generating permutations vector v removing within group permutations. illustrate , let us consider case generating partitions 1:8 2 groups size 4. begin, generate permutations 1:8 group first/last four elements row. Note permutations equivalent partitions 2 groups size 4 last four elements permuted. look \\(25^{th}\\) lexicographical permutation, observe second distinct partition. Continuing , reach \\(3,457^{th}\\) lexicographical permutation, represents last result: small example, method computationally expensive. fact, 35 total partitions 1:8 2 groups size 4 possible factorial(8) = 40320 permutations. However, just doubling size vector make approach infeasible 10 trillion permutations 1:16. algorithm comboGroups avoids duplicate partitions groups utilizing efficient algorithm analogous std::next_permutation found standard algorithm library C++.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partition a Vector into Groups — comboGroups","text":"default, matrix returned column names corresponding associated group. retType = \"3Darray\", named 3D array returned.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Partition a Vector into Groups — comboGroups","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Partition a Vector into Groups — comboGroups","text":"maximum number partitions groups can generated one time \\(2^{31} - 1\\). Utilizing lower upper makes possible generate additional combinations/permutations. length grpSizes must equal numGroups grpSize numGroups provided.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partition a Vector into Groups — comboGroups","text":"","code":"## return a matrix comboGroups(8, 2) #>       Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 #>  [1,]    1    2    3    4    5    6    7    8 #>  [2,]    1    2    3    5    4    6    7    8 #>  [3,]    1    2    3    6    4    5    7    8 #>  [4,]    1    2    3    7    4    5    6    8 #>  [5,]    1    2    3    8    4    5    6    7 #>  [6,]    1    2    4    5    3    6    7    8 #>  [7,]    1    2    4    6    3    5    7    8 #>  [8,]    1    2    4    7    3    5    6    8 #>  [9,]    1    2    4    8    3    5    6    7 #> [10,]    1    2    5    6    3    4    7    8 #> [11,]    1    2    5    7    3    4    6    8 #> [12,]    1    2    5    8    3    4    6    7 #> [13,]    1    2    6    7    3    4    5    8 #> [14,]    1    2    6    8    3    4    5    7 #> [15,]    1    2    7    8    3    4    5    6 #> [16,]    1    3    4    5    2    6    7    8 #> [17,]    1    3    4    6    2    5    7    8 #> [18,]    1    3    4    7    2    5    6    8 #> [19,]    1    3    4    8    2    5    6    7 #> [20,]    1    3    5    6    2    4    7    8 #> [21,]    1    3    5    7    2    4    6    8 #> [22,]    1    3    5    8    2    4    6    7 #> [23,]    1    3    6    7    2    4    5    8 #> [24,]    1    3    6    8    2    4    5    7 #> [25,]    1    3    7    8    2    4    5    6 #> [26,]    1    4    5    6    2    3    7    8 #> [27,]    1    4    5    7    2    3    6    8 #> [28,]    1    4    5    8    2    3    6    7 #> [29,]    1    4    6    7    2    3    5    8 #> [30,]    1    4    6    8    2    3    5    7 #> [31,]    1    4    7    8    2    3    5    6 #> [32,]    1    5    6    7    2    3    4    8 #> [33,]    1    5    6    8    2    3    4    7 #> [34,]    1    5    7    8    2    3    4    6 #> [35,]    1    6    7    8    2    3    4    5  ## or a 3 dimensional array temp = comboGroups(8, 2, retType = \"3Darray\")  ## view the first partition temp[1, , ] #>      Grp1 Grp2 #> [1,]    1    5 #> [2,]    2    6 #> [3,]    3    7 #> [4,]    4    8  ## Example with groups of varying size comboGroups(8, grpSizes = c(3, 5)) #>       Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp2 #>  [1,]    1    2    3    4    5    6    7    8 #>  [2,]    1    2    4    3    5    6    7    8 #>  [3,]    1    2    5    3    4    6    7    8 #>  [4,]    1    2    6    3    4    5    7    8 #>  [5,]    1    2    7    3    4    5    6    8 #>  [6,]    1    2    8    3    4    5    6    7 #>  [7,]    1    3    4    2    5    6    7    8 #>  [8,]    1    3    5    2    4    6    7    8 #>  [9,]    1    3    6    2    4    5    7    8 #> [10,]    1    3    7    2    4    5    6    8 #> [11,]    1    3    8    2    4    5    6    7 #> [12,]    1    4    5    2    3    6    7    8 #> [13,]    1    4    6    2    3    5    7    8 #> [14,]    1    4    7    2    3    5    6    8 #> [15,]    1    4    8    2    3    5    6    7 #> [16,]    1    5    6    2    3    4    7    8 #> [17,]    1    5    7    2    3    4    6    8 #> [18,]    1    5    8    2    3    4    6    7 #> [19,]    1    6    7    2    3    4    5    8 #> [20,]    1    6    8    2    3    4    5    7 #> [21,]    1    7    8    2    3    4    5    6 #> [22,]    2    3    4    1    5    6    7    8 #> [23,]    2    3    5    1    4    6    7    8 #> [24,]    2    3    6    1    4    5    7    8 #> [25,]    2    3    7    1    4    5    6    8 #> [26,]    2    3    8    1    4    5    6    7 #> [27,]    2    4    5    1    3    6    7    8 #> [28,]    2    4    6    1    3    5    7    8 #> [29,]    2    4    7    1    3    5    6    8 #> [30,]    2    4    8    1    3    5    6    7 #> [31,]    2    5    6    1    3    4    7    8 #> [32,]    2    5    7    1    3    4    6    8 #> [33,]    2    5    8    1    3    4    6    7 #> [34,]    2    6    7    1    3    4    5    8 #> [35,]    2    6    8    1    3    4    5    7 #> [36,]    2    7    8    1    3    4    5    6 #> [37,]    3    4    5    1    2    6    7    8 #> [38,]    3    4    6    1    2    5    7    8 #> [39,]    3    4    7    1    2    5    6    8 #> [40,]    3    4    8    1    2    5    6    7 #> [41,]    3    5    6    1    2    4    7    8 #> [42,]    3    5    7    1    2    4    6    8 #> [43,]    3    5    8    1    2    4    6    7 #> [44,]    3    6    7    1    2    4    5    8 #> [45,]    3    6    8    1    2    4    5    7 #> [46,]    3    7    8    1    2    4    5    6 #> [47,]    4    5    6    1    2    3    7    8 #> [48,]    4    5    7    1    2    3    6    8 #> [49,]    4    5    8    1    2    3    6    7 #> [50,]    4    6    7    1    2    3    5    8 #> [51,]    4    6    8    1    2    3    5    7 #> [52,]    4    7    8    1    2    3    5    6 #> [53,]    5    6    7    1    2    3    4    8 #> [54,]    5    6    8    1    2    3    4    7 #> [55,]    5    7    8    1    2    3    4    6 #> [56,]    6    7    8    1    2    3    4    5  total = comboGroupsCount(11, grpSizes = c(3, 3, 5))  ## Start generating from particular index comboGroups(11, grpSizes = c(3, 3, 5), lower = total - 20) #>       Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3 Grp3 #>  [1,]    5    9   10    6    7   11    1    2    3    4    8 #>  [2,]    5    9   10    6    8   11    1    2    3    4    7 #>  [3,]    5    9   10    7    8   11    1    2    3    4    6 #>  [4,]    5    9   11    6    7    8    1    2    3    4   10 #>  [5,]    5    9   11    6    7   10    1    2    3    4    8 #>  [6,]    5    9   11    6    8   10    1    2    3    4    7 #>  [7,]    5    9   11    7    8   10    1    2    3    4    6 #>  [8,]    5   10   11    6    7    8    1    2    3    4    9 #>  [9,]    5   10   11    6    7    9    1    2    3    4    8 #> [10,]    5   10   11    6    8    9    1    2    3    4    7 #> [11,]    5   10   11    7    8    9    1    2    3    4    6 #> [12,]    6    7    8    9   10   11    1    2    3    4    5 #> [13,]    6    7    9    8   10   11    1    2    3    4    5 #> [14,]    6    7   10    8    9   11    1    2    3    4    5 #> [15,]    6    7   11    8    9   10    1    2    3    4    5 #> [16,]    6    8    9    7   10   11    1    2    3    4    5 #> [17,]    6    8   10    7    9   11    1    2    3    4    5 #> [18,]    6    8   11    7    9   10    1    2    3    4    5 #> [19,]    6    9   10    7    8   11    1    2    3    4    5 #> [20,]    6    9   11    7    8   10    1    2    3    4    5 #> [21,]    6   10   11    7    8    9    1    2    3    4    5"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of Partitions of a Vector into Groups — comboGroupsCount","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"Calculate number partitions vector groups. See related integer sequences A025035-A025042 OEIS (E.g. A025036 Number partitions \\( 1, 2, ..., 4n \\) sets size 4.)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"","code":"comboGroupsCount(v, numGroups = NULL, grpSizes = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). numGroups Integer. number groups vector partitioned . default NULL. provided grpSize NULL, must divide length v (v vector) v (v scalar). grpSizes vector whole numbers representing size group. default NULL. provided, sum elements must total length v (v vector) v (v scalar).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"numerical value representing total number partitions groups.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"OEIS Integer Sequence A025036","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"number results exceeds \\(2^{53} - 1\\), number class bigz returned.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsCount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of Partitions of a Vector into Groups — comboGroupsCount","text":"","code":"comboGroupsCount(16, 4) #> [1] 2627625 comboGroupsCount(16, grpSizes = c(1:4, 6)) #> [1] 100900800 comboGroupsCount(28, grpSizes = rep(2:5, each = 2)) #> Big Integer ('bigz') : #> [1] 15954139019358540000"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":null,"dir":"Reference","previous_headings":"","what":"comboGroups Iterator — comboGroupsIter","title":"comboGroups Iterator — comboGroupsIter","text":"Returns iterator iterating partitions vector groups. Supports random access via [[ method. GMP support allows exploration cases number comboGroups large. Use next methods obtain results lexicographical order.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"comboGroups Iterator — comboGroupsIter","text":"","code":"comboGroupsIter(v, numGroups = NULL, grpSizes = NULL,                 retType = \"matrix\", Parallel = FALSE,                 nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"comboGroups Iterator — comboGroupsIter","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). numGroups Integer. number groups vector partitioned . default NULL. provided grpSize NULL, must divide length v (v vector) v (v scalar). grpSizes vector whole numbers representing size group. default NULL. provided, sum elements must total length v (v vector) v (v scalar). retType string, \"3Darray\" \"matrix\", determines shape output. default \"matrix\". Note, \"3Darray\" can used size group uniform. size group varies, return output always matrix. Parallel Logical value indicating whether results generated parallel using \\(n - 1\\) threads, \\(n\\) maximum number threads. default FALSE. nThreads NULL, given preference (e.g. user 8 threads Parallel = TRUE nThreads = 4, 4 threads spawned). system single-threaded, arguments Parallel nThreads ignored. nThreads Specific number threads used. default NULL. See Parallel.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"comboGroups Iterator — comboGroupsIter","text":"nextIter called, named vector returned retType = \"matrix\". retType = \"3Darray\", named matrix returned. Otherwise named matrix returned retType = \"matrix\" named 3D array returned retType = \"3Darray\".","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"comboGroups Iterator — comboGroupsIter","text":"initialize new iterator, following methods available: nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result [[ Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"comboGroups Iterator — comboGroupsIter","text":"nThreads utilized, take effect number elements requested greater threshold (determined internally). E.g: maximum number comboGroups can generated one time \\(2^{31} - 1\\).","code":"serial   <- comboGroupsIter(50, 10) multi    <- comboGroupsIter(50, 10, nThreads = 4) fetch1e6 <- multi@nextNIter(1e6)  ## much faster than serial@nextNIter(1e6) fetch1e3 <- multi@nextNIter(1e3)  ## only one thread used... same as serial@nextNIter(1e3)library(microbenchmark) microbenchmark(multi@nextNIter(1e6), serial@nextNIter(1e6), times = 20) microbenchmark(multi@nextNIter(1e3), serial@nextNIter(1e3), times = 20)"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"comboGroups Iterator — comboGroupsIter","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsIterator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"comboGroups Iterator — comboGroupsIter","text":"","code":"a = comboGroupsIter(12, 3) a@nextIter() #> Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3  #>    1    2    3    4    5    6    7    8    9   10   11   12  a@nextNIter(3) #>      Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3 #> [1,]    1    2    3    4    5    6    7    9    8   10   11   12 #> [2,]    1    2    3    4    5    6    7   10    8    9   11   12 #> [3,]    1    2    3    4    5    6    7   11    8    9   10   12 a@front() #> Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3  #>    1    2    3    4    5    6    7    8    9   10   11   12  all_remaining = a@nextRemaining() dim(all_remaining) #> [1] 5774   12 a@summary() #> $description #> [1] \"Partition of v of length 12 into 3 uniform groups\" #>  #> $currentIndex #> [1] 5776 #>  #> $totalResults #> [1] 5775 #>  #> $totalRemaining #> [1] -1 #>  a@back() #> Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3  #>    1   10   11   12    2    7    8    9    3    4    5    6  a[[5]] #> Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3  #>    1    2    3    4    5    6    7   12    8    9   10   11  a@summary() #> $description #> [1] \"Partition of v of length 12 into 3 uniform groups\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 5775 #>  #> $totalRemaining #> [1] 5770 #>  a[[c(1, 17, 3)]] #>      Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp3 #> [1,]    1    2    3    4    5    6    7    8    9   10   11   12 #> [2,]    1    2    3    4    5    7    8   10    6    9   11   12 #> [3,]    1    2    3    4    5    6    7   10    8    9   11   12 a@summary() #> $description #> [1] \"Partition of v of length 12 into 3 uniform groups\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 5775 #>  #> $totalRemaining #> [1] 5770 #>"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Partitions of a Vector into Groups — comboGroupsSample","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"Generate specific (lexicographically) random sample partitions groups. Produce results parallel using Parallel nThreads arguments. GMP support allows exploration number results large.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"","code":"comboGroupsSample(v, numGroups = NULL, grpSizes = NULL, retType = \"matrix\",                   n = NULL, sampleVec = NULL, seed = NULL, Parallel = FALSE,                   nThreads = NULL, namedSample = FALSE)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). numGroups Integer. number groups vector partitioned . default NULL. provided grpSize NULL, must divide length v (v vector) v (v scalar). grpSizes vector whole numbers representing size group. default NULL. provided, sum elements must total length v (v vector) v (v scalar). retType string, \"3Darray\" \"matrix\", determines shape output. default \"matrix\". Note, \"3Darray\" can used size group uniform. size group varies, return output always matrix. n Number results return. default NULL. sampleVec vector numbers representing lexicographical partition groups return. Accepts vectors class bigz well vectors characters seed Random seed initialization. default NULL. N.B. gmp library needed, parameter must set order reproducible results (E.g set.seed() effect cases). Parallel Logical value indicating whether results generated parallel. default FALSE. TRUE nThreads = NULL, number threads used equal minimum one minus number threads available system number results requested (e.g. user 16 threads needs 5 results, 5 threads used (.e. min(16 - 1, 5) = 5)). nThreads NULL, given preference (e.g. user 8 threads Parallel = TRUE nThreads = 4, 4 threads spawned). system single-threaded, arguments Parallel nThreads ignored. nThreads Specific number threads used. default NULL. See Parallel. namedSample Logical flag. TRUE, rownames corresponding lexicographical result, added returned matrix. default FALSE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"algorithms rely efficiently generating \\(n^{th}\\) lexicographical result.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"default, matrix returned column names corresponding associated group. retType = \"3Darray\", 3D array returned.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"Lexicographical order","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/comboGroupsSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Partitions of a Vector into Groups — comboGroupsSample","text":"","code":"## generate 10 random partitions of groups of equal size comboGroupsSample(10, 2, n = 10, seed = 123) #>       Grp1 Grp1 Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp2 Grp2 #>  [1,]    1    2    4    7    8    3    5    6    9   10 #>  [2,]    1    3    5    8    9    2    4    6    7   10 #>  [3,]    1    2    6    8   10    3    4    5    7    9 #>  [4,]    1    2    3    6    9    4    5    7    8   10 #>  [5,]    1    3    4    7    9    2    5    6    8   10 #>  [6,]    1    2    5    7    9    3    4    6    8   10 #>  [7,]    1    2    6    8    9    3    4    5    7   10 #>  [8,]    1    5    7    8    9    2    3    4    6   10 #>  [9,]    1    2    5    7   10    3    4    6    8    9 #> [10,]    1    4    5    9   10    2    3    6    7    8  ## generate 10 random partitions of groups of varying sizes comboGroupsSample(10, grpSizes = 1:4, n = 10, seed = 123) #>       Grp1 Grp2 Grp2 Grp3 Grp3 Grp3 Grp4 Grp4 Grp4 Grp4 #>  [1,]    2    8   10    1    6    7    3    4    5    9 #>  [2,]    2    9   10    4    5    6    1    3    7    8 #>  [3,]    9    2    4    3    7   10    1    5    6    8 #>  [4,]    7    8    9    1    2    5    3    4    6   10 #>  [5,]   10    6    9    2    5    7    1    3    4    8 #>  [6,]    3    2    9    1    6    8    4    5    7   10 #>  [7,]    2    4    6    3    7   10    1    5    8    9 #>  [8,]    8    2   10    3    6    9    1    4    5    7 #>  [9,]    3    5    9    1    6    8    2    4    7   10 #> [10,]   10    2    3    4    5    8    1    6    7    9  ## using sampleVec to generate specific results comboGroupsSample(15, 5, sampleVec = c(1, 100, 1e3, 1e6)) #>      Grp1 Grp1 Grp1 Grp2 Grp2 Grp2 Grp3 Grp3 Grp3 Grp4 Grp4 Grp4 Grp5 Grp5 Grp5 #> [1,]    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15 #> [2,]    1    2    3    4    5    6    7    9   12    8   14   15   10   11   13 #> [3,]    1    2    3    4    5    9    6   10   13    7   14   15    8   11   12 #> [4,]    1    8   10    2   12   15    3    5   13    4   11   14    6    7    9  all.equal(comboGroupsSample(10, 5,             sampleVec = 1:comboGroupsCount(10, 5)),          comboGroups(10, 5)) #> [1] TRUE  ## Examples with enormous number of total results num = comboGroupsCount(100, 20) gmp::log2.bigz(num) #> [1] 325.5498 ## [1] 325.5498  first = gmp::urand.bigz(n = 1, size = 325, seed = 123) #> Seed initialisation mySamp = do.call(c, lapply(0:10, function(x) gmp::add.bigz(first, x)))  class(mySamp) #> [1] \"bigz\" ## [1] \"bigz\"  ## using the sampling function cbgSamp = comboGroupsSample(100, 20, sampleVec = mySamp)  ## using the standard function cbgGeneral = comboGroups(100, 20,                          lower = first,                          upper = gmp::add.bigz(first, 10))  identical(cbgSamp, cbgGeneral) #> [1] TRUE ## [1] TRUE  if (FALSE) { # \\dontrun{ ## Using Parallel system.time(comboGroupsSample(1000, 20, n = 80, seed = 10, Parallel = TRUE)) } # }"},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized Factorization (Complete) — divisorsRcpp","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"Function generating complete factorization vector numbers.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"","code":"divisorsRcpp(v, namedList = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"v Vector integers numeric values. Non-integral values coerced whole numbers. namedList Logical flag. TRUE length(v) > 1, named list returned. default FALSE. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"Efficient algorithm builds primeFactorize generate complete factorization many numbers.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"Returns unnamed vector length(v) == 1 regardless value namedList. \\(v < 2^{31}\\), class returned vector integer, otherwise class numeric. length(v) > 1, named/unnamed list vectors returned. max(bound1, bound2) \\(< 2^{31}\\), class vector integer, otherwise class numeric.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"Divisor 53-bit significand precision","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"maximum value element \\(v\\) \\(2^{53} - 1\\).","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsRcpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized Factorization (Complete) — divisorsRcpp","text":"","code":"## Get the complete factorization of a single number divisorsRcpp(10^8) #>  [1]         1         2         4         5         8        10        16 #>  [8]        20        25        32        40        50        64        80 #> [15]       100       125       128       160       200       250       256 #> [22]       320       400       500       625       640       800      1000 #> [29]      1250      1280      1600      2000      2500      3125      3200 #> [36]      4000      5000      6250      6400      8000     10000     12500 #> [43]     15625     16000     20000     25000     31250     32000     40000 #> [50]     50000     62500     78125     80000    100000    125000    156250 #> [57]    160000    200000    250000    312500    390625    400000    500000 #> [64]    625000    781250    800000   1000000   1250000   1562500   2000000 #> [71]   2500000   3125000   4000000   5000000   6250000  10000000  12500000 #> [78]  20000000  25000000  50000000 100000000  ## Or get the complete factorization of many numbers set.seed(29) myVec <- sample(-1000000:1000000, 1000) system.time(myFacs <- divisorsRcpp(myVec)) #>    user  system elapsed  #>   0.002   0.000   0.002   ## Return named list myFacsWithNames <- divisorsRcpp(myVec, namedList = TRUE)  ## Using nThreads system.time(divisorsRcpp(myVec, nThreads = 2)) #>    user  system elapsed  #>   0.001   0.001   0.001"},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"Sieve generates complete factorization numbers bound1 bound2 (supplied) numbers bound1.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"","code":"divisorsSieve(bound1, bound2 = NULL, namedList = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"bound1 Positive integer numeric value. bound2 Positive integer numeric value. namedList Logical flag. TRUE, named list returned. default FALSE. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"function useful many complete factorizations needed. Instead generating complete factorization fly, one can reference indices/names generated list. algorithm benefits greatly fast integer division library 'libdivide'. following https://libdivide.com/: “libdivide allows replace expensive integer divides comparatively cheap multiplication bitshifts. Compilers usually , divisor known compile time. libdivide allows take advantage runtime. result integer division can become faster - lot faster.”","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"Returns named/unnamed list integer vectors max(bound1, bound2) \\(< 2^{31}\\), list numeric vectors otherwise.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"maximum value either bounds \\(2^{53} - 1\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"Divisor ridiculousfish (author libdivide) github.com/ridiculousfish/libdivide 53-bit significand precision","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/divisorsSieve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Complete Factorization for Numbers in a Range — divisorsSieve","text":"","code":"## Generate some random data set.seed(33550336) mySamp <- sample(10^5, 5*10^4)  ## Generate complete factorizations up ## to 10^5 (max element from mySamp) system.time(allFacs <- divisorsSieve(10^5)) #>    user  system elapsed  #>   0.024   0.000   0.024   ## Use generated complete factorization for further ## analysis by accessing the index of allFacs for (s in mySamp) {     myFac <- allFacs[[s]]     ## Continue algorithm }  ## Generating complete factorizations over ## a range is efficient as well system.time(divisorsSieve(10^12, 10^12 + 10^5)) #>    user  system elapsed  #>   0.061   0.007   0.068   ## Use nThreads for improved efficiency system.time(divisorsSieve(10^12, 10^12 + 10^5, nThreads = 2)) #>    user  system elapsed  #>   0.080   0.014   0.058   ## Set 'namedList' to TRUE to return a named list divisorsSieve(27, 30, namedList = TRUE) #> $`27` #> [1]  1  3  9 27 #>  #> $`28` #> [1]  1  2  4  7 14 28 #>  #> $`29` #> [1]  1 29 #>  #> $`30` #> [1]  1  2  3  5  6 10 15 30 #>   ## Using nThreads system.time(divisorsSieve(1e5, 2e5, nThreads = 2)) #>    user  system elapsed  #>   0.028   0.000   0.022"},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"Sieve generates number coprime elements every number bound1 bound2 (supplied) numbers bound1. equivalent applying Euler's phi function (often written \\(\\phi(x)\\)) every number given range.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"","code":"eulerPhiSieve(bound1, bound2 = NULL, namedVector = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"bound1 Positive integer numeric value. bound2 Positive integer numeric value. namedVector Logical flag. TRUE, named vector returned. default FALSE. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"simple case (.e. bound2 = NULL), algorithm first generates primes \\(n\\) via sieve Eratosthenes. use primes sieve sequence 1:n, dividing value \\(p\\), creating temporary value subtracted original value index (.e. equivalent multiply index \\((1 - 1/p)\\) efficient deal floating point numbers). case .null(bound2) = FALSE complicated basic ideas still hold. function useful need calculate Euler's phi function many numbers range performing calculation fly can computationally expensive. algorithm benefits greatly fast integer division library 'libdivide'. following https://libdivide.com/: “libdivide allows replace expensive integer divides comparatively cheap multiplication bitshifts. Compilers usually , divisor known compile time. libdivide allows take advantage runtime. result integer division can become faster - lot faster.”","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"Returns named/unnamed integer vector max(bound1, bound2) \\(< 2^{31}\\), numeric vector otherwise.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"maximum allowed value \\(2^{53} - 1\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"Euler's totient function ridiculousfish (author libdivide) github.com/ridiculousfish/libdivide 53-bit significand precision","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/eulerPhiSieve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Euler's Phi Function to Every Element in a Range — eulerPhiSieve","text":"","code":"## Generate some random data set.seed(496) mySamp <- sample(10^6, 5*10^5)  ## Generate number of coprime elements for many numbers system.time(myPhis <- eulerPhiSieve(10^6)) #>    user  system elapsed  #>   0.009   0.001   0.009   ## Now use result in algorithm for (s in mySamp) {     sPhi <- myPhis[s]     ## Continue algorithm }  ## See https://projecteuler.net system.time(which.max((1:10^6)/eulerPhiSieve(10^6))) #>    user  system elapsed  #>   0.011   0.001   0.012   ## Generating number of coprime elements ## for every number in a range is no problem system.time(myPhiRange <- eulerPhiSieve(10^13, 10^13 + 10^6)) #>    user  system elapsed  #>   0.027   0.002   0.029   ## Returning a named vector eulerPhiSieve(10, 20, namedVector = TRUE) #> 10 11 12 13 14 15 16 17 18 19 20  #>  4 10  4 12  6  8  8 16  6 18  8  eulerPhiSieve(10, namedVector = TRUE) #>  1  2  3  4  5  6  7  8  9 10  #>  1  1  2  2  4  2  6  4  6  4   ## Using nThreads system.time(eulerPhiSieve(1e5, 2e5, nThreads = 2)) #>    user  system elapsed  #>   0.001   0.000   0.001"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Cartesian Product — expandGrid","title":"Cartesian Product — expandGrid","text":"Generate Cartesian Product input vectors. similar expand.grid however notable differences: Produces lexicographic ordered output consistent functions RcppAlgos. Compared expand.grid first column varies fastest, expandGrid varies first column slowest. input type, default expandGrid produce matrix (data.frame otherwise). can ignored setting argument return_df = TRUE. attributes added strings converted factors. expand.grid achieve setting KEEP..ATTRS = FALSE stringsAsFactors = FALSE. possible return matrix, can utilize argument nThreads order produce results parallel maximal efficiency.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cartesian Product — expandGrid","text":"","code":"expandGrid(..., lower = NULL, upper = NULL,                nThreads = NULL, return_df = FALSE)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cartesian Product — expandGrid","text":"... vectors, factors list containing . (See ?expand.grid). lower lower bound. Cartesian products generated lexicographically, thus utilizing argument determine specific product start generating (e.g. expandGrid(1:5, 3:11, lower = 6) equivalent expandGrid(1:5, 3:11)[6:expandGridCount(1:5, 3:11), ]). argument along upper useful generating products chunks allowing easy parallelization. upper upper bound. Similar lower, however parameter allows user stop generation specific product (e.g. expandGrid(1:5, 3:11, upper = 5) equivalent expandGrid(1:5, 3:11)[1:5, ]) nThreads Specific number threads used. default NULL. return_df Logical flag force output data.frame. default FALSE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cartesian Product — expandGrid","text":"input type, default expandGrid produces matrix (data.frame otherwise). can ignored setting argument return_df = TRUE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGrid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cartesian Product — expandGrid","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cartesian Product — expandGrid","text":"","code":"## description example lst = list(1:2, 1:2)  ## Using base R t = expand.grid(lst)  ## vs using expandGrid. N.B. Output is a matrix expandGrid(lst) #>      Var1 Var2 #> [1,]    1    1 #> [2,]    1    2 #> [3,]    2    1 #> [4,]    2    2  ## Force a data.frame to be returned expandGrid(lst, return_df = TRUE) #>   Var1 Var2 #> 1    1    1 #> 2    1    2 #> 3    2    1 #> 4    2    2  lst = Map(function(x, y) x:y, 8:14, 15:21)  ## Use multiple threads for greater efficiency system.time(expandGrid(lst, nThreads = 2)) #>    user  system elapsed  #>   0.016   0.007   0.012"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridCount.html","id":null,"dir":"Reference","previous_headings":"","what":"Count of the Cartesian Product — expandGridCount","title":"Count of the Cartesian Product — expandGridCount","text":"Calculate number Cartesian products input vectors.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridCount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count of the Cartesian Product — expandGridCount","text":"","code":"expandGridCount(...)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridCount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count of the Cartesian Product — expandGridCount","text":"... vectors, factors list containing . (See ?expand.grid).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridCount.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count of the Cartesian Product — expandGridCount","text":"number results exceeds \\(2^{53} - 1\\), number class bigz returned.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridCount.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count of the Cartesian Product — expandGridCount","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridCount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count of the Cartesian Product — expandGridCount","text":"","code":"## description example lst = list(1:2, 1:2)  ## Using base R t = expand.grid(lst) nrow(t) #> [1] 4  ## vs calling expandGridCount directly expandGridCount(lst) #> [1] 4  ## Call it just like you would if you were generating the results expandGridCount(1:5, 3:9, letters[1:5], letters[c(1,4,5,8)]) #> [1] 700  ## Same as nrow(expand.grid(1:5, 3:9, letters[1:5], letters[c(1,4,5,8)])) #> [1] 700  lst = Map(function(x, y) x:y, 8:33, 15:40)  ## Return object of class 'bigz' expandGridCount(lst) #> Big Integer ('bigz') : #> [1] 302231454903657293676544"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":null,"dir":"Reference","previous_headings":"","what":"expandGrid Iterator — expandGridIter","title":"expandGrid Iterator — expandGridIter","text":"Returns iterator iterating Cartesian product input vectors. Supports random access via [[ method. GMP support allows exploration cases number products large. Use next methods obtain results lexicographical order.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"expandGrid Iterator — expandGridIter","text":"","code":"expandGridIter(..., nThreads = NULL, return_df = FALSE)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"expandGrid Iterator — expandGridIter","text":"... vectors, factors list containing . (See ?expand.grid). nThreads Specific number threads used. default NULL. return_df Logical flag force output data.frame. default FALSE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"expandGrid Iterator — expandGridIter","text":"nextIter called, named vector returned matrix can returned general case. Otherwise, data.frame returned. nextNIter nextRemaining called, named matrix returned input type return_df = FALSE. Otherwise, data.frame returned.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"expandGrid Iterator — expandGridIter","text":"initialize new iterator, following methods available: nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration startOver Resets iterator sourceVector View source input summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result [[ Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"expandGrid Iterator — expandGridIter","text":"nThreads utilized, take effect number elements requested greater threshold (determined internally). E.g: maximum number expandGrid can generated one time \\(2^{31} - 1\\).","code":"serial   <- expandGridIter(Map(\\(x, y) x:y, 1:10, 11:20)) multi    <- expandGridIter(Map(\\(x, y) x:y, 1:10, 11:20), nThreads = 4) fetch1e6 <- multi@nextNIter(1e6)  ## much faster than serial@nextNIter(1e6) fetch1e3 <- multi@nextNIter(1e3)  ## only one thread used... same as serial@nextNIter(1e3)library(microbenchmark) microbenchmark(multi@nextNIter(1e6), serial@nextNIter(1e6), times = 20) microbenchmark(multi@nextNIter(1e3), serial@nextNIter(1e3), times = 20)"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"expandGrid Iterator — expandGridIter","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridIterator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"expandGrid Iterator — expandGridIter","text":"","code":"a = expandGridIter(factor(state.abb), euro, islands) a@nextIter() #>   Var1    Var2  Var3 #> 1   AL 13.7603 11506 a@nextNIter(3) #>   Var1    Var2  Var3 #> 1   AL 13.7603  5500 #> 2   AL 13.7603 16988 #> 3   AL 13.7603  2968 a@front() #>   Var1    Var2  Var3 #> 1   AL 13.7603 11506 all_remaining = a@nextRemaining() dim(all_remaining) #> [1] 26399     3 a@summary() #> $description #> [1] \"Cartesian Product of the source (see the sourceVector method for more info)\" #>  #> $currentIndex #> [1] 26401 #>  #> $totalResults #> [1] 26400 #>  #> $totalRemaining #> [1] -1 #>  a@back() #>   Var1    Var2 Var3 #> 1   WY 200.482   82 a[[5]] #>   Var1    Var2 Var3 #> 1   AL 13.7603   16 a@summary() #> $description #> [1] \"Cartesian Product of the source (see the sourceVector method for more info)\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 26400 #>  #> $totalRemaining #> [1] 26395 #>  a[[c(1, 17, 3)]] #>   Var1    Var2  Var3 #> 1   AL 13.7603 11506 #> 2   AL 13.7603    13 #> 3   AL 13.7603 16988 a@summary() #> $description #> [1] \"Cartesian Product of the source (see the sourceVector method for more info)\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 26400 #>  #> $totalRemaining #> [1] 26395 #>"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample the Cartesian Product — expandGridSample","title":"Sample the Cartesian Product — expandGridSample","text":"Generate specific (lexicographically) random sample Cartesian product input vectors. Produce results parallel using nThreads arguments. GMP support allows exploration number results large.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample the Cartesian Product — expandGridSample","text":"","code":"expandGridSample(     ..., n = NULL, sampleVec = NULL, seed = NULL,     nThreads = NULL, namedSample = FALSE, return_df = FALSE )"},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample the Cartesian Product — expandGridSample","text":"... vectors, factors list containing . (See ?expand.grid). n Number results return. default NULL. sampleVec vector numbers representing lexicographical partition groups return. Accepts vectors class bigz well vectors characters seed Random seed initialization. default NULL. N.B. gmp library needed, parameter must set order reproducible results (E.g set.seed() effect cases). nThreads Specific number threads used. default NULL. namedSample Logical flag. TRUE, rownames corresponding lexicographical result, added returned matrix. default FALSE. return_df Logical flag force output data.frame. default FALSE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample the Cartesian Product — expandGridSample","text":"algorithms rely efficiently generating \\(n^{th}\\) lexicographical result.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample the Cartesian Product — expandGridSample","text":"input type, default expandGridSample produces matrix (data.frame otherwise). can ignored setting argument return_df = TRUE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample the Cartesian Product — expandGridSample","text":"Lexicographical order","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample the Cartesian Product — expandGridSample","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/expandGridSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample the Cartesian Product — expandGridSample","text":"","code":"## input vectors lst = list(factor(state.abb), euro, islands)  ## generate 10 random products expandGridSample(lst, n = 10, seed = 123) #>    Var1       Var2 Var3 #> 1    OK 1936.27000  306 #> 2    OK   40.33990  306 #> 3    WV    6.55957   13 #> 4    CO 1936.27000   73 #> 5    AR    6.55957   30 #> 6    WI 1936.27000   29 #> 7    CT    5.94573   25 #> 8    MN   13.76030   33 #> 9    GA   13.76030   84 #> 10   IL   40.33990  227  ## using sampleVec to generate specific results expandGridSample(lst, sampleVec = c(1, 100, 1e3)) #>   Var1     Var2  Var3 #> 1   AL 13.76030 11506 #> 2   AL  1.95583  2968 #> 3   AK  2.20371    16  all.equal(expandGridSample(lst, sampleVec = 1:expandGridCount(lst)),          expandGrid(lst)) #> [1] TRUE  ## Examples with enormous number of total results big_lst = Map(function(x, y) x:y, 8:33, 15:40) num = expandGridCount(big_lst) gmp::log2.bigz(num) #> [1] 78 ## [1] 78  first = gmp::urand.bigz(n = 1, size = 78, seed = 123) #> Seed initialisation mySamp = do.call(c, lapply(0:10, function(x) gmp::add.bigz(first, x)))  class(mySamp) #> [1] \"bigz\" ## [1] \"bigz\"  ## using the sampling function cartSamp = expandGridSample(big_lst, sampleVec = mySamp)  ## using the standard function cartGeneral = expandGrid(big_lst,                          lower = first,                          upper = gmp::add.bigz(first, 10))  identical(cartSamp, cartGeneral) #> [1] TRUE ## [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized Primality Test — isPrimeRcpp","title":"Vectorized Primality Test — isPrimeRcpp","text":"Implementation Miller-Rabin primality test. Based \"mp_prime_p\" function \"factorize.c\" source file found gmp library: https://gmplib.org.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized Primality Test — isPrimeRcpp","text":"","code":"isPrimeRcpp(v, namedVector = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized Primality Test — isPrimeRcpp","text":"v Vector integers numeric values. namedVector Logical flag. TRUE, named vector returned. default FALSE. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Vectorized Primality Test — isPrimeRcpp","text":"maximum value element \\(v\\) \\(2^{53} - 1\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vectorized Primality Test — isPrimeRcpp","text":"Miller-Rabin primality test probabilistic algorithm makes heavy use modular exponentiation. heart modular exponentiation ability accurately obtain remainder product two numbers \\(\\pmod p\\). gmp library, producing accurate calculations problems like trivial nature multiple precision data type. However, standard C++ afford luxury simply relying strict translation limited algorithm numbers less \\(\\sqrt 2^{63} - 1\\) (N.B. taking advantage signed 64-bit fixed width integer stdint library C++. confined base R, limit \\(\\sqrt 2^{53} - 1\\)). RcppAlgos::isPrimeRcpp gets around limitation divide conquer approach taking advantage properties arithmetic. problem trying solve can summarized follows: $$(x_1 * x_2) \\pmod p$$ Now, rewrite \\(x_2\\) \\(x_2 = y_1 + y_2 + \\dots + y_n\\), obtain: $$(x_1 * y_1) \\pmod p + (x_1 * y_2) \\pmod p + \\dots + (x_1 * y_n) \\pmod p$$ product \\((x_1 * y_j)\\) \\(j <= n\\) smaller original \\(x_1 * x_2\\). approach, now capable handling much larger numbers. Many details omitted clarity. depth examination topic see Accurate Modular Arithmetic Double Precision.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized Primality Test — isPrimeRcpp","text":"Returns named/unnamed logical vector. index TRUE, number index prime, otherwise number composite.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vectorized Primality Test — isPrimeRcpp","text":"MILLER-RABIN TEST Conrad, Keith. \"MILLER-RABIN TEST.\" https://www.math.uconn.edu/~kconrad/blurbs/ugradnumthy/millerrabin.pdf. 53-bit significand precision","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/isPrimeRcpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized Primality Test — isPrimeRcpp","text":"","code":"## check the primality of a single number isPrimeRcpp(100) #> [1] FALSE  ## check the primality of every number in a vector isPrimeRcpp(1:100) #>   [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE #>  [13]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE #>  [25] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE #>  [37]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE #>  [49] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE #>  [61]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE #>  [73]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE #>  [85] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #>  [97]  TRUE FALSE FALSE FALSE  set.seed(42) mySamp <- sample(10^13, 10)  ## return named vector for easy identification isPrimeRcpp(mySamp, namedVector = TRUE) #> 5053637821668 4945473353752  708576091668 3861127950937 5611435811813  #>         FALSE         FALSE         FALSE          TRUE         FALSE  #> 8651983869445 2062476240920 5651694855126 9421521179996 9639618136290  #>         FALSE         FALSE         FALSE         FALSE         FALSE   ## Using nThreads system.time(isPrimeRcpp(mySamp, nThreads = 2)) #>    user  system elapsed  #>       0       0       0"},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"Sieve generates number divisors every number bound1 bound2 (supplied) numbers bound1. equivalent applying divisor function (often written \\(\\sigma(x)\\)) every number given range.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"","code":"numDivisorSieve(bound1, bound2 = NULL, namedVector = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"bound1 Positive integer numeric value. bound2 Positive integer numeric value. namedVector Logical flag. TRUE, named vector returned. default FALSE. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"Simple efficient sieve calculates number divisors every number given range. function useful need calculate number divisors many numbers. algorithm benefits greatly fast integer division library 'libdivide'. following https://libdivide.com/: “libdivide allows replace expensive integer divides comparatively cheap multiplication bitshifts. Compilers usually , divisor known compile time. libdivide allows take advantage runtime. result integer division can become faster - lot faster.”","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"Returns named/unnamed integer vector","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"maximum allowed value \\(2^{53} - 1\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"Divisor function ridiculousfish (author libdivide) github.com/ridiculousfish/libdivide 53-bit significand precision","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/numDivisorSieve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Divisor Function to Every Element in a Range — numDivisorSieve","text":"","code":"## Generate some random data set.seed(8128) mySamp <- sample(10^6, 5*10^5)  ## Generate number of divisors for ## every number less than a million system.time(mySigmas <- numDivisorSieve(10^6)) #>    user  system elapsed  #>   0.008   0.000   0.008   ## Now use result in algorithm for (s in mySamp) {     sSig <- mySigmas[s]     ## Continue algorithm }  ## Generating number of divisors for every ## number in a range is no problem system.time(sigmaRange <- numDivisorSieve(10^13, 10^13 + 10^6)) #>    user  system elapsed  #>   0.024   0.001   0.024   ## Returning a named vector numDivisorSieve(10, 20, namedVector = TRUE) #> 10 11 12 13 14 15 16 17 18 19 20  #>  4  2  6  2  4  4  5  2  6  2  6  numDivisorSieve(10, namedVector = TRUE) #>  1  2  3  4  5  6  7  8  9 10  #>  1  2  2  3  2  4  2  4  3  4   ## Using nThreads system.time(numDivisorSieve(1e5, 2e5, nThreads = 2)) #>    user  system elapsed  #>   0.001   0.000   0.000"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsCount.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of Partitions/Compositions — partitionsCount","title":"Number of Partitions/Compositions — partitionsCount","text":"Calculate number partitions/compositions vector chosen \\(m\\) time without replacement. Additionally, functions can calculate number partitions multisets.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsCount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of Partitions/Compositions — partitionsCount","text":"","code":"partitionsCount(v, m = NULL, ...) compositionsCount(v, m = NULL, ...)  # Default S3 method partitionsCount(v, m = NULL, repetition = FALSE,                 freqs = NULL, target = NULL, ...) # Default S3 method compositionsCount(v, m = NULL, repetition = FALSE,                   freqs = NULL, target = NULL, weak = FALSE, ...)  # S3 method for class 'table' partitionsCount(v, m = NULL, target = NULL, ...) # S3 method for class 'table' compositionsCount(v, m = NULL, target = NULL, weak = FALSE, ...)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsCount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of Partitions/Compositions — partitionsCount","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. integer numeric vectors accepted. m Width partition. m = NULL, length determined partitioning case (e.g. generating distinct partitions \\(n\\), width equal smallest \\(m\\) sum(1:m) >= n). ... arguments passed methods. repetition Logical value indicating whether partitions/compositions without repetition. default FALSE. freqs vector frequencies used producing partitions multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. target Number partitioned. NULL, max(v) used. weak (Compositions ) Logical flag indicating whether allow terms sequence zero.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsCount.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of Partitions/Compositions — partitionsCount","text":"numerical value representing total number partitions/compositions.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsCount.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Number of Partitions/Compositions — partitionsCount","text":"number results exceeds \\(2^{53} - 1\\), number class bigz returned.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsCount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of Partitions/Compositions — partitionsCount","text":"","code":"## Same interface as partitionsGeneral partitionsCount(25, 5) #> [1] 30 compositionsCount(25, 5, TRUE) #> [1] 10626 partitionsCount(15, 7, TRUE) #> [1] 21 partitionsCount(25, 5, freqs = rep(2, 25)) #> [1] 148  ## Return object of class 'bigz' partitionsCount(2500, 15, TRUE) #> Big Integer ('bigz') : #> [1] 4188807783906550542066742 compositionsCount(2500, 15, TRUE) #> Big Integer ('bigz') : #> [1] 4097094997743241086270928785678827376"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Partitions/Compositions — partitionsGeneral","title":"Generate Partitions/Compositions — partitionsGeneral","text":"algorithms RcppAlgos go beyond traditional integer partition algorithms can tackle wide variety cases.  Efficient algorithms partitioning numbers various constraints: Standard (repetition) Distinct Restricted part specific multiplicity (.e. using freqs multisets). Arbitrary target source vector (e.g. partitionsGeneral(sample(1000, 20), 10, TRUE, target = 5000)) Produce results parallel using nThreads arguments. Alternatively, arguments lower upper make possible generate partitions/compositions chunks allowing parallelization via parallel package. GMP support allows exploration cases number partitions/compositions large. output lexicographical order.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Partitions/Compositions — partitionsGeneral","text":"","code":"partitionsGeneral(v, m = NULL, ...) compositionsGeneral(v, m = NULL, ...)  # Default S3 method partitionsGeneral(     v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL,     lower = NULL, upper = NULL, nThreads = NULL, tolerance = NULL, ... ) # Default S3 method compositionsGeneral(     v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL, weak = FALSE,     lower = NULL, upper = NULL, nThreads = NULL, tolerance = NULL, ... )  # S3 method for class 'table' partitionsGeneral(     v, m = NULL, target = NULL, lower = NULL,     upper = NULL, nThreads = NULL, tolerance = NULL, ... ) # S3 method for class 'table' compositionsGeneral(     v, m = NULL, target = NULL, weak = FALSE, lower = NULL,     upper = NULL, nThreads = NULL, tolerance = NULL, ... )"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Partitions/Compositions — partitionsGeneral","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. integer numeric vectors accepted. m Width partition. m = NULL, length determined partitioning case (e.g. generating distinct partitions \\(n\\), width equal smallest \\(m\\) sum(1:m) >= n). ... arguments passed methods. repetition Logical value indicating whether partitions/compositions without repetition. default FALSE. freqs vector frequencies used producing partitions multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. lower lower bound. Partitions/compositions generated lexicographically, thus utilizing argument determine specific partition start generating (e.g. partitionsGeneral(15, 3, lower = 6) equivalent partitionsGeneral(15, 3)[6:partitionsCount(15, 3), ]). argument along upper useful generating partitions/compositions chunks allowing easy parallelization. upper upper bound. Similar lower, however parameter allows user stop generation specific partition (e.g. partitionsGeneral(15, 3, upper = 5) equivalent partitionsGeneral(15, 3)[1:5, ]) target Number partitioned. NULL, max(v) used. weak (Compositions ) Logical flag indicating whether allow terms sequence zero. nThreads Specific number threads used. default NULL. tolerance numeric value greater equal zero. parameter utilized constraint applied numeric vector. default value 0 can determined whole values utilized, otherwise sqrt(.Machine$double.eps) approximately \\(1.5e-8\\). N.B. input vector type integer, parameter ignored strict equality enforced.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Partitions/Compositions — partitionsGeneral","text":"matrix returned row containing vector length \\(m\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Partitions/Compositions — partitionsGeneral","text":"nThreads ignored following cases (.e. Generating \\(n^{th}\\) partition cases currently unavailable): standard multisets. zero element non-trivial multiplicity, multithreading possible (e.g. partitionsGeneral(0:100, freqs = c(100, rep(1, 100)), nThreads = 4)). source vector isomorphic 1:length(v) (e.g. v = c(1, 4, 6, 7, 8)). maximum number partitions/compositions can generated one time \\(2^{31} - 1\\). Utilizing lower upper makes possible generate additional partitions/compositions.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Partitions/Compositions — partitionsGeneral","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Partitions/Compositions — partitionsGeneral","text":"Lexicographical Order Subset Sum Problem Partition (number theory) Composition (combinatorics))","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsGeneral.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Partitions/Compositions — partitionsGeneral","text":"","code":"partitionsGeneral(1) #>      [,1] #> [1,]    1 partitionsGeneral(-1:0, 1) #>      [,1] #> [1,]    0 partitionsGeneral(-1:0, 1, target = -1) #>      [,1] #> [1,]   -1 partitionsGeneral(20, 5) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    2    3    4   10 #> [2,]    1    2    3    5    9 #> [3,]    1    2    3    6    8 #> [4,]    1    2    4    5    8 #> [5,]    1    2    4    6    7 #> [6,]    1    3    4    5    7 #> [7,]    2    3    4    5    6 partitionsGeneral(20, 5, repetition = TRUE) #>       [,1] [,2] [,3] [,4] [,5] #>  [1,]    1    1    1    1   16 #>  [2,]    1    1    1    2   15 #>  [3,]    1    1    1    3   14 #>  [4,]    1    1    1    4   13 #>  [5,]    1    1    1    5   12 #>  [6,]    1    1    1    6   11 #>  [7,]    1    1    1    7   10 #>  [8,]    1    1    1    8    9 #>  [9,]    1    1    2    2   14 #> [10,]    1    1    2    3   13 #> [11,]    1    1    2    4   12 #> [12,]    1    1    2    5   11 #> [13,]    1    1    2    6   10 #> [14,]    1    1    2    7    9 #> [15,]    1    1    2    8    8 #> [16,]    1    1    3    3   12 #> [17,]    1    1    3    4   11 #> [18,]    1    1    3    5   10 #> [19,]    1    1    3    6    9 #> [20,]    1    1    3    7    8 #> [21,]    1    1    4    4   10 #> [22,]    1    1    4    5    9 #> [23,]    1    1    4    6    8 #> [24,]    1    1    4    7    7 #> [25,]    1    1    5    5    8 #> [26,]    1    1    5    6    7 #> [27,]    1    1    6    6    6 #> [28,]    1    2    2    2   13 #> [29,]    1    2    2    3   12 #> [30,]    1    2    2    4   11 #> [31,]    1    2    2    5   10 #> [32,]    1    2    2    6    9 #> [33,]    1    2    2    7    8 #> [34,]    1    2    3    3   11 #> [35,]    1    2    3    4   10 #> [36,]    1    2    3    5    9 #> [37,]    1    2    3    6    8 #> [38,]    1    2    3    7    7 #> [39,]    1    2    4    4    9 #> [40,]    1    2    4    5    8 #> [41,]    1    2    4    6    7 #> [42,]    1    2    5    5    7 #> [43,]    1    2    5    6    6 #> [44,]    1    3    3    3   10 #> [45,]    1    3    3    4    9 #> [46,]    1    3    3    5    8 #> [47,]    1    3    3    6    7 #> [48,]    1    3    4    4    8 #> [49,]    1    3    4    5    7 #> [50,]    1    3    4    6    6 #> [51,]    1    3    5    5    6 #> [52,]    1    4    4    4    7 #> [53,]    1    4    4    5    6 #> [54,]    1    4    5    5    5 #> [55,]    2    2    2    2   12 #> [56,]    2    2    2    3   11 #> [57,]    2    2    2    4   10 #> [58,]    2    2    2    5    9 #> [59,]    2    2    2    6    8 #> [60,]    2    2    2    7    7 #> [61,]    2    2    3    3   10 #> [62,]    2    2    3    4    9 #> [63,]    2    2    3    5    8 #> [64,]    2    2    3    6    7 #> [65,]    2    2    4    4    8 #> [66,]    2    2    4    5    7 #> [67,]    2    2    4    6    6 #> [68,]    2    2    5    5    6 #> [69,]    2    3    3    3    9 #> [70,]    2    3    3    4    8 #> [71,]    2    3    3    5    7 #> [72,]    2    3    3    6    6 #> [73,]    2    3    4    4    7 #> [74,]    2    3    4    5    6 #> [75,]    2    3    5    5    5 #> [76,]    2    4    4    4    6 #> [77,]    2    4    4    5    5 #> [78,]    3    3    3    3    8 #> [79,]    3    3    3    4    7 #> [80,]    3    3    3    5    6 #> [81,]    3    3    4    4    6 #> [82,]    3    3    4    5    5 #> [83,]    3    4    4    4    5 #> [84,]    4    4    4    4    4 partitionsGeneral(20, 5, freqs = rep(1:4, 5)) #>       [,1] [,2] [,3] [,4] [,5] #>  [1,]    1    2    2    3   12 #>  [2,]    1    2    2    4   11 #>  [3,]    1    2    2    5   10 #>  [4,]    1    2    2    6    9 #>  [5,]    1    2    2    7    8 #>  [6,]    1    2    3    3   11 #>  [7,]    1    2    3    4   10 #>  [8,]    1    2    3    5    9 #>  [9,]    1    2    3    6    8 #> [10,]    1    2    3    7    7 #> [11,]    1    2    4    4    9 #> [12,]    1    2    4    5    8 #> [13,]    1    2    4    6    7 #> [14,]    1    2    5    6    6 #> [15,]    1    3    3    3   10 #> [16,]    1    3    3    4    9 #> [17,]    1    3    3    5    8 #> [18,]    1    3    3    6    7 #> [19,]    1    3    4    4    8 #> [20,]    1    3    4    5    7 #> [21,]    1    3    4    6    6 #> [22,]    1    4    4    4    7 #> [23,]    1    4    4    5    6 #> [24,]    2    2    3    3   10 #> [25,]    2    2    3    4    9 #> [26,]    2    2    3    5    8 #> [27,]    2    2    3    6    7 #> [28,]    2    2    4    4    8 #> [29,]    2    2    4    5    7 #> [30,]    2    2    4    6    6 #> [31,]    2    3    3    3    9 #> [32,]    2    3    3    4    8 #> [33,]    2    3    3    5    7 #> [34,]    2    3    3    6    6 #> [35,]    2    3    4    4    7 #> [36,]    2    3    4    5    6 #> [37,]    2    4    4    4    6 #> [38,]    3    3    3    4    7 #> [39,]    3    3    3    5    6 #> [40,]    3    3    4    4    6 #> [41,]    3    4    4    4    5 partitionsGeneral(20, 5, TRUE, target = 80) #>        [,1] [,2] [,3] [,4] [,5] #>   [1,]    1   19   20   20   20 #>   [2,]    2   18   20   20   20 #>   [3,]    2   19   19   20   20 #>   [4,]    3   17   20   20   20 #>   [5,]    3   18   19   20   20 #>   [6,]    3   19   19   19   20 #>   [7,]    4   16   20   20   20 #>   [8,]    4   17   19   20   20 #>   [9,]    4   18   18   20   20 #>  [10,]    4   18   19   19   20 #>  [11,]    4   19   19   19   19 #>  [12,]    5   15   20   20   20 #>  [13,]    5   16   19   20   20 #>  [14,]    5   17   18   20   20 #>  [15,]    5   17   19   19   20 #>  [16,]    5   18   18   19   20 #>  [17,]    5   18   19   19   19 #>  [18,]    6   14   20   20   20 #>  [19,]    6   15   19   20   20 #>  [20,]    6   16   18   20   20 #>  [21,]    6   16   19   19   20 #>  [22,]    6   17   17   20   20 #>  [23,]    6   17   18   19   20 #>  [24,]    6   17   19   19   19 #>  [25,]    6   18   18   18   20 #>  [26,]    6   18   18   19   19 #>  [27,]    7   13   20   20   20 #>  [28,]    7   14   19   20   20 #>  [29,]    7   15   18   20   20 #>  [30,]    7   15   19   19   20 #>  [31,]    7   16   17   20   20 #>  [32,]    7   16   18   19   20 #>  [33,]    7   16   19   19   19 #>  [34,]    7   17   17   19   20 #>  [35,]    7   17   18   18   20 #>  [36,]    7   17   18   19   19 #>  [37,]    7   18   18   18   19 #>  [38,]    8   12   20   20   20 #>  [39,]    8   13   19   20   20 #>  [40,]    8   14   18   20   20 #>  [41,]    8   14   19   19   20 #>  [42,]    8   15   17   20   20 #>  [43,]    8   15   18   19   20 #>  [44,]    8   15   19   19   19 #>  [45,]    8   16   16   20   20 #>  [46,]    8   16   17   19   20 #>  [47,]    8   16   18   18   20 #>  [48,]    8   16   18   19   19 #>  [49,]    8   17   17   18   20 #>  [50,]    8   17   17   19   19 #>  [51,]    8   17   18   18   19 #>  [52,]    8   18   18   18   18 #>  [53,]    9   11   20   20   20 #>  [54,]    9   12   19   20   20 #>  [55,]    9   13   18   20   20 #>  [56,]    9   13   19   19   20 #>  [57,]    9   14   17   20   20 #>  [58,]    9   14   18   19   20 #>  [59,]    9   14   19   19   19 #>  [60,]    9   15   16   20   20 #>  [61,]    9   15   17   19   20 #>  [62,]    9   15   18   18   20 #>  [63,]    9   15   18   19   19 #>  [64,]    9   16   16   19   20 #>  [65,]    9   16   17   18   20 #>  [66,]    9   16   17   19   19 #>  [67,]    9   16   18   18   19 #>  [68,]    9   17   17   17   20 #>  [69,]    9   17   17   18   19 #>  [70,]    9   17   18   18   18 #>  [71,]   10   10   20   20   20 #>  [72,]   10   11   19   20   20 #>  [73,]   10   12   18   20   20 #>  [74,]   10   12   19   19   20 #>  [75,]   10   13   17   20   20 #>  [76,]   10   13   18   19   20 #>  [77,]   10   13   19   19   19 #>  [78,]   10   14   16   20   20 #>  [79,]   10   14   17   19   20 #>  [80,]   10   14   18   18   20 #>  [81,]   10   14   18   19   19 #>  [82,]   10   15   15   20   20 #>  [83,]   10   15   16   19   20 #>  [84,]   10   15   17   18   20 #>  [85,]   10   15   17   19   19 #>  [86,]   10   15   18   18   19 #>  [87,]   10   16   16   18   20 #>  [88,]   10   16   16   19   19 #>  [89,]   10   16   17   17   20 #>  [90,]   10   16   17   18   19 #>  [91,]   10   16   18   18   18 #>  [92,]   10   17   17   17   19 #>  [93,]   10   17   17   18   18 #>  [94,]   11   11   18   20   20 #>  [95,]   11   11   19   19   20 #>  [96,]   11   12   17   20   20 #>  [97,]   11   12   18   19   20 #>  [98,]   11   12   19   19   19 #>  [99,]   11   13   16   20   20 #> [100,]   11   13   17   19   20 #> [101,]   11   13   18   18   20 #> [102,]   11   13   18   19   19 #> [103,]   11   14   15   20   20 #> [104,]   11   14   16   19   20 #> [105,]   11   14   17   18   20 #> [106,]   11   14   17   19   19 #> [107,]   11   14   18   18   19 #> [108,]   11   15   15   19   20 #> [109,]   11   15   16   18   20 #> [110,]   11   15   16   19   19 #> [111,]   11   15   17   17   20 #> [112,]   11   15   17   18   19 #> [113,]   11   15   18   18   18 #> [114,]   11   16   16   17   20 #> [115,]   11   16   16   18   19 #> [116,]   11   16   17   17   19 #> [117,]   11   16   17   18   18 #> [118,]   11   17   17   17   18 #> [119,]   12   12   16   20   20 #> [120,]   12   12   17   19   20 #> [121,]   12   12   18   18   20 #> [122,]   12   12   18   19   19 #> [123,]   12   13   15   20   20 #> [124,]   12   13   16   19   20 #> [125,]   12   13   17   18   20 #> [126,]   12   13   17   19   19 #> [127,]   12   13   18   18   19 #> [128,]   12   14   14   20   20 #> [129,]   12   14   15   19   20 #> [130,]   12   14   16   18   20 #> [131,]   12   14   16   19   19 #> [132,]   12   14   17   17   20 #> [133,]   12   14   17   18   19 #> [134,]   12   14   18   18   18 #> [135,]   12   15   15   18   20 #> [136,]   12   15   15   19   19 #> [137,]   12   15   16   17   20 #> [138,]   12   15   16   18   19 #> [139,]   12   15   17   17   19 #> [140,]   12   15   17   18   18 #> [141,]   12   16   16   16   20 #> [142,]   12   16   16   17   19 #> [143,]   12   16   16   18   18 #> [144,]   12   16   17   17   18 #> [145,]   12   17   17   17   17 #> [146,]   13   13   14   20   20 #> [147,]   13   13   15   19   20 #> [148,]   13   13   16   18   20 #> [149,]   13   13   16   19   19 #> [150,]   13   13   17   17   20 #> [151,]   13   13   17   18   19 #> [152,]   13   13   18   18   18 #> [153,]   13   14   14   19   20 #> [154,]   13   14   15   18   20 #> [155,]   13   14   15   19   19 #> [156,]   13   14   16   17   20 #> [157,]   13   14   16   18   19 #> [158,]   13   14   17   17   19 #> [159,]   13   14   17   18   18 #> [160,]   13   15   15   17   20 #> [161,]   13   15   15   18   19 #> [162,]   13   15   16   16   20 #> [163,]   13   15   16   17   19 #> [164,]   13   15   16   18   18 #> [165,]   13   15   17   17   18 #> [166,]   13   16   16   16   19 #> [167,]   13   16   16   17   18 #> [168,]   13   16   17   17   17 #> [169,]   14   14   14   18   20 #> [170,]   14   14   14   19   19 #> [171,]   14   14   15   17   20 #> [172,]   14   14   15   18   19 #> [173,]   14   14   16   16   20 #> [174,]   14   14   16   17   19 #> [175,]   14   14   16   18   18 #> [176,]   14   14   17   17   18 #> [177,]   14   15   15   16   20 #> [178,]   14   15   15   17   19 #> [179,]   14   15   15   18   18 #> [180,]   14   15   16   16   19 #> [181,]   14   15   16   17   18 #> [182,]   14   15   17   17   17 #> [183,]   14   16   16   16   18 #> [184,]   14   16   16   17   17 #> [185,]   15   15   15   15   20 #> [186,]   15   15   15   16   19 #> [187,]   15   15   15   17   18 #> [188,]   15   15   16   16   18 #> [189,]   15   15   16   17   17 #> [190,]   15   16   16   16   17 #> [191,]   16   16   16   16   16 partitionsGeneral(0:10, repetition = TRUE) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    0    0    0    0    0    0    0    0    0    10 #>  [2,]    0    0    0    0    0    0    0    0    1     9 #>  [3,]    0    0    0    0    0    0    0    0    2     8 #>  [4,]    0    0    0    0    0    0    0    0    3     7 #>  [5,]    0    0    0    0    0    0    0    0    4     6 #>  [6,]    0    0    0    0    0    0    0    0    5     5 #>  [7,]    0    0    0    0    0    0    0    1    1     8 #>  [8,]    0    0    0    0    0    0    0    1    2     7 #>  [9,]    0    0    0    0    0    0    0    1    3     6 #> [10,]    0    0    0    0    0    0    0    1    4     5 #> [11,]    0    0    0    0    0    0    0    2    2     6 #> [12,]    0    0    0    0    0    0    0    2    3     5 #> [13,]    0    0    0    0    0    0    0    2    4     4 #> [14,]    0    0    0    0    0    0    0    3    3     4 #> [15,]    0    0    0    0    0    0    1    1    1     7 #> [16,]    0    0    0    0    0    0    1    1    2     6 #> [17,]    0    0    0    0    0    0    1    1    3     5 #> [18,]    0    0    0    0    0    0    1    1    4     4 #> [19,]    0    0    0    0    0    0    1    2    2     5 #> [20,]    0    0    0    0    0    0    1    2    3     4 #> [21,]    0    0    0    0    0    0    1    3    3     3 #> [22,]    0    0    0    0    0    0    2    2    2     4 #> [23,]    0    0    0    0    0    0    2    2    3     3 #> [24,]    0    0    0    0    0    1    1    1    1     6 #> [25,]    0    0    0    0    0    1    1    1    2     5 #> [26,]    0    0    0    0    0    1    1    1    3     4 #> [27,]    0    0    0    0    0    1    1    2    2     4 #> [28,]    0    0    0    0    0    1    1    2    3     3 #> [29,]    0    0    0    0    0    1    2    2    2     3 #> [30,]    0    0    0    0    0    2    2    2    2     2 #> [31,]    0    0    0    0    1    1    1    1    1     5 #> [32,]    0    0    0    0    1    1    1    1    2     4 #> [33,]    0    0    0    0    1    1    1    1    3     3 #> [34,]    0    0    0    0    1    1    1    2    2     3 #> [35,]    0    0    0    0    1    1    2    2    2     2 #> [36,]    0    0    0    1    1    1    1    1    1     4 #> [37,]    0    0    0    1    1    1    1    1    2     3 #> [38,]    0    0    0    1    1    1    1    2    2     2 #> [39,]    0    0    1    1    1    1    1    1    1     3 #> [40,]    0    0    1    1    1    1    1    1    2     2 #> [41,]    0    1    1    1    1    1    1    1    1     2 #> [42,]    1    1    1    1    1    1    1    1    1     1 partitionsGeneral(seq(2L, 500L, 23L), 5, target = 1804) #>        [,1] [,2] [,3] [,4] [,5] #>   [1,]    2  416  439  462  485 #>   [2,]   25  393  439  462  485 #>   [3,]   48  370  439  462  485 #>   [4,]   48  393  416  462  485 #>   [5,]   71  347  439  462  485 #>   [6,]   71  370  416  462  485 #>   [7,]   71  393  416  439  485 #>   [8,]   94  324  439  462  485 #>   [9,]   94  347  416  462  485 #>  [10,]   94  370  393  462  485 #>  [11,]   94  370  416  439  485 #>  [12,]   94  393  416  439  462 #>  [13,]  117  301  439  462  485 #>  [14,]  117  324  416  462  485 #>  [15,]  117  347  393  462  485 #>  [16,]  117  347  416  439  485 #>  [17,]  117  370  393  439  485 #>  [18,]  117  370  416  439  462 #>  [19,]  140  278  439  462  485 #>  [20,]  140  301  416  462  485 #>  [21,]  140  324  393  462  485 #>  [22,]  140  324  416  439  485 #>  [23,]  140  347  370  462  485 #>  [24,]  140  347  393  439  485 #>  [25,]  140  347  416  439  462 #>  [26,]  140  370  393  416  485 #>  [27,]  140  370  393  439  462 #>  [28,]  163  255  439  462  485 #>  [29,]  163  278  416  462  485 #>  [30,]  163  301  393  462  485 #>  [31,]  163  301  416  439  485 #>  [32,]  163  324  370  462  485 #>  [33,]  163  324  393  439  485 #>  [34,]  163  324  416  439  462 #>  [35,]  163  347  370  439  485 #>  [36,]  163  347  393  416  485 #>  [37,]  163  347  393  439  462 #>  [38,]  163  370  393  416  462 #>  [39,]  186  232  439  462  485 #>  [40,]  186  255  416  462  485 #>  [41,]  186  278  393  462  485 #>  [42,]  186  278  416  439  485 #>  [43,]  186  301  370  462  485 #>  [44,]  186  301  393  439  485 #>  [45,]  186  301  416  439  462 #>  [46,]  186  324  347  462  485 #>  [47,]  186  324  370  439  485 #>  [48,]  186  324  393  416  485 #>  [49,]  186  324  393  439  462 #>  [50,]  186  347  370  416  485 #>  [51,]  186  347  370  439  462 #>  [52,]  186  347  393  416  462 #>  [53,]  186  370  393  416  439 #>  [54,]  209  232  416  462  485 #>  [55,]  209  255  393  462  485 #>  [56,]  209  255  416  439  485 #>  [57,]  209  278  370  462  485 #>  [58,]  209  278  393  439  485 #>  [59,]  209  278  416  439  462 #>  [60,]  209  301  347  462  485 #>  [61,]  209  301  370  439  485 #>  [62,]  209  301  393  416  485 #>  [63,]  209  301  393  439  462 #>  [64,]  209  324  347  439  485 #>  [65,]  209  324  370  416  485 #>  [66,]  209  324  370  439  462 #>  [67,]  209  324  393  416  462 #>  [68,]  209  347  370  393  485 #>  [69,]  209  347  370  416  462 #>  [70,]  209  347  393  416  439 #>  [71,]  232  255  370  462  485 #>  [72,]  232  255  393  439  485 #>  [73,]  232  255  416  439  462 #>  [74,]  232  278  347  462  485 #>  [75,]  232  278  370  439  485 #>  [76,]  232  278  393  416  485 #>  [77,]  232  278  393  439  462 #>  [78,]  232  301  324  462  485 #>  [79,]  232  301  347  439  485 #>  [80,]  232  301  370  416  485 #>  [81,]  232  301  370  439  462 #>  [82,]  232  301  393  416  462 #>  [83,]  232  324  347  416  485 #>  [84,]  232  324  347  439  462 #>  [85,]  232  324  370  393  485 #>  [86,]  232  324  370  416  462 #>  [87,]  232  324  393  416  439 #>  [88,]  232  347  370  393  462 #>  [89,]  232  347  370  416  439 #>  [90,]  255  278  324  462  485 #>  [91,]  255  278  347  439  485 #>  [92,]  255  278  370  416  485 #>  [93,]  255  278  370  439  462 #>  [94,]  255  278  393  416  462 #>  [95,]  255  301  324  439  485 #>  [96,]  255  301  347  416  485 #>  [97,]  255  301  347  439  462 #>  [98,]  255  301  370  393  485 #>  [99,]  255  301  370  416  462 #> [100,]  255  301  393  416  439 #> [101,]  255  324  347  393  485 #> [102,]  255  324  347  416  462 #> [103,]  255  324  370  393  462 #> [104,]  255  324  370  416  439 #> [105,]  255  347  370  393  439 #> [106,]  278  301  324  416  485 #> [107,]  278  301  324  439  462 #> [108,]  278  301  347  393  485 #> [109,]  278  301  347  416  462 #> [110,]  278  301  370  393  462 #> [111,]  278  301  370  416  439 #> [112,]  278  324  347  370  485 #> [113,]  278  324  347  393  462 #> [114,]  278  324  347  416  439 #> [115,]  278  324  370  393  439 #> [116,]  278  347  370  393  416 #> [117,]  301  324  347  370  462 #> [118,]  301  324  347  393  439 #> [119,]  301  324  370  393  416  compositionsGeneral(0:10, 5, repetition = TRUE) #>        [,1] [,2] [,3] [,4] [,5] #>   [1,]    0    0    0    0   10 #>   [2,]    0    0    0    1    9 #>   [3,]    0    0    0    2    8 #>   [4,]    0    0    0    3    7 #>   [5,]    0    0    0    4    6 #>   [6,]    0    0    0    5    5 #>   [7,]    0    0    0    6    4 #>   [8,]    0    0    0    7    3 #>   [9,]    0    0    0    8    2 #>  [10,]    0    0    0    9    1 #>  [11,]    0    0    1    1    8 #>  [12,]    0    0    1    2    7 #>  [13,]    0    0    1    3    6 #>  [14,]    0    0    1    4    5 #>  [15,]    0    0    1    5    4 #>  [16,]    0    0    1    6    3 #>  [17,]    0    0    1    7    2 #>  [18,]    0    0    1    8    1 #>  [19,]    0    0    2    1    7 #>  [20,]    0    0    2    2    6 #>  [21,]    0    0    2    3    5 #>  [22,]    0    0    2    4    4 #>  [23,]    0    0    2    5    3 #>  [24,]    0    0    2    6    2 #>  [25,]    0    0    2    7    1 #>  [26,]    0    0    3    1    6 #>  [27,]    0    0    3    2    5 #>  [28,]    0    0    3    3    4 #>  [29,]    0    0    3    4    3 #>  [30,]    0    0    3    5    2 #>  [31,]    0    0    3    6    1 #>  [32,]    0    0    4    1    5 #>  [33,]    0    0    4    2    4 #>  [34,]    0    0    4    3    3 #>  [35,]    0    0    4    4    2 #>  [36,]    0    0    4    5    1 #>  [37,]    0    0    5    1    4 #>  [38,]    0    0    5    2    3 #>  [39,]    0    0    5    3    2 #>  [40,]    0    0    5    4    1 #>  [41,]    0    0    6    1    3 #>  [42,]    0    0    6    2    2 #>  [43,]    0    0    6    3    1 #>  [44,]    0    0    7    1    2 #>  [45,]    0    0    7    2    1 #>  [46,]    0    0    8    1    1 #>  [47,]    0    1    1    1    7 #>  [48,]    0    1    1    2    6 #>  [49,]    0    1    1    3    5 #>  [50,]    0    1    1    4    4 #>  [51,]    0    1    1    5    3 #>  [52,]    0    1    1    6    2 #>  [53,]    0    1    1    7    1 #>  [54,]    0    1    2    1    6 #>  [55,]    0    1    2    2    5 #>  [56,]    0    1    2    3    4 #>  [57,]    0    1    2    4    3 #>  [58,]    0    1    2    5    2 #>  [59,]    0    1    2    6    1 #>  [60,]    0    1    3    1    5 #>  [61,]    0    1    3    2    4 #>  [62,]    0    1    3    3    3 #>  [63,]    0    1    3    4    2 #>  [64,]    0    1    3    5    1 #>  [65,]    0    1    4    1    4 #>  [66,]    0    1    4    2    3 #>  [67,]    0    1    4    3    2 #>  [68,]    0    1    4    4    1 #>  [69,]    0    1    5    1    3 #>  [70,]    0    1    5    2    2 #>  [71,]    0    1    5    3    1 #>  [72,]    0    1    6    1    2 #>  [73,]    0    1    6    2    1 #>  [74,]    0    1    7    1    1 #>  [75,]    0    2    1    1    6 #>  [76,]    0    2    1    2    5 #>  [77,]    0    2    1    3    4 #>  [78,]    0    2    1    4    3 #>  [79,]    0    2    1    5    2 #>  [80,]    0    2    1    6    1 #>  [81,]    0    2    2    1    5 #>  [82,]    0    2    2    2    4 #>  [83,]    0    2    2    3    3 #>  [84,]    0    2    2    4    2 #>  [85,]    0    2    2    5    1 #>  [86,]    0    2    3    1    4 #>  [87,]    0    2    3    2    3 #>  [88,]    0    2    3    3    2 #>  [89,]    0    2    3    4    1 #>  [90,]    0    2    4    1    3 #>  [91,]    0    2    4    2    2 #>  [92,]    0    2    4    3    1 #>  [93,]    0    2    5    1    2 #>  [94,]    0    2    5    2    1 #>  [95,]    0    2    6    1    1 #>  [96,]    0    3    1    1    5 #>  [97,]    0    3    1    2    4 #>  [98,]    0    3    1    3    3 #>  [99,]    0    3    1    4    2 #> [100,]    0    3    1    5    1 #> [101,]    0    3    2    1    4 #> [102,]    0    3    2    2    3 #> [103,]    0    3    2    3    2 #> [104,]    0    3    2    4    1 #> [105,]    0    3    3    1    3 #> [106,]    0    3    3    2    2 #> [107,]    0    3    3    3    1 #> [108,]    0    3    4    1    2 #> [109,]    0    3    4    2    1 #> [110,]    0    3    5    1    1 #> [111,]    0    4    1    1    4 #> [112,]    0    4    1    2    3 #> [113,]    0    4    1    3    2 #> [114,]    0    4    1    4    1 #> [115,]    0    4    2    1    3 #> [116,]    0    4    2    2    2 #> [117,]    0    4    2    3    1 #> [118,]    0    4    3    1    2 #> [119,]    0    4    3    2    1 #> [120,]    0    4    4    1    1 #> [121,]    0    5    1    1    3 #> [122,]    0    5    1    2    2 #> [123,]    0    5    1    3    1 #> [124,]    0    5    2    1    2 #> [125,]    0    5    2    2    1 #> [126,]    0    5    3    1    1 #> [127,]    0    6    1    1    2 #> [128,]    0    6    1    2    1 #> [129,]    0    6    2    1    1 #> [130,]    0    7    1    1    1 #> [131,]    1    1    1    1    6 #> [132,]    1    1    1    2    5 #> [133,]    1    1    1    3    4 #> [134,]    1    1    1    4    3 #> [135,]    1    1    1    5    2 #> [136,]    1    1    1    6    1 #> [137,]    1    1    2    1    5 #> [138,]    1    1    2    2    4 #> [139,]    1    1    2    3    3 #> [140,]    1    1    2    4    2 #> [141,]    1    1    2    5    1 #> [142,]    1    1    3    1    4 #> [143,]    1    1    3    2    3 #> [144,]    1    1    3    3    2 #> [145,]    1    1    3    4    1 #> [146,]    1    1    4    1    3 #> [147,]    1    1    4    2    2 #> [148,]    1    1    4    3    1 #> [149,]    1    1    5    1    2 #> [150,]    1    1    5    2    1 #> [151,]    1    1    6    1    1 #> [152,]    1    2    1    1    5 #> [153,]    1    2    1    2    4 #> [154,]    1    2    1    3    3 #> [155,]    1    2    1    4    2 #> [156,]    1    2    1    5    1 #> [157,]    1    2    2    1    4 #> [158,]    1    2    2    2    3 #> [159,]    1    2    2    3    2 #> [160,]    1    2    2    4    1 #> [161,]    1    2    3    1    3 #> [162,]    1    2    3    2    2 #> [163,]    1    2    3    3    1 #> [164,]    1    2    4    1    2 #> [165,]    1    2    4    2    1 #> [166,]    1    2    5    1    1 #> [167,]    1    3    1    1    4 #> [168,]    1    3    1    2    3 #> [169,]    1    3    1    3    2 #> [170,]    1    3    1    4    1 #> [171,]    1    3    2    1    3 #> [172,]    1    3    2    2    2 #> [173,]    1    3    2    3    1 #> [174,]    1    3    3    1    2 #> [175,]    1    3    3    2    1 #> [176,]    1    3    4    1    1 #> [177,]    1    4    1    1    3 #> [178,]    1    4    1    2    2 #> [179,]    1    4    1    3    1 #> [180,]    1    4    2    1    2 #> [181,]    1    4    2    2    1 #> [182,]    1    4    3    1    1 #> [183,]    1    5    1    1    2 #> [184,]    1    5    1    2    1 #> [185,]    1    5    2    1    1 #> [186,]    1    6    1    1    1 #> [187,]    2    1    1    1    5 #> [188,]    2    1    1    2    4 #> [189,]    2    1    1    3    3 #> [190,]    2    1    1    4    2 #> [191,]    2    1    1    5    1 #> [192,]    2    1    2    1    4 #> [193,]    2    1    2    2    3 #> [194,]    2    1    2    3    2 #> [195,]    2    1    2    4    1 #> [196,]    2    1    3    1    3 #> [197,]    2    1    3    2    2 #> [198,]    2    1    3    3    1 #> [199,]    2    1    4    1    2 #> [200,]    2    1    4    2    1 #> [201,]    2    1    5    1    1 #> [202,]    2    2    1    1    4 #> [203,]    2    2    1    2    3 #> [204,]    2    2    1    3    2 #> [205,]    2    2    1    4    1 #> [206,]    2    2    2    1    3 #> [207,]    2    2    2    2    2 #> [208,]    2    2    2    3    1 #> [209,]    2    2    3    1    2 #> [210,]    2    2    3    2    1 #> [211,]    2    2    4    1    1 #> [212,]    2    3    1    1    3 #> [213,]    2    3    1    2    2 #> [214,]    2    3    1    3    1 #> [215,]    2    3    2    1    2 #> [216,]    2    3    2    2    1 #> [217,]    2    3    3    1    1 #> [218,]    2    4    1    1    2 #> [219,]    2    4    1    2    1 #> [220,]    2    4    2    1    1 #> [221,]    2    5    1    1    1 #> [222,]    3    1    1    1    4 #> [223,]    3    1    1    2    3 #> [224,]    3    1    1    3    2 #> [225,]    3    1    1    4    1 #> [226,]    3    1    2    1    3 #> [227,]    3    1    2    2    2 #> [228,]    3    1    2    3    1 #> [229,]    3    1    3    1    2 #> [230,]    3    1    3    2    1 #> [231,]    3    1    4    1    1 #> [232,]    3    2    1    1    3 #> [233,]    3    2    1    2    2 #> [234,]    3    2    1    3    1 #> [235,]    3    2    2    1    2 #> [236,]    3    2    2    2    1 #> [237,]    3    2    3    1    1 #> [238,]    3    3    1    1    2 #> [239,]    3    3    1    2    1 #> [240,]    3    3    2    1    1 #> [241,]    3    4    1    1    1 #> [242,]    4    1    1    1    3 #> [243,]    4    1    1    2    2 #> [244,]    4    1    1    3    1 #> [245,]    4    1    2    1    2 #> [246,]    4    1    2    2    1 #> [247,]    4    1    3    1    1 #> [248,]    4    2    1    1    2 #> [249,]    4    2    1    2    1 #> [250,]    4    2    2    1    1 #> [251,]    4    3    1    1    1 #> [252,]    5    1    1    1    2 #> [253,]    5    1    1    2    1 #> [254,]    5    1    2    1    1 #> [255,]    5    2    1    1    1 #> [256,]    6    1    1    1    1  set.seed(111) partitionsGeneral(sample(1000, 20), 5, TRUE, target = 2500) #>       [,1] [,2] [,3] [,4] [,5] #>  [1,]   45   45  586  904  920 #>  [2,]   45   45  602  904  904 #>  [3,]   45  175  507  794  979 #>  [4,]   45  175  602  699  979 #>  [5,]   45  281  334  920  920 #>  [6,]   45  281  586  794  794 #>  [7,]   45  584  586  586  699 #>  [8,]   69  175  584  793  879 #>  [9,]   69  175  602  675  979 #> [10,]   69  305  507  699  920 #> [11,]   69  334  699  699  699 #> [12,]   69  584  586  586  675 #> [13,]  281  334  507  584  794 #> [14,]  281  334  584  602  699 #> [15,]  305  334  584  602  675  system.time(one_thread  <- partitionsGeneral(80, 10, TRUE)) #>    user  system elapsed  #>   0.006   0.002   0.008  system.time(two_threads <- partitionsGeneral(80, 10, TRUE, nThreads = 2)) #>    user  system elapsed  #>   0.006   0.005   0.006  identical(one_thread, two_threads) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":null,"dir":"Reference","previous_headings":"","what":"Partition/Composition Iterator — partitionsIter","title":"Partition/Composition Iterator — partitionsIter","text":"Returns iterator iterating partitions/compositions numbers. Supports random access via [[ method. GMP support allows exploration cases number partitions/compositions large. Use next methods obtain results lexicographical order.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partition/Composition Iterator — partitionsIter","text":"","code":"partitionsIter(v, m = NULL, ...) compositionsIter(v, m = NULL, ...)  # Default S3 method partitionsIter(v, m = NULL, repetition = FALSE,                freqs = NULL, target = NULL,                nThreads = NULL, tolerance = NULL, ...)  # Default S3 method compositionsIter(v, m = NULL, repetition = FALSE, freqs = NULL,                  target = NULL, weak = FALSE, nThreads = NULL,                  tolerance = NULL, ...)  # S3 method for class 'table' partitionsIter(     v, m = NULL, target = NULL, nThreads = NULL, tolerance = NULL, ... ) # S3 method for class 'table' compositionsIter(     v, m = NULL, target = NULL, weak = FALSE, nThreads = NULL, tolerance = NULL, ... )"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partition/Composition Iterator — partitionsIter","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. integer numeric vectors accepted. m Width partition. m = NULL, length determined partitioning case (e.g. generating distinct partitions \\(n\\), width equal smallest \\(m\\) sum(1:m) >= n). ... arguments passed methods. repetition Logical value indicating whether partitions/compositions without repetition. default FALSE. freqs vector frequencies used producing partitions multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. target Number partitioned. NULL, max(v) used. weak (Compositions ) Logical flag indicating whether allow terms sequence zero. nThreads Specific number threads used. default NULL. tolerance numeric value greater equal zero. parameter utilized constraint applied numeric vector. default value 0 can determined whole values utilized, otherwise sqrt(.Machine$double.eps) approximately \\(1.5e-8\\). N.B. input vector type integer, parameter ignored strict equality enforced.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partition/Composition Iterator — partitionsIter","text":"nextIter called, vector returned Otherwise, matrix \\(m\\) columns","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partition/Composition Iterator — partitionsIter","text":"initialize new iterator, following methods available: nextIter Retrieve next lexicographical result nextNIter Pass integer n retrieve next n lexicographical results nextRemaining Retrieve remaining lexicographical results currIter Returns current iteration startOver Resets iterator sourceVector View source vector summary Returns list summary information iterator front Retrieve first lexicographical result back Retrieve last lexicographical result [[ Random access method. Pass single value vector valid indices. single value passed, internal index iterator updated, however vector passed internal state change. GMP support allows flexible indexing.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Partition/Composition Iterator — partitionsIter","text":"nThreads utilized, take effect number elements requested greater threshold (determined internally). E.g: nThreads ignored following cases (.e. Generating \\(n^{th}\\) partition cases currently unavailable): standard multisets. zero element non-trivial multiplicity, multithreading possible. source vector isomorphic 1:length(v) maximum number partitions/compositions can generated one time \\(2^{31} - 1\\).","code":"serial   <- partitionsIter(1000, 10) multi    <- partitionsIter(1000, 10, nThreads = 4) fetch1e6 <- multi@nextNIter(1e6)  ## much faster than serial@nextNIter(1e6) fetch1e3 <- multi@nextNIter(1e3)  ## only one thread used... same as serial@nextNIter(1e3)library(microbenchmark) microbenchmark(multi@nextNIter(1e6), serial@nextNIter(1e6)) microbenchmark(multi@nextNIter(1e3), serial@nextNIter(1e3))"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Partition/Composition Iterator — partitionsIter","text":"Lexicographical Order Subset Sum Problem Partition (number theory) Composition (combinatorics))","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Partition/Composition Iterator — partitionsIter","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsIterator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partition/Composition Iterator — partitionsIter","text":"","code":"a = partitionsIter(0:10, repetition = TRUE) a@nextIter() #>  [1]  0  0  0  0  0  0  0  0  0 10 a@nextNIter(3) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    0    0    0    0    0    0    0    0    1     9 #> [2,]    0    0    0    0    0    0    0    0    2     8 #> [3,]    0    0    0    0    0    0    0    0    3     7 a@front() #>  [1]  0  0  0  0  0  0  0  0  0 10 a@nextRemaining() #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    0    0    0    0    0    0    0    0    1     9 #>  [2,]    0    0    0    0    0    0    0    0    2     8 #>  [3,]    0    0    0    0    0    0    0    0    3     7 #>  [4,]    0    0    0    0    0    0    0    0    4     6 #>  [5,]    0    0    0    0    0    0    0    0    5     5 #>  [6,]    0    0    0    0    0    0    0    1    1     8 #>  [7,]    0    0    0    0    0    0    0    1    2     7 #>  [8,]    0    0    0    0    0    0    0    1    3     6 #>  [9,]    0    0    0    0    0    0    0    1    4     5 #> [10,]    0    0    0    0    0    0    0    2    2     6 #> [11,]    0    0    0    0    0    0    0    2    3     5 #> [12,]    0    0    0    0    0    0    0    2    4     4 #> [13,]    0    0    0    0    0    0    0    3    3     4 #> [14,]    0    0    0    0    0    0    1    1    1     7 #> [15,]    0    0    0    0    0    0    1    1    2     6 #> [16,]    0    0    0    0    0    0    1    1    3     5 #> [17,]    0    0    0    0    0    0    1    1    4     4 #> [18,]    0    0    0    0    0    0    1    2    2     5 #> [19,]    0    0    0    0    0    0    1    2    3     4 #> [20,]    0    0    0    0    0    0    1    3    3     3 #> [21,]    0    0    0    0    0    0    2    2    2     4 #> [22,]    0    0    0    0    0    0    2    2    3     3 #> [23,]    0    0    0    0    0    1    1    1    1     6 #> [24,]    0    0    0    0    0    1    1    1    2     5 #> [25,]    0    0    0    0    0    1    1    1    3     4 #> [26,]    0    0    0    0    0    1    1    2    2     4 #> [27,]    0    0    0    0    0    1    1    2    3     3 #> [28,]    0    0    0    0    0    1    2    2    2     3 #> [29,]    0    0    0    0    0    2    2    2    2     2 #> [30,]    0    0    0    0    1    1    1    1    1     5 #> [31,]    0    0    0    0    1    1    1    1    2     4 #> [32,]    0    0    0    0    1    1    1    1    3     3 #> [33,]    0    0    0    0    1    1    1    2    2     3 #> [34,]    0    0    0    0    1    1    2    2    2     2 #> [35,]    0    0    0    1    1    1    1    1    1     4 #> [36,]    0    0    0    1    1    1    1    1    2     3 #> [37,]    0    0    0    1    1    1    1    2    2     2 #> [38,]    0    0    1    1    1    1    1    1    1     3 #> [39,]    0    0    1    1    1    1    1    1    2     2 #> [40,]    0    1    1    1    1    1    1    1    1     2 #> [41,]    1    1    1    1    1    1    1    1    1     1 a@summary() #> $description #> [1] \"Partitions with repetition of 10 into 10 parts\" #>  #> $currentIndex #> [1] 43 #>  #> $totalResults #> [1] 42 #>  #> $totalRemaining #> [1] -1 #>  a@back() #>  [1] 1 1 1 1 1 1 1 1 1 1 a[[5]] #>  [1] 0 0 0 0 0 0 0 0 4 6 a@summary() #> $description #> [1] \"Partitions with repetition of 10 into 10 parts\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 42 #>  #> $totalRemaining #> [1] 37 #>  a[[c(1, 17, 3)]] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    0    0    0    0    0    0    0    0    0    10 #> [2,]    0    0    0    0    0    0    1    1    3     5 #> [3,]    0    0    0    0    0    0    0    0    2     8 a@summary() #> $description #> [1] \"Partitions with repetition of 10 into 10 parts\" #>  #> $currentIndex #> [1] 5 #>  #> $totalResults #> [1] 42 #>  #> $totalRemaining #> [1] 37 #>   ## Multisets... no random access b = partitionsIter(40, 5, freqs = rep(1:4, 10), target = 80) b@nextIter() #> [1]  1  2  2 35 40 b@nextNIter(10) #>       [,1] [,2] [,3] [,4] [,5] #>  [1,]    1    2    2   36   39 #>  [2,]    1    2    2   37   38 #>  [3,]    1    2    3   34   40 #>  [4,]    1    2    3   35   39 #>  [5,]    1    2    3   36   38 #>  [6,]    1    2    4   33   40 #>  [7,]    1    2    4   34   39 #>  [8,]    1    2    4   35   38 #>  [9,]    1    2    4   36   37 #> [10,]    1    2    5   32   40 b@summary() #> $description #> [1] \"Partitions of a multiset of 80 into 5 parts\" #>  #> $currentIndex #> [1] 11 #>  #> $totalResults #> [1] 10144 #>  #> $totalRemaining #> [1] 10133 #>  b@nextIter() #> [1]  1  2  5 33 39 b@currIter() #> [1]  1  2  5 33 39"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank Partitions/Compositions — partitionsRank","title":"Rank Partitions/Compositions — partitionsRank","text":"Generate rank (lexicographically) partitions/compositions. functions complement partitions/compositionsSample. See examples . GMP support allows exploration partitions/compositions vectors many elements.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank Partitions/Compositions — partitionsRank","text":"","code":"partitionsRank(..., v, repetition = FALSE, freqs = NULL, target = NULL)  compositionsRank(..., v, repetition = FALSE, freqs = NULL,                  target = NULL, weak = FALSE)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank Partitions/Compositions — partitionsRank","text":"... vectors matrices ranked. v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. atomic types supported (See .atomic). repetition Logical value indicating whether partitions/compositions without repetition. default FALSE. freqs vector frequencies used producing partitions multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. target Number partitioned. NULL, max(v) used. weak (Compositions ) Logical flag indicating whether allow terms sequence zero.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank Partitions/Compositions — partitionsRank","text":"algorithms rely efficiently ranking \\(n^{th}\\) lexicographical partition.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank Partitions/Compositions — partitionsRank","text":"vector class integer, numeric, bigz determined total number partitions/compositions","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rank Partitions/Compositions — partitionsRank","text":"Lexicographical order ranking/unranking","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rank Partitions/Compositions — partitionsRank","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Rank Partitions/Compositions — partitionsRank","text":"v must supplied.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsRank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rank Partitions/Compositions — partitionsRank","text":"","code":"mySamp = partitionsSample(30, 8, TRUE, n = 5, seed = 10, namedSample = TRUE) myRank = partitionsRank(mySamp, v = 30, repetition = TRUE) all.equal(as.integer(rownames(mySamp)), myRank) #> [1] TRUE"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Partitions/Compositions — partitionsSample","title":"Sample Partitions/Compositions — partitionsSample","text":"Generate specific (lexicographically) random sample partitions/compositions number. Produce results parallel using Parallel nThreads arguments. GMP support allows exploration cases number partitions/compositions large.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Partitions/Compositions — partitionsSample","text":"","code":"partitionsSample(v, m = NULL, ...) compositionsSample(v, m = NULL, ...)  # Default S3 method partitionsSample(     v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL,     n = NULL, sampleVec = NULL, seed = NULL,     nThreads = NULL, namedSample = FALSE, ... ) # Default S3 method compositionsSample(     v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL,     weak = FALSE, n = NULL, sampleVec = NULL, seed = NULL,     nThreads = NULL, namedSample = FALSE, ... )  # S3 method for class 'table' partitionsSample(     v, m = NULL, target = NULL, n = NULL,     sampleVec = NULL, seed = NULL, nThreads = NULL, namedSample = FALSE, ... ) # S3 method for class 'table' compositionsSample(     v, m = NULL, target = NULL, weak = FALSE, n = NULL,     sampleVec = NULL, seed = NULL, nThreads = NULL, namedSample = FALSE, ... )"},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Partitions/Compositions — partitionsSample","text":"v Source vector. v positive integer, converted sequence 1:v. v negative integer, converted sequence v:-1. integer numeric vectors accepted. m Width partition. m = NULL, length determined partitioning case (e.g. generating distinct partitions \\(n\\), width equal smallest \\(m\\) sum(1:m) >= n). ... arguments passed methods. repetition Logical value indicating whether partitions/compositions without repetition. default FALSE. freqs vector frequencies used producing partitions multiset v. element freqs represents many times element source vector, v, repeated. analogous times argument rep. default value NULL. target Number partitioned. NULL, max(v) used. weak (Compositions ) Logical flag indicating whether allow terms sequence zero. n Number partitions/compositions return. default NULL. sampleVec vector numbers representing lexicographical partitions/compositions return. Accepts vectors class bigz well vectors characters seed Random seed initialization. default NULL. N.B. gmp library needed, parameter must set order reproducible results (E.g set.seed() effect cases). nThreads Specific number threads used. default NULL. namedSample Logical flag. TRUE, rownames corresponding lexicographical partition, added returned matrix. default FALSE.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Partitions/Compositions — partitionsSample","text":"algorithms rely efficiently generating \\(n^{th}\\) lexicographical partition. process unranking.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Partitions/Compositions — partitionsSample","text":"matrix returned row containing vector length \\(m\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample Partitions/Compositions — partitionsSample","text":"Lexicographical order Partition (Number Theory)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample Partitions/Compositions — partitionsSample","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample Partitions/Compositions — partitionsSample","text":"partitionsSample available following cases: standard multisets. zero element non-trivial multiplicity, sampling allowed (e.g. partitionsSample(0:100, freqs = c(100, rep(1, 100)), n = 2)) source vector isomorphic 1:length(v) (e.g. v = c(1, 4, 6, 7, 8)). n sampleVec NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/partitionsSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Partitions/Compositions — partitionsSample","text":"","code":"partitionsSample(100, 10, n = 5) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    2    3    4    6    8    9   13   14   17    24 #> [2,]    2    3    4    6    8    9   11   12   20    25 #> [3,]    1    2    6    7    8   10   12   15   18    21 #> [4,]    1    3    6    7    9   11   12   16   17    18 #> [5,]    1    2    5    6    7    8   10   15   18    28 partitionsSample(100, 10, seed = 42, n = 5, target = 200) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    6    9   11   12   14   20   25   48    54 #> [2,]    1    3    6   11   12   13   17   26   49    62 #> [3,]    3    5    6    7    8   21   24   36   41    49 #> [4,]    3    6    8    9   22   27   28   29   33    35 #> [5,]    1    2    3    8   13   29   33   34   36    41  ## retrieve specific results (lexicographically) partitionsCount(100, 10, TRUE, target = 500) #> [1] 175591757896 ## [1] 175591757896 partitionsSample(100, 10, TRUE, target = 500,                  sampleVec = c(1, 1000, 175591757896)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    1    1    1    1   95  100  100  100   100 #> [2,]    1    1    1    1   16   90   94   96  100   100 #> [3,]   50   50   50   50   50   50   50   50   50    50"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":null,"dir":"Reference","previous_headings":"","what":"Prime Counting Function \\(\\pi(x)\\) — primeCount","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"Prime counting function counting prime numbers less integer, \\(n\\), using Legendre's formula. based algorithm developed Kim Walisch found : kimwalisch/primecount.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"","code":"primeCount(n, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"n Positive number nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"Legendre's Formula counting number primes less \\(n\\) makes use inclusion-exclusion principle avoid explicitly counting every prime \\(n\\). given : $$\\pi(x) = \\pi(\\sqrt x) + \\Phi(x, \\sqrt x) - 1$$ \\(\\Phi(x, )\\) number positive integers less equal \\(x\\) relatively prime first \\(\\) primes (.e. divisible first \\(\\) primes). given recurrence relation (\\(p_a\\) \\(ath\\) prime (e.g. \\(p_4 = 7\\))): $$\\Phi(x, ) = \\Phi(x, - 1) + \\Phi(x / p_a, - 1)$$ algorithm implements five modifications developed Kim Walisch calculating \\(\\Phi(x, )\\) efficiently. Cache results \\(\\Phi(x, )\\) Calculate \\(\\Phi(x, )\\) using \\(\\Phi(x, ) = (x / pp) * \\phi(pp) + \\Phi(x mod pp, )\\)  \\(<= 6\\) \\(pp = 2 * 3 * ... * \\) prime[] \\(\\phi(pp) = (2 - 1) * (3 - 1) * ... * \\) \\((\\)prime[] \\(- 1)\\) (.e. Euler's totient function) Calculate \\(\\Phi(x, )\\) using \\(\\pi(x)\\) lookup table Calculate \\(\\Phi(x, ) = 1\\) upfront Stop recursion \\(6\\) \\(\\sqrt x >= 13\\) \\(\\pi(\\sqrt x)\\) instead \\(1\\)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"maximum value \\(n\\) \\(2^{53} - 1\\)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"Computing \\(\\pi(x)\\): combinatorial method Tomás Oliveira e Silva, Computing pi(x): combinatorial method, Revista DETUA, vol. 4, . 6, March 2006, p. 761. https://sweet.ua.pt/tos/bib/5.4.pdf 53-bit significand precision","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"Whole number representing number prime numbers less equal \\(n\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeCount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prime Counting Function \\(\\pi(x)\\) — primeCount","text":"","code":"## Get the number of primes less than a billion primeCount(10^9) #> [1] 50847534  ## Using nThreads system.time(primeCount(10^10, nThreads = 2)) #>    user  system elapsed  #>   0.020   0.001   0.015"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorized Prime Factorization — primeFactorize","title":"Vectorized Prime Factorization — primeFactorize","text":"Implementation Pollard's rho algorithm generating prime factorization. algorithm based \"factorize.c\" source file gmp library found https://gmplib.org.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorized Prime Factorization — primeFactorize","text":"","code":"primeFactorize(v, namedList = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorized Prime Factorization — primeFactorize","text":"v Vector integers numeric values. Non-integral values cured whole numbers. namedList Logical flag. TRUE length(v) > 1, named list returned. default FALSE. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vectorized Prime Factorization — primeFactorize","text":"noted Description section , algorithm based \"factorize.c\" source code gmp library. Much code RcppAlgos::primeFactorize straightforward translation multiple precision C data types standard C++ data types. crucial part algorithm's efficiency based quickly determining primality, easily computed gmp. However, standard C++, quite challenging. Much research RcppAlgos::primeFactorize focused developing algorithm accurately efficiently compute primality. details, see documentation isPrimeRcpp.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorized Prime Factorization — primeFactorize","text":"Returns unnamed vector length(v) == 1 regardless value namedList. \\(v < 2^{31}\\), class returned vector integer, otherwise class numeric. length(v) > 1, named/unnamed list vectors returned. max(bound1, bound2) \\(< 2^{31}\\), class vector integer, otherwise class numeric.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vectorized Prime Factorization — primeFactorize","text":"Pollard's rho algorithm Miller-Rabin primality test Accurate Modular Arithmetic Double Precision 53-bit significand precision","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Vectorized Prime Factorization — primeFactorize","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Vectorized Prime Factorization — primeFactorize","text":"maximum value element \\(v\\) \\(2^{53} - 1\\).","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorized Prime Factorization — primeFactorize","text":"","code":"## Get the prime factorization of a single number primeFactorize(10^8) #>  [1] 2 2 2 2 2 2 2 2 5 5 5 5 5 5 5 5  ## Or get the prime factorization of many numbers set.seed(29) myVec <- sample(-1000000:1000000, 1000) system.time(pFacs <- primeFactorize(myVec)) #>    user  system elapsed  #>       0       0       0   ## Return named list pFacsWithNames <- primeFactorize(myVec, namedList = TRUE)  ## Using nThreads system.time(primeFactorize(myVec, nThreads = 2)) #>    user  system elapsed  #>       0       0       0"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"Generates prime factorization numbers bound1 bound2 (supplied) numbers bound1.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"","code":"primeFactorizeSieve(bound1, bound2 = NULL, namedList = FALSE, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"bound1 Positive integer numeric value. bound2 Positive integer numeric value. namedList Logical flag. TRUE, named list returned. default FALSE. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"function useful many prime factorizations needed. Instead generating prime factorization fly, one can reference indices/names generated list. algorithm benefits greatly fast integer division library 'libdivide'. following https://libdivide.com/: “libdivide allows replace expensive integer divides comparatively cheap multiplication bitshifts. Compilers usually , divisor known compile time. libdivide allows take advantage runtime. result integer division can become faster - lot faster.”","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"Returns named/unnamed list integer vectors max(bound1, bound2) \\(< 2^{31}\\), list numeric vectors otherwise.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"maximum value either bounds \\(2^{53} - 1\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"Prime Factor ridiculousfish (author libdivide) github.com/ridiculousfish/libdivide 53-bit significand precision","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"Joseph Wood","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeFactorizeSieve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Prime Factorization for Numbers in a Range — primeFactorizeSieve","text":"","code":"## Generate some random data set.seed(28) mySamp <- sample(10^5, 5*10^4)  ## Generate prime factorizations up ## to 10^5 (max element from mySamp) system.time(allPFacs <- primeFactorizeSieve(10^5)) #>    user  system elapsed  #>    0.02    0.00    0.02   ## Use generated prime factorization for further ## analysis by accessing the index of allPFacs for (s in mySamp) {     pFac <- allPFacs[[s]]     ## Continue algorithm }  ## Generating prime factorizations over ## a range is efficient as well system.time(primeFactorizeSieve(10^12, 10^12 + 10^5)) #>    user  system elapsed  #>   0.033   0.000   0.033   ## Set 'namedList' to TRUE to return a named list primeFactorizeSieve(27, 30, namedList = TRUE) #> $`27` #> [1] 3 3 3 #>  #> $`28` #> [1] 2 2 7 #>  #> $`29` #> [1] 29 #>  #> $`30` #> [1] 2 3 5 #>   ## Using nThreads system.time(primeFactorizeSieve(1e4, 5e4, nThreads = 2)) #>    user  system elapsed  #>   0.008   0.000   0.006"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Prime Numbers — primeSieve","title":"Generate Prime Numbers — primeSieve","text":"Implementation segmented sieve Eratosthenes wheel factorization. Generates prime numbers bound1 bound2 (supplied) primes bound1. See stackoverflow post analysis prime number generation efficiency R: Generate list primes certain number fundamental concepts algorithm based implementation Kim Walisch found : kimwalisch/primesieve.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Prime Numbers — primeSieve","text":"","code":"primeSieve(bound1, bound2 = NULL, nThreads = NULL)"},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Prime Numbers — primeSieve","text":"bound1 Positive integer numeric value. bound2 Positive integer numeric value. nThreads Specific number threads used. default NULL.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Prime Numbers — primeSieve","text":"matter bound larger resulting primes min(bound1, bound2) max(bound1, bound2) bound2 provided. maximum value either bounds \\(2^{53} - 1\\).","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Prime Numbers — primeSieve","text":"heart algorithm traditional sieve Eratosthenes (.e. given prime \\(p\\), mark multiples \\(p\\) composite), however instead sieving entire interval, consider small sub-intervals. benefits method two fold: Reduction space complexity \\(O(n)\\), traditional sieve, \\(O(\\sqrt n)\\) Reduction cache misses latter particular importance cache memory much efficient closer proximity CPU main memory. Reducing size sieving interval allows effective utilization cache, greatly impacts overall efficiency. Another optimization traditional sieve utilization wheel factorization. traditional sieve Eratosthenes, typically check every odd index logical vector value true, found prime. wheel factorization using first four primes (.e. 2, 3, 5, 7) construct wheel (.e. 210 wheel), check indices logical vector coprime 210 (.e. product first four primes). example, \\(n = 10000\\) 210 wheel, check 2285 indices vs. 5000 classical implementation.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Prime Numbers — primeSieve","text":"Returns integer vector max(bound1, bound2) \\(< 2^{31}\\), numeric vector otherwise.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Prime Numbers — primeSieve","text":"primesieve (Fast C/C++ prime number generator) Sieve Eratosthenes Wheel factorization 53-bit significand precision","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Prime Numbers — primeSieve","text":"Joseph Wood","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/primeSieve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Prime Numbers — primeSieve","text":"","code":"## Primes up to a thousand primeSieve(100) #>  [1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97  ## Primes between 42 and 17 primeSieve(42, 17) #> [1] 17 19 23 29 31 37 41  ## Equivalent to primeSieve(17, 42) #> [1] 17 19 23 29 31 37 41  ## Primes up to one hundred million in no time system.time(primeSieve(10^8)) #>    user  system elapsed  #>   0.111   0.005   0.115   ## options(scipen = 50) ## Generate large primes over interval system.time(myPs <- primeSieve(10^13+10^6, 10^13)) #>    user  system elapsed  #>    0.01    0.00    0.01  ## Object created is small object.size(myPs) #> 267696 bytes  ## Using nThreads system.time(primeSieve(1e7, nThreads = 2)) #>    user  system elapsed  #>   0.012   0.000   0.007"},{"path":"https://jwood000.github.io/RcppAlgos/reference/stdThreadMax.html","id":null,"dir":"Reference","previous_headings":"","what":"Max Number of Concurrent Threads — stdThreadMax","title":"Max Number of Concurrent Threads — stdThreadMax","text":"Wrapper std::thread::hardware_concurrency(). stated cppreference, returned value considered hint.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/reference/stdThreadMax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Max Number of Concurrent Threads — stdThreadMax","text":"","code":"stdThreadMax()"},{"path":"https://jwood000.github.io/RcppAlgos/reference/stdThreadMax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Max Number of Concurrent Threads — stdThreadMax","text":"integer representing number concurrent threads supported user implementation. value determined, 1L returned.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/reference/stdThreadMax.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Max Number of Concurrent Threads — stdThreadMax","text":"","code":"stdThreadMax() #> [1] 4"},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-9-5","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.9.5","text":"Fixed CITATION metadata can read CRAN incoming checks. Corrected malformed GitHub issue URL updated redirected/broken links.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-9-4","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.9.4","text":"Replaced non-API use ATTRIB C++ internals satisfy CRAN checks. Improved handling diagnostics classed raw-vector inputs (e.g. bigz/mpfr). Refreshed documentation URLs current canonical links.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-293","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.9.3","title":"RcppAlgos 2.9.3","text":"CRAN release: 2025-02-03","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-9-3","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.9.3","text":"Corrected spelling DESCRIPTION","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-9-2","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.9.2","text":"Fixed clang-ASAN issue arising calling vector::front empty container.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-291","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.9.1","title":"RcppAlgos 2.9.1","text":"CRAN release: 2025-01-27","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-9-1","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.9.1","text":"Fixed urls","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-9-0","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.9.0","text":"Added Cartesian product functions: expandGrid, expandGridCount, expandGridSample, expandGridIter.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-9-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.9.0","text":"Fixed issue comboGroup groups size 1 passed. See Issue #53.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-285","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.8.5","title":"RcppAlgos 2.8.5","text":"CRAN release: 2024-10-11","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-8-5","dir":"Changelog","previous_headings":"","what":"Other","title":"RcppAlgos 2.8.5","text":"Updated Author field removed Maintainer field DESCRIPTION file per W.R.E.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-8-5","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.8.5","text":"Fixed LLVM-19 error occurring libdivide header. See PR #113.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-8-4","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.8.4","text":"Can now pass integer convertible results sample functions n parameter.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-8-4","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.8.4","text":"Fixed bug iterator multithreading exhausting iterator. Enforced values converted primitive length 1.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-283","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.8.3","title":"RcppAlgos 2.8.3","text":"CRAN release: 2023-12-10","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-8-3","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.8.3","text":"Now combination permutation functions flexible S3 methods. Added ... allow passing additional arguments FUN. example: comboGeneral(letters, 3, FUN = paste, collapse = \", \").","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-8-3","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.8.3","text":"Added explicit type conversion Rprintf.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-282","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.8.2","title":"RcppAlgos 2.8.2","text":"CRAN release: 2023-10-02","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-8-2","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.8.2","text":"added comboGroupsIter. flexible iterator iterating partitions groups. Offers random access, ability retrieve next group next n groups time keeping memory low.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-281","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.8.1","title":"RcppAlgos 2.8.1","text":"CRAN release: 2023-08-14","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-8-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.8.1","text":"Fixed integer overflow bug converting vector size number rows matrix. See Issue #45. Fixed constraint permutation iterator. fix, user requested certain number results std::next_permutation algorithm exhausted, next iteration requested nonsensical.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-280","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.8.0","title":"RcppAlgos 2.8.0","text":"CRAN release: 2023-07-10","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-8-0","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.8.0","text":"comboGroups can now handle groups different sizes.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-272","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.7.2","title":"RcppAlgos 2.7.2","text":"CRAN release: 2023-02-11","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-7-2","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.7.2","text":"Using copy gmpxx.h source order easily build platforms.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-271","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.7.1","title":"RcppAlgos 2.7.1","text":"CRAN release: 2023-02-06","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-7-1","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.7.1","text":"Updated default C++ specification.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-7-0","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.7.0","text":"Now using gmpxx.h instead gmp.h.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-260","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.6.0","title":"RcppAlgos 2.6.0","text":"CRAN release: 2022-08-15","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-6-0","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.6.0","text":"Added integer composition functions: compositionsCount, compositionsGeneral, compositionsSample, compositionsIter, compositionsRank.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-5-5","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.5.5","text":"Added ranking functions: comboRank, permuteRank, partitionsRank. Added back ability interrupt general constraint problems via cpp11::check_user_interrupt().","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-5-5","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.5.5","text":"Corrected () conditions comparing class() string. Changed .character.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-5-5","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.5.5","text":"Now checking class input vector partition funcitons. Now partitionsCount returns 0, number results zero. , checking count partitions greater zero, otherwise use standard combinatorial counting functions determine number results. lead strange results elements present original vector. partitionsSample, cases rely generating partitions one time (e.g. partitionsGeneral), number partitions isn’t calculated. leads error: “n exceeds maximum number possible results”. now fixed.","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-5-4","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.5.4","text":"Added missing includes","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-253","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.5.3","title":"RcppAlgos 2.5.3","text":"CRAN release: 2022-03-31","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-5-3","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.5.3","text":"Fixed urls","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-5-2","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.5.2","text":"Fixed valgrind memory issue package cpp11. Now using cpp11::stop instead Rf_error avoid longjmp (root cause memory issues).","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-5-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.5.1","text":"Fixed memory issue number results contraint less requested number.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-250","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.5.0","title":"RcppAlgos 2.5.0","text":"CRAN release: 2022-03-16","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-5-0","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.5.0","text":"Added partition specific functions: partionsGeneral, partitionsCount, partitionsIter, partitionsSample comboIter permuteIter now work constraints. Dropped Rcpp RcppThread dependency reduce compile time binary size. result, longer ability interrupt long running processes. investigate next release. added parameter FUN.VALUE comboGeneral permuteGeneral. acts template return value FUN. implementation modeled vapply.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"enhancements-2-5-0","dir":"Changelog","previous_headings":"","what":"Enhancements:","title":"RcppAlgos 2.5.0","text":"Improved underlying algorithm comboGrid memory efficient. Made minor changes make data types consistent primeCount primeSieve.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-5-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.5.0","text":"permuteGeneral used multisets width maximized, multithreading fail. fixed 2.5.0. Fixed bug retreiving nth result comboGroup comboGroupSample number results greater 2^31 - 1 less 2^53 - 1. E.g. comboGroupsSample(27, 9, seed = 4, sampleVec = 1606990240475839) gives incorrect results 5th group prior versions. Now fixed!.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-5-0","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.5.0","text":"version longer output lexicographical composititions special circumstances outlined older documentation using permuteGeneral. done consistency felt output diverged much general constrained output permuteGeneral (See Output Order permuteGeneral). Research initial stage focused implementing new family functions similar partition family functions, compositions.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-243","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.4.3","title":"RcppAlgos 2.4.3","text":"CRAN release: 2021-05-30","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-4-3","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.4.3","text":"Fixed urls","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-4-2","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.4.2","text":"Added function comboGrid efficiently generating Cartesian product order matter.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"enhancements-2-4-2","dir":"Changelog","previous_headings":"","what":"Enhancements:","title":"RcppAlgos 2.4.2","text":"Refactored code base reduce binary size","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-4-2","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.4.2","text":"Removed LazyData DESCRIPTION. Also added rmarkdown Suggests.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-241","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.4.1","title":"RcppAlgos 2.4.1","text":"CRAN release: 2020-03-24","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"other-2-4-1","dir":"Changelog","previous_headings":"","what":"Other:","title":"RcppAlgos 2.4.1","text":"Fixed urls","code":""},{"path":[]},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-4-0","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.4.0","text":"Added comboIter permuteIter. functions return iterators iterating combinations permutations. similar interface comboGeneral permuteGeneral currently work standard combinations permutations. yet work constraints (focus next release). Added “High Performance Benchmarks” “Combinatorial Iterators RcppAlgos” vignettes","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"enhancements-2-4-0","dir":"Changelog","previous_headings":"","what":"Enhancements:","title":"RcppAlgos 2.4.0","text":"Now able interrupt general constraint problems (See Interrupt Execution Rcpp::checkUserInterrupt)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-4-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.4.0","text":"2.3.5 2.3.6, mistakenly allowed constraintFun applied logical vector crashing R. corrected 2.4.0. Changed data type sizing index matrix permuteGeneral. Originally, using int output large enough, causing integer overflow thus causing index matrix improperly sized. since changed data type recommended std::size_t (See max array length limit C++?)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-236","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.3.6","title":"RcppAlgos 2.3.6","text":"CRAN release: 2020-01-29","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-3-6","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.3.6","text":"Fixed bug associated integer vectors, multisets, constraints. See Issue #12 information.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-235","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.3.5","title":"RcppAlgos 2.3.5","text":"CRAN release: 2020-01-26","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"new-features-2-3-5","dir":"Changelog","previous_headings":"","what":"New Features:","title":"RcppAlgos 2.3.5","text":"Added comboGroups, comboGroupsCount, comboGroupsSample. functions deal partitioning vector/set groups equal size. See Combinations R Groups. See related integer sequences A025035-A025042 https://oeis.org (E.g. https://oeis.org/A025036A025036 Number partitions (1, 2, ..., 4n) sets size 4.) Added vignettes (First version vignettes) Added website via excellent package pkgdown Now using C++11 instead C++14. See Issue #10 information.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"enhancements-2-3-5","dir":"Changelog","previous_headings":"","what":"Enhancements:","title":"RcppAlgos 2.3.5","text":"Extended general partitions algorithm multisets. E.g. comboGeneral(10, 8, freqs = rep(1:5, 2), constraintFun = \"sum\", comparisonFun = \"==\", limitConstraints = 55) Improved constraint algorithm general case. Added support complex raw types combinatorial functions. Improved permutation algorithm cases (.e. rep, rep, multisets). Added loop unrolling prime sieve algorithm improved efficiency.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"bug-fixes-2-3-5","dir":"Changelog","previous_headings":"","what":"Bug Fixes:","title":"RcppAlgos 2.3.5","text":"Corrected checks total number partitions assignment number rows upper applied {combo|permute}General. See Issue #9 information. permuteGeneral longer alters source vector. See Issue #11 information.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-234","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.3.4","title":"RcppAlgos 2.3.4","text":"CRAN release: 2019-07-03 Fixed clang/gcc-ASAN valgrind issues 2.3.3. issues arising finding first vector meet criteria PartitionRep/Distinct. also found issues standard functions length partition 2. algorithm eventually try access element vector index -1. fixes confirmed successful Rdevel CMD check ‘r-devel-ubsan-clang’ via docker using advice found : https://knausb.github.io/2017/06/reproducing--clang-ubsan-issue/ http://dirk.eddelbuettel.com/code/sanitizers.html.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-233","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.3.3","title":"RcppAlgos 2.3.3","text":"CRAN release: 2019-06-30 Fixed clang-UBSAN issue 2.3.2. caused populating vector ints values larger 2^31 - 1. Added optimized algorithm {combo|permute}General constraintFun = \"sum\", comparisonFun = \"==\", vector passed special form. problem special case subset sum problem. Using std::vector push_back member function instead pre-allocating matrix constraint applied {combo|permute}General. alleviates need guess upper limit subsequently subset elements meet constraints added. Fixed error PollardRho.cpp number passed factors close limit predefined lookup table (.e. constexpr int64_t FirstOmittedPrime = 3989)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-232","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.3.2","title":"RcppAlgos 2.3.2","text":"CRAN release: 2019-04-14 Fixed clang-UBSAN issue 2.3.1. caused casting extremely large values int64_t. Corrected handling small values PrimeSieveBig.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-231","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.3.1","title":"RcppAlgos 2.3.1","text":"CRAN release: 2019-03-21 Explicitly casted double sqrt silence Solaris Corrected handling NaNs","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-230","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.3.0","title":"RcppAlgos 2.3.0","text":"CRAN release: 2019-03-17 functions now parallel capabilities via RcppThread. Utilizes RMatrix.h RcppParallel thread safe matrix class. Major overhaul primeSieve large primes. Added stdThreadMax obtaining number threads available machine","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-220","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.2.0","title":"RcppAlgos 2.2.0","text":"CRAN release: 2018-09-14 Disabled Parallel argument causing unpredictable errors certain platforms. Research ongoing correct use future versions. development version retain feature. Corrected UBSAN error caused filling vector integers numbers larger 2^31 - 1.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-210","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.1.0","title":"RcppAlgos 2.1.0","text":"CRAN release: 2018-09-11 Added argument Parallel general sampling functions increased gains efficiency. comboGeneral(30, 10, Parallel = TRUE) permuteGeneral(12, 7, TRUE, constraintFun = \"sum\", Parallel = TRUE) Logical class now preserved combinatorial functions Added gmp support combinatorial functions. Now, one can accurately quickly work combinations/permutations large vectors E.g.: comboSample(runif(10000), 100, n = 10, seed = 42, Parallel = TRUE) permuteGeneral(factor(state.name), 20, lower = 1e15, upper = 1e15 + 1000) Added FUN argument combinatorial functions. Allows user pass custom functions applied combinations/permutations.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-203","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.0.3","title":"RcppAlgos 2.0.3","text":"CRAN release: 2018-06-30 Corrected clang UBSAN error identified two different unit tests. situations, problem occurring result populating vector integers values vector doubles contained NaN (--Number). information obtained Brian J. Knaus’s blog titled : “Reproducing clang-UBSAN issue” (https://knausb.github.io/2017/06/reproducing--clang-ubsan-issue/)","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-202","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.0.2","title":"RcppAlgos 2.0.2","text":"CRAN release: 2018-06-14 Corrected divide zero divisorsRcpp unit test.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-201","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.0.1","title":"RcppAlgos 2.0.1","text":"CRAN release: 2018-06-10 Corrected spelling DESCRIPTION","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-200","dir":"Changelog","previous_headings":"","what":"RcppAlgos 2.0.0","title":"RcppAlgos 2.0.0","text":"Changed max value explicitly casted values int64_t PollardRho.cpp efficiency still maintaining accuracy 2^60 2^62 (isPrimeRcpp roughly 10% faster now). Updated core permutation algorithm greater efficiency generality Added capability generating specific combinations/permutations Changed arguments comboGeneral/permuteGeneral. rowCap now upper. Added comboSample, permuteSample, comboCount, permuteCount Fixed bug numDivisorSieve divisorSieve lower bound greater 1 less sqrt upper bound. previous version, numbers range duplicated values/counts. Increased efficiency numDivisorSieve factor 2. Updated unit tests greater coverage. See function package_coverage package covr.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-101","dir":"Changelog","previous_headings":"","what":"RcppAlgos 1.0.1","title":"RcppAlgos 1.0.1","text":"CRAN release: 2018-03-10 Corrected precision limits documentation 2^64 2^63. Changed const type PollardRho.cpp int64_t double correct “UndefinedBehaviorSanitizer” Changed examples primeFactorizeSieve reduce check time Added RcppAlgos-package man file.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-100","dir":"Changelog","previous_headings":"","what":"RcppAlgos 1.0.0","title":"RcppAlgos 1.0.0","text":"CRAN release: 2018-03-07 Added following functions: primeFactorize (vectorized pollard rho factorization), divisorsRcpp (vectorized factoring (complete)), isPrimeRcpp (vectorized primality testing using Miller-Rabin algorithm), & primeCount (based primecount algorithm Kim Walisch) Completely revamped primeSieve function. now segmented sieve Eratosthenes wheel factorization based primesieve Kim Walisch. Renamed divisorsList divisorsSieve (reason major version update 1.0.0) Renamed primeFactorizationList primeFactorizeSieve Made sieving functions flexible. now able generate results range can also produce named objects. number theoretic functions made efficient. make use fast integer division library libdivide ridiculousfish.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-025","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.2.5","title":"RcppAlgos 0.2.5","text":"CRAN release: 2018-01-04 Added unit tests. Removed unnecessary files. Fixed bug primeSieve occurred number decimal passed (e.g. 2.01). Adjusted accepted lower bound numDivisorSieve, eulerPhiSieve, divisorsList, primeSieve, primeFactorizationList. Fixed bug non-unique elements present factors.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-024","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.2.4","title":"RcppAlgos 0.2.4","text":"CRAN release: 2017-12-18 Fixed bug occurs non-unique elements present combinations replacement.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-023","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.2.3","title":"RcppAlgos 0.2.3","text":"Fixed segmentation fault error highlighted valgrind check version 0.2.2. Updated DESCRIPTION file.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-022","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.2.2","title":"RcppAlgos 0.2.2","text":"CRAN release: 2017-12-15 Fixed bug constraint functions occurred m = 1 constraint limit equal last element v. returning 2x1 matrix value twice. now correctly returning 1x1 matrix correct value 1 time. Reorganized source code utility functions combinatoric functions now file. Additionally added header file. combinatoric functions can now utilize rowCap argument. , rowCap applied combinatorial functions constraints. comboGeneral can now find combinations multisets. comboGeneral permuteGeneral can utilize argument m dealing multisets. , permuteGeneral simply return permutations multiset. Now can specify lengths output.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-021","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.2.1","title":"RcppAlgos 0.2.1","text":"CRAN release: 2017-11-29 Fixed bug occur two edge cases involving constraint functions. Slightly modified formatting primeSieve.Rd","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-020","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.2.0","title":"RcppAlgos 0.2.0","text":"CRAN release: 2017-11-28 Updated combination algorithms. now twice fast. Updated constraint functions memory access always within container bounds Consolidated redundant code outputting different Rcpp types (e.g. IntegerMatrix, CharacterMatrix, etc.) via templated approach. Added function permuteGeneral analogous comboGeneral instead combinations, gives permutations. additional argument (.e. ‘freqs’) used generate permutations multisets. combinatoric functions now support factor types.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-012","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.1.2","title":"RcppAlgos 0.1.2","text":"CRAN release: 2017-11-03 Corrected minor typo README file. Fixed minor error regarding explicitly comparing variables large numbers typed . Simply adding decimal along zero remedies situation.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-011","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.1.1","title":"RcppAlgos 0.1.1","text":"CRAN release: 2017-11-03 Improved ComboConstraint function removing unnecessary subsetting. Improved PrimeSieve internal C++ algorithm. Corrected errors respect math functions C++. Explicitly overloaded parameters functions casting double type.","code":""},{"path":"https://jwood000.github.io/RcppAlgos/news/index.html","id":"rcppalgos-010","dir":"Changelog","previous_headings":"","what":"RcppAlgos 0.1.0","title":"RcppAlgos 0.1.0","text":"CRAN release: 2017-10-26 Initial Release","code":""}]
